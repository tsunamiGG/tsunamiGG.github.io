{"meta":{"title":"Secret Garden","subtitle":"","description":"","author":"tsunamiGG","url":"https://tsunamiGG.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2020-05-17T13:00:41.486Z","updated":"2020-05-17T13:00:41.486Z","comments":true,"path":"categories/index.html","permalink":"https://tsunamigg.github.io/categories/index.html","excerpt":"","text":"javascript"},{"title":"关于","date":"2020-05-17T12:59:07.730Z","updated":"2020-05-17T12:59:07.730Z","comments":true,"path":"about/index.html","permalink":"https://tsunamigg.github.io/about/index.html","excerpt":"","text":"占个位子"},{"title":"所有标签","date":"2020-05-17T13:01:21.307Z","updated":"2020-05-17T13:01:21.307Z","comments":true,"path":"tags/index.html","permalink":"https://tsunamigg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"走好下一步","slug":"reload","date":"2020-05-23T14:48:07.000Z","updated":"2020-05-23T14:52:29.238Z","comments":true,"path":"2020/05/23/reload/","link":"","permalink":"https://tsunamigg.github.io/2020/05/23/reload/","excerpt":"抛下过去，走向未来，成就自己","text":"抛下过去，走向未来，成就自己 前言大三下学期，觉得自己不能就此沉沦。想着自己好歹算个计算机沾边的专业，去找一份编程相关的工作，应该还是有搞头的。 在图书馆看到一本《web工程师的自我修养》，心里波澜起伏。于是，就在前端的路上一去不复返~ 折戟实习去了一家高歌猛进，疯狂增长的现已上市的在线教育公司，当我满怀憧憬，准备大干一场，现实却给我来了一记狠狠的patch。 对于没有任何项目经验，只学了俩个月基础的我来说；每天醍醐灌顶，很多事情并没有做到自己能做到的最好，更多的失误，脑子犯浑，给决定我实习是否通过的师傅留下了能力不足的印象。 从未想过会有这样的结果，每天睡不着，很多就来到工位学习知道晚上9点，与大家一起开早会，完成几个简单的任务，一起极乐汤团建，参加年会…. 对我的打击是巨大的，听着HRBP安慰的语音，思绪翻涌。我甚至开始怀疑自己真正是否能够胜任这份工作，我是不是应该听爸妈的话，回去小县城去考公务员….各种怀疑，不自信的负面情绪就像潮汐一般，想要推得越远，却弹回来越远。我知道，我失去了这辈子最重要的第二次机会。 重启？改变？在颓废2个月后，房租，电费，燃气费，一条条短信提醒着我，不能再这样下去了。 于是降低自己的要求，在武汉这样一个大环境都是外包的条件下，匆匆就签了一个40人，只有1个前端的科技公司…. 嗯，是的，对于现状非常不满意。每天写着不太感兴趣的业务，改着稀烂的代码。 如果非要说进步，那大概是磨平了棱角，刷新了对客户的认知，熟悉了微信这样稀烂的开发环境… 我仍然没有放弃，努力在工作空余时间，去看点东西，但就像一只无头苍蝇一般，乱撞。 着学习的事情不能一蹴而就，得持之以恒，系统的学。就从红宝书开始，重学基础，然后就去肯Vue源码。现在对Vue2.x的双向绑定，虚拟DOM，模板编译都有一定理解，源码中没有秘密。 如果迷茫了就开始制定计划吧迷茫来自于下时代5G的浪潮，每次通信革命都让人们的生活发生翻天覆地的变化..这次也毫不例外。是继续在本就过饱和的互联网继续挣扎还是去把握住新的风口机会？但相信自己的条件，并没有机会去抓住新风口，只能继续前进，但紧跟变化发展，发挥自己的洞察力，找到合适的机会！ 刚毕业快一年，想着给自己定一个目标。 毕业3年内，在武汉工资过万或者进入一家心里满意的公司。对前端的技能很熟练，可以独自解决业务难点，养成良好编码习惯。熟练Vue与react，啃完Vue2.x,3.x源码；深入使用canvas或者进击数据可视化等等有深度的领域。 能够写py或者其他后端语言，去捡起SQL，碰碰服务端的数据库，服务器等等。 今年，一定要跳槽！ 冲鸭！","categories":[],"tags":[{"name":"diary","slug":"diary","permalink":"https://tsunamigg.github.io/tags/diary/"}]},{"title":"Vue的变化侦测","slug":"Vue-source-learn2","date":"2020-05-22T00:40:28.000Z","updated":"2020-05-28T12:10:02.376Z","comments":true,"path":"2020/05/22/Vue-source-learn2/","link":"","permalink":"https://tsunamigg.github.io/2020/05/22/Vue-source-learn2/","excerpt":"Vue的响应式数据是如何做到的？","text":"Vue的响应式数据是如何做到的？ 变化侦测 变化侦测 = 数据观测+依赖收集+依赖更新 使用Object.defineProperty来使得数据变得可“观测” 依赖收集(Observer)：是指收集视图里的部分与数据绑定的关系 在getter中收集依赖，在setter中通知更新依赖 典型的发布-订阅模式,为了解耦，新增了一个管理对象 dep(收集某个数据相关的所有依赖)，watcher(被dep通知，更新依赖) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// observer.js// 收集依赖const Dep = require('./dep');export class Observer &#123; constructor(value) &#123; this.value = value; def(value, \"__ob__\", this); if (Array.isArray(value)) &#123; console.log(\"array\"); &#125; else &#123; this.walk(value); &#125; &#125; walk(obj) &#123; const keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj,keys[i]); &#125; &#125;&#125;function defineReactive(obj, key, val) &#123; if (arguments.length === 2) &#123; val = obj[key]; &#125; if (typeof val === 'object') &#123; new Observer(val); &#125; const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; dep.depend(); return val; &#125;, set(newval) &#123; if (val === newval) return; val = newval; dep.notify(); &#125; &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// dep.js// 依赖管理器： 1数据 ：n依赖 的一对多关系进行依赖管理，收集某个数据相关的所有依赖export default class Dep &#123; constructor() &#123; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; removeSub(sub) &#123; remove(this.subs, sub); &#125; depend() &#123; window.target &amp;&amp; this.addSub(window.target); &#125; notify() &#123; const subs = this.subs.slice(); for (let i = 0; i &lt; subs.length; i++) &#123; subs[i].update(); &#125; &#125;&#125;export function remove(arr, item) &#123; if (arr.length &gt; 1) &#123; const itemIndex = arr.indexOf(item); if (itemIndex &gt; 1) &#123; return arr.splice(itemIndex, 1); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// watcher.js// watcher表示依赖关系，通知视图更新// window.target是为了拷贝一份 watcher,添加到Dep的依赖数组中export default class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.vm = vm; this.cb = cb; this.getter = parsePath(expOrFn); this.value = this.get(); &#125; get() &#123; window.target = this; const vm = this.vm; let value = this.getter.call(vm, vm); window.target = undefined; return value; &#125; update() &#123; const oldValue = this.value; this.value = this.get(); this.cb.call(this.vm, this.value, oldValue); &#125;&#125;/** * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath('a.b.c')(data) // 2 */const bailRE = /[^\\w.$]/;export function parsePath(path) &#123; if (bailRE.test(path)) return; const segements = path.split('.'); return function (obj) &#123; for (let i = 0; i &lt; segements.length; i++) &#123; if (!obj) return; obj = obj[segements[i]]; &#125; return obj; &#125;&#125; 侦测流程 vue这套变化侦测的缺点很明显，因为利用defineProperty来进行收集，只限于读和写已有值，当我们对obj进行新增或者删除属性值时，它是监听不到的。所以在官网文档上的叙述上说明过，对数组或对象的直接增加或者删除会产生不期望的结果， 为了解决这一问题，特地增加了Vue.set和Vue.delete两个全局API 。 数组怎么办? 看到这里，对原型熟悉的人可能会问了，这种方法只针对于Obj类型，那剩下的常用的Arr类型或者其他类型呢？defineProperty数组是不可能使用的，那么我们应该怎么对数组进行依赖收集和通知更新？ 还是延续上面的思想：拦截，vue将所有数组的异变方法(能改变原有数组)拦截一波，就能知道arr啥时候被setter了。 经常面试被问到原型，原型链的what,why,那么how???? 我觉得这就是个很巧妙的实践~ 拦截数组原型上的异变方法(会改变原有宿主的方法)的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//代码位置 vue/src/core/observer/array.js/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 数组依赖收集 无论怎样,先得用walk让元素注入observer依赖，使得在getter中实例化Dep收集依赖并将数组方法拦截掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 源码位置：/src/core/observer/index.jsconst Dep = require(\"./dep\");const &#123; arrayKeys, arrayMethods &#125; = require(\"./array\");// 源码位置：src/core/observer/index.js// 使用 defineProperty 让数据可观测export class Observer &#123; constructor(value) &#123; this.value = value; this.dep = new Dep(); def(value, \"__ob__\", this); if (Array.isArray(value)) &#123; const agument = hasProto ? protoAugment : copyAugument; [agument](value, arrayMethods, arrayKeys); this.observerArray(value); &#125; else &#123; this.walk(value); &#125; &#125; walk(obj) &#123; const keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]); &#125; &#125; observerArray(ietms) &#123; for (let i = 0; i &lt; ietms.length; i++) &#123; observe(ietms[i]); &#125; &#125;&#125;export const hasProto = \"__proto__\" in &#123;&#125;;/* 复制原型属性，添加拦截*/function protoAugment(target, src, keys) &#123; target.__proto__ = src;&#125;function copyAugument(target, src, keys) &#123; for (let i = 0; i &lt; keys.length; i++) &#123; const key = key[i]; def(target, key, src[key]); &#125;&#125;/* * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。 * 如果 Value 已经存在一个Observer实例，则直接返回它 */function observe(value) &#123; if (!isObject(value) || value instanceof VNode) &#123; return; &#125; let ob; if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else &#123; ob = new Observer(value); &#125; return ob;&#125;function defineReactive(obj, key, val) &#123; let childOb = observe(val); if (arguments.length === 2) &#123; val = obj[key]; &#125; if (typeof val === \"object\") &#123; new Observer(val); &#125; const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; if (childOb) &#123; childOb.dep.depend(); &#125; return val; &#125;, set(newval) &#123; if (val === newval) return; val = newval; dep.notify(); &#125; &#125;);&#125; 通知更新 主要是还要对数组进行深度监测和新增元素侦测，在拦截的原型上进行依赖更新。 __ob__是在进行初始化observer的时候，在被监听者上面挂载了自己的实例，以便访问后进行依赖更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 源码位置：vue/src/core/observer/array.js/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 总结： vue的变化侦测与React对比Vdom和Angular的脏值检测都不一样。核心是利用defineProperty的能力，拦截所有绑定的响应式数据(data中),在拦截中添加依赖管理器Dep来收集管理依赖,用Watcher表示依赖关系本身，进行通知依赖更新。 其中，对于数组的侦测的思路是，覆盖所有数组原型的的异变方法，在覆盖后植入依赖逻辑。这套缺点就是对数组进行下标赋值操作时，vue是侦测不到的，官网文档上多处对此有说明。 相信下次，面试官问：为什么在vue中对数组下标进行赋值操作会导致不正确的响应式数据结果。这种类似的问题，你一定胸有成竹。","categories":[],"tags":[{"name":"Vue-2.6X-source-learn","slug":"Vue-2-6X-source-learn","permalink":"https://tsunamigg.github.io/tags/Vue-2-6X-source-learn/"}]},{"title":"vue源码学习（开篇）","slug":"Vue-source-learn1","date":"2020-05-10T02:37:35.000Z","updated":"2020-05-22T02:53:25.923Z","comments":true,"path":"2020/05/10/Vue-source-learn1/","link":"","permalink":"https://tsunamigg.github.io/2020/05/10/Vue-source-learn1/","excerpt":"应该如何学习源码？ 我觉得最开始有个全局观，然后切入细节的模块，带着问题去读。","text":"应该如何学习源码？ 我觉得最开始有个全局观，然后切入细节的模块，带着问题去读。 vue源码学习笔记 本篇结合了阅读 https://nlrx-wjc.github.io/Learn-Vue-Source-Code/ 的笔记，感谢wjc199366(wx)开源。 现在应该看不了了，因为发生了一些事情，大概是人民邮电出版社以影响旗下《深入浅出Vue.js》销量为由，联系微软，将电子书的仓库给关了….. 不过好在关闭之前，留了一份在本地，需要的加我微信取：tangtang1996918 阅读源码之前，建议去看看HcySunYang大佬对vue2/3中一些重要概念的解读： http://hcysun.me/vue-design/zh/essence-of-comp.html 例如：组件传出的本质是什么？Vnode是如何设计的？Vnode是如何挂载为真实DOM的？ 对阅读源码，理清思路是非常有帮助的~ 源码之中没有秘密~ 1.路线 变化侦测篇 学习Vue中如何实现数据的响应式系统，从而达到数据驱动视图。 虚拟DOM篇 学习什么是虚拟DOM，以及Vue中的DOM-Diff原理 模板编译篇 学习Vue内部是怎么把template模板编译成虚拟DOM,从而渲染出真实DOM 生命周期篇 学习Vue中组件的生命周期实现原理 实例方法篇 学习Vue中所有实例方法(即所有以$开头的方法)的实现原理 全局API篇 学习Vue中所有全局API的实现原理 指令篇 学习Vue中所有指令的实现原理 过滤器篇 学习Vue中所有过滤器的实现原理 内置组件篇 学习Vue中内置组件的实现原理 2.方法面对繁复的源码，我们应该怎么去读？ 说下适合我自己的读源码方法，抛砖引玉。 一本正经的一行行的看源码，我只能说兄弟，你他娘的真是个天才 1.一般我先扫一眼import引入的都是那些模块的js文件，一般源码的目录结构都清晰。根据引入的js文件大概都看出该js文件的依赖性，我们可以根据依赖项的多少来判断复杂程度，有个心理预期。 2.然后去看js文件主函数的输入和输出，即传参和返回都是什么，先搞清楚其主要功能。 对。不是一上来就一行行的看逻辑代码，除非你有超强的理解能力，一般是很吃力的。所以我们就先假装自己是个debug工具，先设置跳过全部函数内部细节，只观察主函数和各个内部子函数的输入和输出。(这期间肯定少不了去查看上一部引入的函数功能)。如果结合注释看了很多输入输出还是不明白其作用，那也很正常。 接下来，我们可以复制一下代码片段，做一些测试来证实部分我们对某些函数功能的猜想。有了这些，我们脑中大多都能有个框架。 其实这跟证明数学题的思路十分类似，先提出假设，然后用各种公理，定理来慢慢推导证明。 3.深入每个函数内部的细节。这个就八仙过海各显神通了。不过我觉得还可以先做减法，即根据注释解决兼容性和一些判断环境的hack先给屏蔽掉，关注每个函数主要的逻辑，等把整个模块的脉络弄清楚后，有空再去看看哪些hack。细节不清楚的同样测试，用结果去逆推过程。 4.做笔记，自己写一遍梳理清楚，把你觉得一些很精妙的思路，有趣的类比联想，方法总结，都可以记录下来 复杂的东西都是由简单的东西构成，人们擅长将东西变复杂，却不擅长将东西变简单。 3.目录结构强烈建议浏览一遍，源码中很多都是复用的，纵观全局，再某些判断上是能够帮上忙的~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120src├─ compiler│ ├─ codeframe.js│ ├─ codegen│ │ ├─ events.js│ │ └─ index.js│ ├─ create-compiler.js│ ├─ directives│ │ ├─ bind.js│ │ ├─ index.js│ │ ├─ model.js│ │ └─ on.js│ ├─ error-detector.js│ ├─ helpers.js│ ├─ index.js│ ├─ optimizer.js│ ├─ parser│ │ ├─ entity-decoder.js│ │ ├─ filter-parser.js│ │ ├─ html-parser.js│ │ ├─ index.js│ │ └─ text-parser.js│ └─ to-function.js├─ core│ ├─ components│ │ ├─ index.js│ │ └─ keep-alive.js│ ├─ config.js│ ├─ global-api│ │ ├─ assets.js│ │ ├─ extend.js│ │ ├─ index.js│ │ ├─ mixin.js│ │ └─ use.js│ ├─ index.js│ ├─ instance│ │ ├─ events.js│ │ ├─ index.js│ │ ├─ init.js│ │ ├─ inject.js│ │ ├─ lifecycle.js│ │ ├─ proxy.js│ │ ├─ render-helpers│ │ ├─ render.js│ │ └─ state.js│ ├─ observer│ │ ├─ array.js│ │ ├─ dep.js│ │ ├─ index.js│ │ ├─ scheduler.js│ │ ├─ traverse.js│ │ └─ watcher.js│ ├─ util│ │ ├─ debug.js│ │ ├─ env.js│ │ ├─ error.js│ │ ├─ index.js│ │ ├─ lang.js│ │ ├─ next-tick.js│ │ ├─ options.js│ │ ├─ perf.js│ │ └─ props.js│ └─ vdom│ ├─ create-component.js│ ├─ create-element.js│ ├─ create-functional-component.js│ ├─ helpers│ ├─ modules│ ├─ patch.js│ └─ vnode.js├─ platforms│ ├─ web│ │ ├─ compiler│ │ ├─ entry-compiler.js│ │ ├─ entry-runtime-with-compiler.js│ │ ├─ entry-runtime.js│ │ ├─ entry-server-basic-renderer.js│ │ ├─ entry-server-renderer.js│ │ ├─ runtime│ │ ├─ server│ │ └─ util│ └─ weex│ ├─ compiler│ ├─ entry-compiler.js│ ├─ entry-framework.js│ ├─ entry-runtime-factory.js│ ├─ runtime│ └─ util├─ server│ ├─ bundle-renderer│ │ ├─ create-bundle-renderer.js│ │ ├─ create-bundle-runner.js│ │ └─ source-map-support.js│ ├─ create-basic-renderer.js│ ├─ create-renderer.js│ ├─ optimizing-compiler│ │ ├─ codegen.js│ │ ├─ index.js│ │ ├─ modules.js│ │ ├─ optimizer.js│ │ └─ runtime-helpers.js│ ├─ render-context.js│ ├─ render-stream.js│ ├─ render.js│ ├─ template-renderer│ │ ├─ create-async-file-mapper.js│ │ ├─ index.js│ │ ├─ parse-template.js│ │ └─ template-stream.js│ ├─ util.js│ ├─ webpack-plugin│ │ ├─ client.js│ │ ├─ server.js│ │ └─ util.js│ └─ write.js├─ sfc│ └─ parser.js└─ shared ├─ constants.js └─ util.js","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://tsunamigg.github.io/tags/notes/"}]},{"title":"创建对象的几种方式","slug":"object-create","date":"2019-08-25T11:45:38.000Z","updated":"2020-05-17T12:48:45.034Z","comments":true,"path":"2019/08/25/object-create/","link":"","permalink":"https://tsunamigg.github.io/2019/08/25/object-create/","excerpt":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式","text":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式 1.简单工厂模式：Simple Factory工厂模式什么意思？ 如果把我们编写业务代码的过程，比作造一台电视机，那么工厂模式就是先打造好生产电视机的流水线。如何打造生产线？？？ 我们将需要工厂制造的产物的特性抽象出来，在代码上表现为我们规定其属性名称，但其属性值又参数来决定。 1234567function createBook(name, pages, author) &#123; let newBook = &#123;&#125;; newBook.name = name; newBook.pages = pages; newBook.author = author; return newBook;&#125; 这是一种工厂模式，其实现方式与之前学基础的寄生继承有点相似，也是在一个新的变量上去添加属性，使用字面量方式创建对象会比使用new高效的多。 还有一种就是先将不同型号的电视机造出来，然后通过工厂来输送到不同的产品区。 这里的工厂不在制造，而是充当deliver的角色。 123456789101112131415161718192021222324function fictionBook() &#123; this.name = '九州缥缈录'; this.story = '铁甲依然在'; this.tellStory = function()&#123; console.log(this.story) &#125;&#125;function classicBook() &#123; this.name = '假如给我三天光明'; this.author = '海伦凯勒'; this.bookauthor = function () &#123; console.log(this.author) &#125;&#125;function createBook(type) &#123; switch (type) &#123; case 'fiction': return new fictionBook(); case 'classic': return new classicBook(); &#125;&#125; 两种方式优缺点十分明显， 第一种常见方式需要我们固定某些参数类型，限制了其多样性，但相比第二种省事多了。第二种则相反，每创造一种不同型号的电视机就需要我们去创建一个新的类并向分发类添加该选项。 2.工厂方法模式: Factory Method12345678910111213141516//安全模式 const Factory = function (type, content) &#123; if (this instanceof Factory) &#123; return new this[type](content); &#125; else &#123; return new Factory(type, content); &#125; &#125;Factory.prototype = &#123; show: function(content) &#123; this.content = content; console.log(content); &#125;&#125;const test = new Factory('show', '2'); 安全模式的好处在于，在简单工厂模式上加了一层限制，如果没有创建工厂类，就直接执行该函数而不是返回工厂对象。 12345678910111213141516171819202122232425262728293031323334353637383940//抽象模式const abstractFactory = function (superType, subType) &#123; if (typeof abstractFactory[superType] === 'function' ) &#123; function F() &#123;&#125;; F.prototype = new abstractFactory[superType](); subType.constructor = subType; subType.prototype = new F(); &#125; else &#123; throw new Error('未创建该抽象类') &#125;&#125;abstractFactory.desk = function() &#123; this.type = 'desk';&#125;abstractFactory.desk.prototype = &#123; getDeskSize: function () &#123; return new Error('抽象方法不能调用') &#125;, getDeskMaterial: function() &#123; return new Error('抽象方法不能调用') &#125;&#125;//实例化抽象desk类// 1.子类构造方法let machilusDesk = function(size, material) &#123; this.size = size; this.material = material;&#125;// 2. 将子类构造方法送入工厂，继承工厂抽象方法abstractFactory('desk', machilusDesk);// 3. 覆盖抽象方法machilusDesk.prototype.getDeskSize = function() &#123; return this.size;&#125;machilusDesk.prototype.getDeskMaterial = function() &#123; return this.material;&#125; 在JS中，abstract是一个保留关键字，所以想要实现抽象类，是不可能像传统的面向对象语言那么方便，但由于其灵活性，我们可以模拟出抽象类的主要行为。 抽象方法时不可调用的，会报错，所以我们模拟出其这个行为，并且采用寄生继承来继承父类。当工厂生成子类后，覆盖抽象方法，就不会报错了。 抽象模式是提前定义了类的结构，而不是直接创建类。就像建房子先画好房子的图纸一样，先描述出其轮廓~ 但JS中不支持抽象化创建和虚拟方法，所以其引用并不广泛，但也是面向对象编程中很经典常见的一种模式。 3.建造者模式： Builder如果说工厂模式的侧重点在创建的结果，那么建造者就是注重创建过程的一种模式。 建造者会注意创建过程的每个细节，就像我们捏橡皮人时，不光要注意身体的轮廓，还要注意头有多大，四肢有多长….理所当然的创建过程会复杂很多。 其过程就是将各种特性都封装成类，然后在主类里面根据不同参数，实例化不同的特性，组成新的子类，或者叫其复合对象。 123456789101112131415161718192021222324252627function House(parmas) &#123; this.material = parmas &amp;&amp; parmas.material || '**'; this.area = parmas &amp;&amp; parmas.area || '**';&#125;House.prototype = &#123; getMaterial: function() &#123; return this.material; &#125;, getArea: function() &#123; return this.area; &#125;&#125;function material(material) &#123; this.material = material;&#125;function area(m) &#123; this.area = m * m;&#125;function newHouse(material, m) &#123; let _house = new House(); _house.material = new material(material); _house.area = new area(area); return _house;&#125; 就像搭积木一样，先把各块积木的形状找好，然后组合在一起。抛出一个问题，如果要在一个网页上呈现卡片堆砌的效果，你会怎么做呢？ 个人理解，这个模式是我们经常解决生活中问题的一种方法的抽象，复杂的问题简单化，就是将一个复杂的事物拆分成多个简单的事物，再以某种方式组合起来，来解决问题的一种方法。 4.原型模式：prototype其被称为语言之魂，它将原型对象指向创建对象的类，使这些类共享原型对象的方法和属性。 存在即合理，那么它解决了什么问题？在很多复杂的功能下，我们的子类需要继承父类的一些属性与方法，但是并非所有子类需求的属性和方法都是一致的，所以子类会从父类继承一些不必要的，增加额外开销的属性和方法。例如，一个车的父类，子类可能是跑车，轿车，SUV，越野，跑车需要整个车体结构和轿车不一样，但父类因为考虑整体性不会有特殊的车体结构，而是通用的轿车结构，那么子类就从父类继承了一些额外的负担性质的属性和方法。而子类每次实例化都会造成很多不可避免的额外开销。 原型概念就此而出，它将某些可复用，可共享的，开销大的属性和方法从父类提取出来放在原型之中，子类通过前文的某些继承方式来继承，直接获得这些属性和方法而不是每次实例化重新创建这些属性和方法，节省了很多不必要的开销。 js在原型模式下实现的原型链，让所有内置的属性和方法都享受到该模式的好处。 其实现方式就是对一个对象的拷贝，也是一种继承方式，但很特殊的一点，创建过程于它无瓜，理解这一点很重要~ 5.单例模式： singleton这是js编程中很常见的一种模式，只允许实例化一次的对象类。有时生成命名空间namespace。多人协作开发或者加载独立的第三方库的时候，我们的词语总是有限的，怎么让它们的命名互不影响呢？答案说都开辟独立的命名空间，使得其方法名都可以区分开。同时，对我们在管理静态变量也非常有帮助。 风靡很多时的Jquery就是经典的例子，其$符就是命名空间，$(&#39;className&#39;).function这样的调用方式使得代码清晰明了，一看就知道是Jquery的方法。 1234567891011let mynamespace = &#123; utils: &#123; formate: function() &#123; ..... &#125; &#125;, ajax: function() &#123; ..... &#125; MYHEIGHT: 180&#125; 其实就是封装在一个对象里面，延展开来就是模块机制，把整个js文件作为一个对象，存放不同的命名空间，避免方法名的覆盖。 怎么实现只能实例化一次的对象类？ 妈耶，用个闭包记录，如果被实例化了，就return掉，easy。 什么？ 怎么创建一个闭包？？？ 建议你去看看《你不知道的javascript》,书中详细的论述了闭包是什么，怎么创建闭包，闭包的用途又是什么，闭包背后的作用机制其实是保持对作用域的引用等等。下次有空，结合书本我们来详解一下js中的闭包，解开其神秘的面纱。 总结 创建型设计模式是一些处理对象创建的模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。 创建单类简单对象的简单工厂模式，简单的缺点也很明显，于是工厂方法模式补足创建多类的实例(其实是传入不同参数的简单工厂模式和安全模式的混合)。建造者模式则是通过组合多种简单工厂模式，来创造复杂的对象。原型模式也被成为语言之魂，将某些属性和方法放在原型对象中作为所有对象的共有属性和方法，避免了子类每次实例化都会可能创建新的不必要的，开销大的属性和方法。单例模式则是为我们的代码管理做出了卓越的贡献。这五种模式中，原型模式并不关心对象创建过程，但对创建过程做出的贡献还是有目共睹，或许这就是大佬吧，润物细无声~","categories":[],"tags":[{"name":"javascript native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"}]},{"title":"ESmodule","slug":"ESmodule","date":"2019-05-28T12:07:12.000Z","updated":"2020-05-28T13:23:16.775Z","comments":true,"path":"2019/05/28/ESmodule/","link":"","permalink":"https://tsunamigg.github.io/2019/05/28/ESmodule/","excerpt":"ESmodule的标准化完成一定会掀起波澜~","text":"ESmodule的标准化完成一定会掀起波澜~ 图说 ES Modules（转载译文）原文：ES modules: A cartoon deep-dive, Lin Clark ES modules（ESM） 是 JavaScript 官方的标准化模块系统。然而，它在标准化的道路上已经花费了近 10 年的时间。 可喜的是，标准化之路马上就要完成了。等到 2018 年 5 月 Firefox 60 发布之后，所有的主流浏览器就都支持 ESM 了。同时，Node 模块工作小组也正在为 Node.js 添加 ESM 支持。为 WebAssembly 提供 ESM 集成的工作也正在如火如荼的进行。 许多 JS 开发者都知道，对 ESM 的讨论从开始至今一直都没停过。但是很少有人真正理解 ESM 的工作原理。 今天，让我们来梳理梳理 ESM 到底解决了什么问题，以及它跟其他模块系统之间有什么区别。 为何要模块化说到 JS 编程，其实说的就是如何管理变量。编程的过程都是关于如何给变量赋值，要么直接赋值给变量，要么是把两个变量结合起来然后再把结果赋值给另一个变量 因为大部分代码都是关于改变变量的，所以如何组织这些变量就直接影响了编码质量，以及维护它们的成本。 如果代码中仅有少量的变量，那么组织起来其实是很简单的。JS 本身就提供了一种方式帮你组织变量，称为函数作用域。因为函数作用域的缘故，一个函数无法访问另一个函数中定义的变量。 这种方式是很有效的。它使得我们在写一个函数的时候，只需要考虑当前函数，而不必担心其它函数可能会改变当前函数的变量。不过，它也有不好的地方。它会让我们很难在不同函数之间共享变量。 如果我们想跟当前函数以外的函数共享变量要怎么办呢？一种通用的做法是把要共享的变量提升到上一层作用域，比如全局作用域。 在 jQuery 时代这种提升做法相当普遍。在我们加载任何 jQuery 插件之前，我们必须确保 jQuery 已经存在于全局作用域。 这种做法也确实行之有效，但是也带来了令人烦恼的影响。首先，所有的 &lt;script&gt; 必须以正确的顺序排列，开发者必须非常谨慎地确保没有任何一个脚本排列错误。 如果排列错了，那么在运行过程中，应用将会抛出错误。当函数在全局作用域寻找 jQuery 变量时，如果没有找到，那么它将会抛出异常错误，并且停止继续运行。 这同时也使得代码的后期维护变得困难。它会使得移除旧代码或者脚本标签变得充满不确定性。你根本不知道移除它会带来什么影响。代码之间的依赖是不透明的。任何函数都可能依赖全局作用域中的任何变量，以至于你也不知道哪个函数依赖哪个脚本。 其次，由于变量存在于全局作用域，所以任何代码都可以改变它。恶意的代码可能会故意改变全局变量，从而让你的代码做出危险行为。又或者，代码可能不是恶意的，但是却无意地改变了你期望的变量。、 模块化的作用模块化为你提供了一种更好的方式来组织变量和函数。你可以把相关的变量和函数放在一起组成一个模块。 这种组织方式会把函数和变量放在模块作用域中。模块中的函数可以通过模块作用域来共享变量。 不过，与函数作用域不同的是，模块作用域还提供了一种暴露变量给其他模块使用的方式。模块可以明确地指定哪些变量、类或函数对外暴露。 对外暴露的过程称为导出。一旦导出，其他模块就可以明确地声称它们依赖这些导出的变量、类或者函数。 因为这是一种明确的关系，所以你可以很简单地辨别哪些代码能移除，哪些不能移除。 拥有了在模块之间导出和导入变量的能力之后，你就可以把代码分割成更小的、可以独立运行地代码块了。然后，你就可以像搭乐高积木一样，基于这些代码块，创建所有不同类型的应用。 由于模块化是非常有用的，所以历史上曾经多次尝试为 JS 添加模块化的功能。不过截止到目前，真正得到广泛使用的只有两个模块系统。一个是 Node.js 使用的 CommonJS （CJS）；另一个是 JS 规范的新模块系统 EcmaScript modules（ESM），Node.js 也正在添加对 ESM 的支持。 下面就让我们来深入理解下这个新的模块系统是如何工作的。 ESM 原理当你在使用模块进行开发时，其实是在构建一张依赖关系图。不同模块之间的连线就代表了代码中的导入语句。 正是这些导入语句告诉浏览器或者 Node 该去加载哪些代码。我们要做的是为依赖关系图指定一个入口文件。从这个入口文件开始，浏览器或者 Node 就会顺着导入语句找出所依赖的其他代码文件。 但是呢，浏览器并不能直接使用这些代码文件。它需要解析所有的文件，并把它们变成一种称为模块记录（Module Record）的数据结构。只有这样，它才知道代码文件中到底发生了什么。 解析之后，还需要把模块记录变成一个模块实例。模块实例会把代码和状态结合起来。 所谓代码，基本上是一组指令集合。它就像是制作某样东西的配方，指导你该如何制作。但是它本身并不能让你完成制作。你还需要一些原料，这样才可以按照这些指令完成制作。 所谓状态，它就是原料。具体点，状态是变量在任何时候的真实值。当然，变量实际上就是内存地址的别名，内存才是正在存储值的地方。 所以，可以看出，模块实例中代码和状态的结合，就是指令集和变量值的结合。 对于模块而言，我们真正需要的是模块实例。模块加载会从入口文件开始，最终生成完整的模块实例关系图。 对于 ESM ，这个过程包含三个阶段： 构建：查找，下载，然后把所有文件解析成模块记录。 实例化：为所有模块分配内存空间（此刻还没有填充值），然后依照导出、导入语句把模块指向对应的内存地址。这个过程称为链接（Linking）。 运行：运行代码，从而把内存空间填充为真实值。 大家都说 ESM 是异步的。因为它把整个过程分为了三个不同的阶段：加载、实例化和运行，并且这三个阶段是可以独立进行的。 这意味着，ESM 规范确实引入了一种异步方式，且这种异步方式在 CJS 中是没有的。后面我们会详细说到为什么，然而在 CJS 中，一个模块及其依赖的加载、实例化和运行是一起顺序执行的，中间没有任何间断。 不过，这三个阶段本身是没必要异步化。它们可以同步执行，这取决于它是由谁来加载的。因为 ESM 标准并没有明确规范所有相关内容。实际上，这些工作分为两部分，并且分别是由不同的标准所规范的。 其中，ESM 标准 规范了如何把文件解析为模块记录，如何实例化和如何运行模块。但是它没有规范如何获取文件。 文件是由加载器来提取的，而加载器由另一个不同的标准所规范。对于浏览器来说，这个标准就是 HTML。但是你还可以根据所使用的平台使用不同的加载器。 加载器也同时控制着如何加载模块。它会调用 ESM 的方法，包括 ParseModule、Module.Instantiate 和 Module.Evaluate 。它就像是控制着 JS 引擎的木偶。 下面我们将更加详细地说明每一步。 构建对于每个模块，在构建阶段会做三个处理： 确定要从哪里下载包含该模块的文件，也称为模块定位（Module Resolution） 提取文件，通过从 URL 下载或者从文件系统加载 解析文件为模块记录 1.下载模块加载器负责定位文件并且提取。首先，它需要找到入口文件。在 HTML 中，你可以通过 &lt;script&gt; 标签来告诉加载器。 但是，加载器要如何定位 main.js 直接依赖的模块呢？这个时候导入语句就派上用场了。导入语句中有一部分称为模块定位符（Module Specifier），它会告诉加载器去哪定位模块。 对于模块定位符，有一点要注意的是：它们在浏览器和 Node 中会有不同的处理。每个平台都有自己的一套方式来解析模块定位符。这些方式称为模块定位算法，不同的平台会使用不同的模块定位算法。当前，一些在 Node 中能工作模块定位符并不能在浏览器中工作，但是已经有一项工作正在解决这个问题。 在这个问题被解决之前，浏览器只接受 URL 作为模块定位符。它们会从 URL 加载模块文件。但是，这并不是在整个关系图上同时发生的。因为在解析完这个模块之前，你根本不知道它依赖哪些模块。而且在它下载完成之前，你也无法解析它。 这就意味着，我们必须一层层遍历依赖树，先解析文件，然后找出依赖，最后又定位并加载这些依赖，如此往复。 如果主线程正在等待这些模块文件下载完成，许多其他任务将会堆积在任务队列中，造成阻塞。这是因为在浏览器中，下载会耗费大量的时间。 而阻塞主线程会使得应用变得卡顿，影响用户体验。这是 ESM 标准把算法分成多个阶段的原因之一。将构建划分为一个独立阶段后，浏览器可以在进入同步的实例化过程之前下载文件然后理解模块关系图。 ESM 和 CJS 之间最主要的区别之一就是，ESM 把算法化为为多个阶段。 CJS 使用不同的算法是因为它从文件系统加载文件，这耗费的时间远远小于从网络上下载。因此 Node 在加载文件的时候可以阻塞主线程，而不造成太大影响。而且既然文件已经加载完成了，那么它就可以直接进行实例化和运行。所以在 CJS 中实例化和运行并不是两个相互独立的阶段。这也意味着，你可以在返回模块实例之前，顺着整颗依赖树去逐一加载、实例化和运行每一个依赖。 CJS 的方式对 ESM 也有一些启发，这个后面会解释。其中一个就是，在 Node 的 CJS 中，你可以在模块定位符中使用变量。因为已经执行了 require 之前的代码，所以模块定位符中的变量此刻是有值的，这样就可以进行模块定位的处理了。 但是对于 ESM，在运行任何代码之前，你首先需要建立整个模块依赖的关系图。也就是说，建立关系图时变量是还没有值的，因为代码都还没运行。 不过呢，有时候我们确实需要在模块定位符中使用变量。比如，你可能需要根据当前的状况加载不同的依赖。 为了在 ESM 中实现这种方式，人们已经提出了一个动态导入提案。该提案允许你可以使用类似 import(\\${path}/foo.js)的导入语句。 这种方式实际上是把使用 import() 加载的文件当成了一个入口文件。动态导入的模块会开启一个全新的独立依赖关系树。 不过有一点要注意的是，这两棵依赖关系树共有的模块会共享同一个模块实例。这是因为加载器会缓存模块实例。在特定的全局作用域中，每个模块只会有一个与之对应的模块实例。 这种方式有助于提高 JS 引擎的性能。例如，一个模块文件只会被下载一次，即使有多个模块依赖它。这也是缓存模块的原因之一，后面说到运行的时候会介绍另一个原因。 加载器使用模块映射（Module Map）来管理缓存。每个全局作用域都在一个单独的模块映射中跟踪其模块。 当加载器要从一个 URL 加载文件时，它会把 URL 记录到模块映射中，并把它标记为正在下载的文件。然后它会发出这个文件请求并继续开始获取下一个文件。 当其他模块也依赖这个文件的时候会发生什么呢？加载器会查找模块映射中的每一个 URL 。如果发现 URL 的状态为正在下载，则会跳过该 URL ，然后开始下一个依赖的处理。 不过，模块映射的作用并不仅仅是记录哪些文件已经下载。下面我们将会看到，模块映射也可以作为模块的缓存。 2.解析模块至此，我们已经拿到了模块文件，我们需要把它解析为模块记录。这有助于浏览器理解模块的不同部分。 一旦模块记录创建完成，它就会被记录在模块映射中。所以，后续任何时候再次请求这个模块时，加载器就可以直接从模块映射中获取该模块。 解析过程中有一个看似微不足道的细节，但是实际造成的影响却很大。那就是所有的模块都按照严格模式来解析的。也还有其他的小细节，比如，关键字 await 在模块的最顶层是保留字， this 的值为 undefinded。 这种不同的解析方式称为解析目标（Parse Goal）。如果按照不同的解析目标来解析相同的文件，会得到不同的结果。因此，在解析文件之前，必须清楚地知道所解析的文件类型是什么，不管它是不是一个模块文件。 在浏览器中，知道文件类型是很简单的。只需要在 &lt;script&gt; 脚本中添加 type=&quot;module&quot; 属性即可。这告诉浏览器这个文件需要被解析为一个模块。而且，因为只有模块才能被导入，所以浏览器以此推测所有的导入也都是模块文件。 不过在 Node 中，我们并不使用 HTML 标签，所以也没办法通过 type 属性来辨别。社区提出一种解决办法是使用 .mjs 拓展名。使用该拓展名会告诉 Node 说“这是个模块文件”。你会看到大家正在讨论把这个作为解析目标。不过讨论仍在继续，所以目前仍不明确 Node 社区最终会采用哪种方式。 无论最终使用哪种方式，加载器都会决定是否把一个文件作为模块来解析。如果是模块，而且包含导入语句，那它会重新开始处理直至所有的文件都已提取和解析。 到这里，构建阶段差不多就完成了。在加载过程处理完成后，你已经从最开始只有一个入口文件，到现在得到了一堆模块记录。 下一步会实例化这些模块并且把所有的实例链接起来。 实例化正如前文所述，一个模块实例结合了代码和状态。状态存储在内存中，所以实例化的过程就是把所有值写入内存的过程。 首先，JS 引擎会创建一个模块环境记录（Module Environment Record）。它管理着模块记录的所有变量。然后，引擎会找出多有导出在内存中的地址。模块环境记录会跟踪每个导出对应于哪个内存地址。 这些内存地址此时还没有值，只有等到运行后它们才会被填充上实际值。有一点要注意，所有导出的函数声明都在这个阶段初始化，这会使得后面的运行阶段变得更加简单。 为了实例化模块关系图，引擎会采用深度优先的后序遍历方式。即，它会顺着关系图到达最底端没有任何依赖的模块，然后设置它们的导出。 最终，引擎会把模块下的所有依赖导出链接到当前模块。然后回到上一层把模块的导入链接起来。 这个过程跟 CJS 是不同的。在 CJS 中，整个导出对象在导出时都是值拷贝。即，所有的导出值都是拷贝值，而不是引用。所以，如果导出模块内导出的值改变了，导入模块中导入的值也不会改变。 相反，ESM 则使用称为实时绑定（Live Binding）的方式。导出和导入的模块都指向相同的内存地址（即值引用）。所以，当导出模块内导出的值改变后，导入模块中的值也实时改变了。 模块导出的值在任何时候都可以能发生改变，但是导入模块却不能改变它所导入的值，因为它是只读的。举例来说，如果一个模块导入了一个对象，那么它只能改变该对象的属性，而不能改变对象本身。 ESM 采用这种实时绑定的原因是，引擎可以在不运行任何模块代码的情况下完成链接。后面会解释到，这对解决运行阶段的循环依赖问题也是有帮助的。 实例化阶段完成后，我们得到了所有模块实例，以及已完成链接的导入、导出值。 现在我们可以开始运行代码并且往内存空间内填充值了。 运行最后一步是往已申请好的内存空间中填入真实值。JS 引擎通过运行顶层代码（函数外的代码）来完成填充。 除了填充值以外，运行代码也会引发一些副作用（Side Effect）。例如，一个模块可能会向服务器发起请求。 因为这些潜在副作用的存在，所以模块代码只能运行一次。前面我们看到，实例化阶段中发生的链接可以多次进行，并且每次的结果都一样。但是，如果运行阶段进行多次的话，则可能会每次都得到不一样的结果。 这正是为什么会使用模块映射的原因之一。模块映射会以 URL 为索引来缓存模块，以确保每个模块只有一个模块记录。这保证了每个模块只会运行一次。跟实例化一样，运行阶段也采用深度优先的后序遍历方式。 那对于前面谈到的循环依赖会怎么处理呢？ 循环依赖会使得依赖关系图中出现一个依赖环，即你依赖我，我也依赖你。通常来说，这个环会非常大。不过，为了解释好这个问题，这里我们举例一个简单的循环依赖。 counter 模块会试图去访问导出对象的 message 。不过，由于 main 模块中还没运行到 message 处，所以此时得到的 message 为 undefined。JS 引擎会为本地变量分配空间并把值设为 undefined 。 运行阶段继续往下执行，直到 counter 模块顶层代码的末尾处。我们想知道，当 counter 模块运行结束后，message 是否会得到真实值，所以我们设置了一个超时定时器。之后运行阶段便返回到 main.js 中。 这时，message 将会被初始化并添加到内存中。但是这个 message 与 counter 模块中的 message 之间并没有任何关联关系，所以 counter 模块中的 message 仍然为 undefined。 如果导出值采用的是实时绑定方式，那么 counter 模块最终会得到真实的 message 值。当超时定时器开始计时时，main.js 的运行就已经完成并设置了 message 值。 支持循环依赖是 ESM 设计之初就考虑到的一大原因。也正是这种分段设计使其成为可能。 ESM 的当前状态等到 2018 年 5 月 Firefox 60 发布后，所有的主流浏览器就都默认支持 ESM 了。Node 也正在添加 ESM 支持，为此还成立了工作小组来专门研究 CJS 和 ESM 之间的兼容性问题。 所以，在未来你可以直接在 &lt;script&gt; 标签中使用 type=&quot;module&quot;，并且在代码中使用 import 和 export 。同时，更多的模块功能也正在研究中。比如动态导入提案已经处于 Stage 3 状态；import.meta也被提出以便 Node.js 对 ESM 的支持；模块定位提案 也致力于解决浏览器和 Node.js 之间的差异。 相信在不久的未来，跟模块一起玩耍将会变成一件更加愉快的事！","categories":[],"tags":[]},{"title":"Event loop","slug":"Event loop","date":"2019-05-19T11:25:19.000Z","updated":"2020-05-23T14:52:52.835Z","comments":true,"path":"2019/05/19/Event loop/","link":"","permalink":"https://tsunamigg.github.io/2019/05/19/Event%20loop/","excerpt":"Event loop的粗浅认识","text":"Event loop的粗浅认识 事件轮询js是单线程的。其事件轮询由：同步任务，异步任务，macrotask（宏任务），microtask （微任务）组成。其执行过程如下： 同步任务： 主线程上的任务，前一个完成后后一个执行。 异步任务：不进入主线程，进入任务队列（task queue)中执行，等于macrotask。 macrotask：任务队列的主体，同一个队列内的“先进先出”执行。不同的队列之间“先进后出”执行。 microtask ：总在任务队列末尾执行，有新的microtask 继续加在末尾执行。 执行过程：1.同步任务执行 2. 任务按队列依次执行 3.微任务按队列依次执行 4.重复1-3 宏任务和微任务对于宏任务和微任务的概念的理解，一开始确实是不太清楚的。 先来说说宏任务，我们不妨这样来看，既然它是任务队列的主体，那么它一定由一个或者多个任务构成。抛开JS,[宏]这个字本身就不是单一的，在CS中的[宏]就是批量处理的意思。 对于稍微了解过一点点c的人来说，应该都不陌生，辟如：编译预处理命令，宏定义等等。 1234// 编译预处理命令#include&lt;stdio.h&gt;// 宏定义#define PI 3.14 我将[编译预处理命令]（在编译之前进行的处理）就看做是[宏任务]，就是你写了一系列的前置操作，在后面的代码执行之前，这些宏任务全部需要执行完毕~ 稍微生活化一点点，比如那个中国互联网起步的时候，我的同学之间，喜欢用QQ等级作为谈资。所以我让我的电脑开机后自动登录QQ；或者现今5G来临之前，男生多半玩过的MOBA类游戏，就拿LOL中的瞎子摸眼R闪这种操作，你完全可以选一个拥有宏命令的鼠标，设置测试后一键完成这种“用双手成就你的梦想”等秀的飞起的操作；还有诸如乔碧萝之类的人士，开启直播推流之前，对自己直播效果的优化。这些都是所谓宏任务。 至于微任务，相信聪明可爱的你一定能够举一反一，找到自己对其充分的理解~:smile: 常见的宏任务和微任务： 宏任务： setTimeout setInterval setImmediate requestAnimationFrame I/O UI rendering 微任务： process.nextTick Promises Object.observe MutationObserver 执行图例 希望执行帧动画能让你对整个过程的理解清晰许多 小练习11234567891011121314151617181920console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// 浏览器输出顺序：//script start//script end//promise1//promise2//setTimeout 小练习21234567891011121314151617181920212223242526272829async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout') &#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end')// 浏览器输出顺序：// script start//async1 start//async2//promise1//script end//async1 end//promise2//setTimeout await会将之后的代码抛入下一个执行队列，代码上的表现就是执行完await的会跳出函数体执行其他的同步任务。 setTimeout的回调函数会进入下一个同步任务队列中。 如果输出顺序不一致，是因为各大浏览器对异步的处理是不一样的，没什么奇怪的。 另外，node环境输出顺序也有很大差异。","categories":[],"tags":[{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"}]}],"categories":[],"tags":[{"name":"diary","slug":"diary","permalink":"https://tsunamigg.github.io/tags/diary/"},{"name":"Vue-2.6X-source-learn","slug":"Vue-2-6X-source-learn","permalink":"https://tsunamigg.github.io/tags/Vue-2-6X-source-learn/"},{"name":"notes","slug":"notes","permalink":"https://tsunamigg.github.io/tags/notes/"},{"name":"javascript native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"},{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"}]}