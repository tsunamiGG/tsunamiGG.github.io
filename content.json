{"meta":{"title":"Secret Garden","subtitle":"","description":"","author":"tsunamiGG","url":"https://tsunamiGG.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2020-05-17T13:00:41.486Z","updated":"2020-05-17T13:00:41.486Z","comments":true,"path":"categories/index.html","permalink":"https://tsunamigg.github.io/categories/index.html","excerpt":"","text":"javascript"},{"title":"所有标签","date":"2020-05-17T13:01:21.307Z","updated":"2020-05-17T13:01:21.307Z","comments":true,"path":"tags/index.html","permalink":"https://tsunamigg.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-17T12:59:07.730Z","updated":"2020-05-17T12:59:07.730Z","comments":true,"path":"about/index.html","permalink":"https://tsunamigg.github.io/about/index.html","excerpt":"","text":"占个位子"}],"posts":[{"title":"创建对象的几种方式","slug":"object-create","date":"2019-08-25T11:45:38.000Z","updated":"2020-05-17T12:48:45.034Z","comments":true,"path":"2019/08/25/object-create/","link":"","permalink":"https://tsunamigg.github.io/2019/08/25/object-create/","excerpt":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式","text":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式 1.简单工厂模式：Simple Factory工厂模式什么意思？ 如果把我们编写业务代码的过程，比作造一台电视机，那么工厂模式就是先打造好生产电视机的流水线。如何打造生产线？？？ 我们将需要工厂制造的产物的特性抽象出来，在代码上表现为我们规定其属性名称，但其属性值又参数来决定。 1234567function createBook(name, pages, author) &#123; let newBook = &#123;&#125;; newBook.name = name; newBook.pages = pages; newBook.author = author; return newBook;&#125; 这是一种工厂模式，其实现方式与之前学基础的寄生继承有点相似，也是在一个新的变量上去添加属性，使用字面量方式创建对象会比使用new高效的多。 还有一种就是先将不同型号的电视机造出来，然后通过工厂来输送到不同的产品区。 这里的工厂不在制造，而是充当deliver的角色。 123456789101112131415161718192021222324function fictionBook() &#123; this.name = '九州缥缈录'; this.story = '铁甲依然在'; this.tellStory = function()&#123; console.log(this.story) &#125;&#125;function classicBook() &#123; this.name = '假如给我三天光明'; this.author = '海伦凯勒'; this.bookauthor = function () &#123; console.log(this.author) &#125;&#125;function createBook(type) &#123; switch (type) &#123; case 'fiction': return new fictionBook(); case 'classic': return new classicBook(); &#125;&#125; 两种方式优缺点十分明显， 第一种常见方式需要我们固定某些参数类型，限制了其多样性，但相比第二种省事多了。第二种则相反，每创造一种不同型号的电视机就需要我们去创建一个新的类并向分发类添加该选项。 2.工厂方法模式: Factory Method12345678910111213141516//安全模式 const Factory = function (type, content) &#123; if (this instanceof Factory) &#123; return new this[type](content); &#125; else &#123; return new Factory(type, content); &#125; &#125;Factory.prototype = &#123; show: function(content) &#123; this.content = content; console.log(content); &#125;&#125;const test = new Factory('show', '2'); 安全模式的好处在于，在简单工厂模式上加了一层限制，如果没有创建工厂类，就直接执行该函数而不是返回工厂对象。 12345678910111213141516171819202122232425262728293031323334353637383940//抽象模式const abstractFactory = function (superType, subType) &#123; if (typeof abstractFactory[superType] === 'function' ) &#123; function F() &#123;&#125;; F.prototype = new abstractFactory[superType](); subType.constructor = subType; subType.prototype = new F(); &#125; else &#123; throw new Error('未创建该抽象类') &#125;&#125;abstractFactory.desk = function() &#123; this.type = 'desk';&#125;abstractFactory.desk.prototype = &#123; getDeskSize: function () &#123; return new Error('抽象方法不能调用') &#125;, getDeskMaterial: function() &#123; return new Error('抽象方法不能调用') &#125;&#125;//实例化抽象desk类// 1.子类构造方法let machilusDesk = function(size, material) &#123; this.size = size; this.material = material;&#125;// 2. 将子类构造方法送入工厂，继承工厂抽象方法abstractFactory('desk', machilusDesk);// 3. 覆盖抽象方法machilusDesk.prototype.getDeskSize = function() &#123; return this.size;&#125;machilusDesk.prototype.getDeskMaterial = function() &#123; return this.material;&#125; 在JS中，abstract是一个保留关键字，所以想要实现抽象类，是不可能像传统的面向对象语言那么方便，但由于其灵活性，我们可以模拟出抽象类的主要行为。 抽象方法时不可调用的，会报错，所以我们模拟出其这个行为，并且采用寄生继承来继承父类。当工厂生成子类后，覆盖抽象方法，就不会报错了。 抽象模式是提前定义了类的结构，而不是直接创建类。就像建房子先画好房子的图纸一样，先描述出其轮廓~ 但JS中不支持抽象化创建和虚拟方法，所以其引用并不广泛，但也是面向对象编程中很经典常见的一种模式。 3.建造者模式： Builder如果说工厂模式的侧重点在创建的结果，那么建造者就是注重创建过程的一种模式。 建造者会注意创建过程的每个细节，就像我们捏橡皮人时，不光要注意身体的轮廓，还要注意头有多大，四肢有多长….理所当然的创建过程会复杂很多。 其过程就是将各种特性都封装成类，然后在主类里面根据不同参数，实例化不同的特性，组成新的子类，或者叫其复合对象。 123456789101112131415161718192021222324252627function House(parmas) &#123; this.material = parmas &amp;&amp; parmas.material || '**'; this.area = parmas &amp;&amp; parmas.area || '**';&#125;House.prototype = &#123; getMaterial: function() &#123; return this.material; &#125;, getArea: function() &#123; return this.area; &#125;&#125;function material(material) &#123; this.material = material;&#125;function area(m) &#123; this.area = m * m;&#125;function newHouse(material, m) &#123; let _house = new House(); _house.material = new material(material); _house.area = new area(area); return _house;&#125; 就像搭积木一样，先把各块积木的形状找好，然后组合在一起。抛出一个问题，如果要在一个网页上呈现卡片堆砌的效果，你会怎么做呢？ 个人理解，这个模式是我们经常解决生活中问题的一种方法的抽象，复杂的问题简单化，就是将一个复杂的事物拆分成多个简单的事物，再以某种方式组合起来，来解决问题的一种方法。 4.原型模式：prototype其被称为语言之魂，它将原型对象指向创建对象的类，使这些类共享原型对象的方法和属性。 存在即合理，那么它解决了什么问题？在很多复杂的功能下，我们的子类需要继承父类的一些属性与方法，但是并非所有子类需求的属性和方法都是一致的，所以子类会从父类继承一些不必要的，增加额外开销的属性和方法。例如，一个车的父类，子类可能是跑车，轿车，SUV，越野，跑车需要整个车体结构和轿车不一样，但父类因为考虑整体性不会有特殊的车体结构，而是通用的轿车结构，那么子类就从父类继承了一些额外的负担性质的属性和方法。而子类每次实例化都会造成很多不可避免的额外开销。 原型概念就此而出，它将某些可复用，可共享的，开销大的属性和方法从父类提取出来放在原型之中，子类通过前文的某些继承方式来继承，直接获得这些属性和方法而不是每次实例化重新创建这些属性和方法，节省了很多不必要的开销。 js在原型模式下实现的原型链，让所有内置的属性和方法都享受到该模式的好处。 其实现方式就是对一个对象的拷贝，也是一种继承方式，但很特殊的一点，创建过程于它无瓜，理解这一点很重要~ 5.单例模式： singleton这是js编程中很常见的一种模式，只允许实例化一次的对象类。有时生成命名空间namespace。多人协作开发或者加载独立的第三方库的时候，我们的词语总是有限的，怎么让它们的命名互不影响呢？答案说都开辟独立的命名空间，使得其方法名都可以区分开。同时，对我们在管理静态变量也非常有帮助。 风靡很多时的Jquery就是经典的例子，其$符就是命名空间，$(&#39;className&#39;).function这样的调用方式使得代码清晰明了，一看就知道是Jquery的方法。 1234567891011let mynamespace = &#123; utils: &#123; formate: function() &#123; ..... &#125; &#125;, ajax: function() &#123; ..... &#125; MYHEIGHT: 180&#125; 其实就是封装在一个对象里面，延展开来就是模块机制，把整个js文件作为一个对象，存放不同的命名空间，避免方法名的覆盖。 怎么实现只能实例化一次的对象类？ 妈耶，用个闭包记录，如果被实例化了，就return掉，easy。 什么？ 怎么创建一个闭包？？？ 建议你去看看《你不知道的javascript》,书中详细的论述了闭包是什么，怎么创建闭包，闭包的用途又是什么，闭包背后的作用机制其实是保持对作用域的引用等等。下次有空，结合书本我们来详解一下js中的闭包，解开其神秘的面纱。 总结 创建型设计模式是一些处理对象创建的模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。 创建单类简单对象的简单工厂模式，简单的缺点也很明显，于是工厂方法模式补足创建多类的实例(其实是传入不同参数的简单工厂模式和安全模式的混合)。建造者模式则是通过组合多种简单工厂模式，来创造复杂的对象。原型模式也被成为语言之魂，将某些属性和方法放在原型对象中作为所有对象的共有属性和方法，避免了子类每次实例化都会可能创建新的不必要的，开销大的属性和方法。单例模式则是为我们的代码管理做出了卓越的贡献。这五种模式中，原型模式并不关心对象创建过程，但对创建过程做出的贡献还是有目共睹，或许这就是大佬吧，润物细无声~","categories":[],"tags":[{"name":"javascript native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"}]},{"title":"Event loop","slug":"Event loop","date":"2019-05-19T11:25:19.000Z","updated":"2020-05-17T11:46:13.652Z","comments":true,"path":"2019/05/19/Event loop/","link":"","permalink":"https://tsunamigg.github.io/2019/05/19/Event%20loop/","excerpt":"","text":"Event loop的粗浅认识事件轮询js是单线程的。其事件轮询由：同步任务，异步任务，macrotask（宏任务），microtask （微任务）组成。其执行过程如下： 同步任务： 主线程上的任务，前一个完成后后一个执行。 异步任务：不进入主线程，进入任务队列（task queue)中执行，等于macrotask。 macrotask：任务队列的主体，同一个队列内的“先进先出”执行。不同的队列之间“先进后出”执行。 microtask ：总在任务队列末尾执行，有新的microtask 继续加在末尾执行。 执行过程：1.同步任务执行 2. 任务按队列依次执行 3.微任务按队列依次执行 4.重复1-3 宏任务和微任务对于宏任务和微任务的概念的理解，一开始确实是不太清楚的。 先来说说宏任务，我们不妨这样来看，既然它是任务队列的主体，那么它一定由一个或者多个任务构成。抛开JS,[宏]这个字本身就不是单一的，在CS中的[宏]就是批量处理的意思。 对于稍微了解过一点点c的人来说，应该都不陌生，辟如：编译预处理命令，宏定义等等。 1234// 编译预处理命令#include&lt;stdio.h&gt;// 宏定义#define PI 3.14 我将[编译预处理命令]（在编译之前进行的处理）就看做是[宏任务]，就是你写了一系列的前置操作，在后面的代码执行之前，这些宏任务全部需要执行完毕~ 稍微生活化一点点，比如那个中国互联网起步的时候，我的同学之间，喜欢用QQ等级作为谈资。所以我让我的电脑开机后自动登录QQ；或者现今5G来临之前，男生多半玩过的MOBA类游戏，就拿LOL中的瞎子摸眼R闪这种操作，你完全可以选一个拥有宏命令的鼠标，设置测试后一键完成这种“用双手成就你的梦想”等秀的飞起的操作；还有诸如乔碧萝之类的人士，开启直播推流之前，对自己直播效果的优化。这些都是所谓宏任务。 至于微任务，相信聪明可爱的你一定能够举一反一，找到自己对其充分的理解~:smile: 常见的宏任务和微任务： 宏任务： setTimeout setInterval setImmediate requestAnimationFrame I/O UI rendering 微任务： process.nextTick Promises Object.observe MutationObserver 执行图例 希望执行帧动画能让你对整个过程的理解清晰许多 小练习11234567891011121314151617181920console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// 浏览器输出顺序：//script start//script end//promise1//promise2//setTimeout 小练习21234567891011121314151617181920212223242526272829async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout') &#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end')// 浏览器输出顺序：// script start//async1 start//async2//promise1//script end//async1 end//promise2//setTimeout await会将之后的代码抛入下一个执行队列，代码上的表现就是执行完await的会跳出函数体执行其他的同步任务。 setTimeout的回调函数会进入下一个同步任务队列中。 如果输出顺序不一致，是因为各大浏览器对异步的处理是不一样的，没什么奇怪的。 另外，node环境输出顺序也有很大差异。","categories":[],"tags":[{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"}]}],"categories":[],"tags":[{"name":"javascript native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"},{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"}]}