{"meta":{"title":"Secret Garden","subtitle":"","description":"","author":"tsunamiGG","url":"https://tsunamiGG.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2020-05-17T13:00:41.486Z","updated":"2020-05-17T13:00:41.486Z","comments":true,"path":"categories/index.html","permalink":"https://tsunamigg.github.io/categories/index.html","excerpt":"","text":"javascript"},{"title":"所有标签","date":"2020-05-17T13:01:21.307Z","updated":"2020-05-17T13:01:21.307Z","comments":true,"path":"tags/index.html","permalink":"https://tsunamigg.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-09T13:44:13.214Z","updated":"2020-06-09T13:44:13.213Z","comments":true,"path":"about/index.html","permalink":"https://tsunamigg.github.io/about/index.html","excerpt":"","text":"占个位子"}],"posts":[{"title":"chrome调试骚操作","slug":"Chrome-debugging-ways","date":"2020-05-28T14:26:20.000Z","updated":"2020-05-28T14:29:19.762Z","comments":true,"path":"2020/05/28/Chrome-debugging-ways/","link":"","permalink":"https://tsunamigg.github.io/2020/05/28/Chrome-debugging-ways/","excerpt":"解锁chrome调试黑科技","text":"解锁chrome调试黑科技 chrome调试骚操作 通用篇(Windows) 切换DevTools窗口的布局（下右） Ctrl + Shift + D 切换DevTools选项卡 (Element-NetWork-Audits) Ctrl + [ 或 ]： 向左和向右 Ctrl + 1 到 9：DevTools&gt;Settings&gt;Preferences&gt;Appearance中打开 (开启之后，浏览器网页选项卡也可以切换) Styles数值调整 Alt +上下箭头 0.1 上下箭头 1 Shfit+上下箭头 10 Ctrl +上下箭头 100 elements，logs， sources &amp; network 皆可使用 Ctrl+F Element中的HTML可以直接Ctrl+C保存 copy(全局对象或者DOM or 一些太长的对象)，可直接复制到编辑器中查看。 12345678&#x2F;&#x2F; console板块window ....blabllablacopy(window)Ctrl+V debugger 越过下一个函数调用 : F10、Ctrl + ‘ ; 进入下一个函数调用 : F11、Ctrl + ; 跳出当前函数 : Shift + F11、Ctrl + Shift + ; 切换断点条件: 点击行号、Ctrl + B; 只列举出来我认为很常用的，详见： https://developers.google.com/web/tools/chrome-devtools/shortcuts Command篇 打开devtools, [Ctrl] + [Shift] + [P] (Mac： [⌘] + [Shift]+ [P] ) ,会进入这样的界面。 截屏方式 没错，有好几种截屏的方式，但微信截图他不香吗？ 不不不，第三方工具只能截满你的屏幕尺寸大小，比如：web长度大于1080，而你要看到所有的element? 选择上图中的： full size 即可。 长图示例预警: 切换主题 当你在晚上工作，讨厌白闪闪的devtools,Commond输入： theme。 里面还有很多很多功能~ 模块如下： Snippets 位于Sources模块的，很常用的除了page来看一些err和源码。还有一个snippets也很实用。 1.新建代码块 2.执行(!+代码块序号) 这样就可以输出对应代码块的结果啦。 可以理解为给你开了个沙箱，所以你可以引入其他来源代码块来执行。 测试证明，清cookie ，清缓存，关闭浏览器都不会导致snippets丢失，而且是跨域名全局可用，应该是强存储于浏览器上的 。有点硬~ Date: 2020/2/28 Console模块篇 $符号 1.调试的过程中，你经常会通过打印查看一些变量的值，但如果你想看一下上次执行的结果呢？再输一遍表达式吗？ 这时候 $_ 就派上了用场，$_ 是对上次执行的结果的 引用 ： $ 变量在 console 中就是对这一大串函数 document.querySelector 的别名。 $$变量执行 document.QuerySelectorAll 并且它返回的是：一个节点的 数组 ，而不是一个 Node list 例如：Array.from(document.querySelectorAll(&#39;div&#39;)) === $$(&#39;div&#39;) 。 查找Node可比对着Element看强太多啦！ 结合起来就有一个很妙的css调试法~ 12// Console输入！$$('*').forEach(item=&gt;&#123;item.style.outline='1px solid red'&#125;) 效果如下： custom formatter 自定义格式转换器 我们习惯使用 DevTools 的 console 默认对 object 的转换(例如上图)，但有时候我们想用与众不同的方式来处理。 那我们就可以自定义输出对象的函数 custom formatter~ 具体的官网介绍在这里： https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview 开启方法：打开devtools,按下F1。勾选如下~ formatter： 它是一个对象，包含三个方法： header : 处理如何展示在 console 的日志中的主要部分。 hasbody : 如果你想显示一个用来展开对象的 ▶ 箭头，返回 true body : 定义将会被显示在展开部分的内容中。 12345678window.devtoolsFormatters = [&#123; header: function(obj)&#123; return [\"div\", &#123;&#125;, obj.toString()] &#125;, hasBody: function()&#123; return false; &#125;&#125;] 其中header 方法返回了一个 JsonML (注： JsonML : JSON Markup Language - JSON 标记语言) 数组，由这些组成： 标签名 属性对象 内容 (文本值或者其他元素) 让我们看看发生了什么： amazing 现有好几种 custom formatter 可供选择，例如：你可以在这个 immutable-devtools 仓库中找到对于 Immutable.js 结构的完美展示。但你同样可以自己造一个。 如果你遇到结构不寻常的对象时，或大量的日志(最好避免这样的情况，但是有时候很有用)而你想从中做区分时，你可以采用 custom formatter 来处理。 一个很实用的窍门：直接将你不关心，不需要区别对待的对象过滤出来，直接在 header 方法里面 return null。让 DevTools 使用默认的格式化方式来处理这些值。 让我们来找点乐子，让开让开，我要装逼啦！ 12345678910111213141516171819202122232425262728293031window.devtoolsFormatters = [&#123; header: function(obj)&#123; if (!obj.__clown) &#123; return null; &#125; delete obj.__clown; const style = ` color: red; border: dotted 2px gray; border-radius: 4px; padding: 5px; `; const content = `🤡 $&#123;JSON.stringify(obj, null, 2)&#125;`; try &#123; return ['div', &#123;style&#125;, content] &#125; catch (err) &#123; // for circular structures return null; // use the default formatter &#125; &#125;, hasBody: function()&#123; return false; &#125;&#125;]console.clown = function (obj) &#123; console.log(&#123;...obj, __clown: true&#125;);&#125;console.log(&#123;message: 'hello!'&#125;); // normal logconsole.clown(&#123;message: 'hello!'&#125;); // a silly log 可以在massage里面加入一个emoji表情。当然，**他的实际作用是tag，可以通过不同的tag来表示不同的项目，便于区分~","categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://tsunamigg.github.io/tags/browser/"}]},{"title":"走好下一步","slug":"reload","date":"2020-05-23T14:48:07.000Z","updated":"2020-05-23T14:52:29.238Z","comments":true,"path":"2020/05/23/reload/","link":"","permalink":"https://tsunamigg.github.io/2020/05/23/reload/","excerpt":"抛下过去，走向未来，成就自己","text":"抛下过去，走向未来，成就自己 前言大三下学期，觉得自己不能就此沉沦。想着自己好歹算个计算机沾边的专业，去找一份编程相关的工作，应该还是有搞头的。 在图书馆看到一本《web工程师的自我修养》，心里波澜起伏。于是，就在前端的路上一去不复返~ 折戟实习去了一家高歌猛进，疯狂增长的现已上市的在线教育公司，当我满怀憧憬，准备大干一场，现实却给我来了一记狠狠的patch。 对于没有任何项目经验，只学了俩个月基础的我来说；每天醍醐灌顶，很多事情并没有做到自己能做到的最好，更多的失误，脑子犯浑，给决定我实习是否通过的师傅留下了能力不足的印象。 从未想过会有这样的结果，每天睡不着，很多就来到工位学习知道晚上9点，与大家一起开早会，完成几个简单的任务，一起极乐汤团建，参加年会…. 对我的打击是巨大的，听着HRBP安慰的语音，思绪翻涌。我甚至开始怀疑自己真正是否能够胜任这份工作，我是不是应该听爸妈的话，回去小县城去考公务员….各种怀疑，不自信的负面情绪就像潮汐一般，想要推得越远，却弹回来越远。我知道，我失去了这辈子最重要的第二次机会。 重启？改变？在颓废2个月后，房租，电费，燃气费，一条条短信提醒着我，不能再这样下去了。 于是降低自己的要求，在武汉这样一个大环境都是外包的条件下，匆匆就签了一个40人，只有1个前端的科技公司…. 嗯，是的，对于现状非常不满意。每天写着不太感兴趣的业务，改着稀烂的代码。 如果非要说进步，那大概是磨平了棱角，刷新了对客户的认知，熟悉了微信这样稀烂的开发环境… 我仍然没有放弃，努力在工作空余时间，去看点东西，但就像一只无头苍蝇一般，乱撞。 着学习的事情不能一蹴而就，得持之以恒，系统的学。就从红宝书开始，重学基础，然后就去肯Vue源码。现在对Vue2.x的双向绑定，虚拟DOM，模板编译都有一定理解，源码中没有秘密。 如果迷茫了就开始制定计划吧迷茫来自于下时代5G的浪潮，每次通信革命都让人们的生活发生翻天覆地的变化..这次也毫不例外。是继续在本就过饱和的互联网继续挣扎还是去把握住新的风口机会？但相信自己的条件，并没有机会去抓住新风口，只能继续前进，但紧跟变化发展，发挥自己的洞察力，找到合适的机会！ 刚毕业快一年，想着给自己定一个目标。 毕业3年内，在武汉工资过万或者进入一家心里满意的公司。对前端的技能很熟练，可以独自解决业务难点，养成良好编码习惯。熟练Vue与react，啃完Vue2.x,3.x源码；深入使用canvas或者进击数据可视化等等有深度的领域。 能够写py或者其他后端语言，去捡起SQL，碰碰服务端的数据库，服务器等等。 今年，一定要跳槽！ 冲鸭！","categories":[],"tags":[{"name":"diary","slug":"diary","permalink":"https://tsunamigg.github.io/tags/diary/"}]},{"title":"Vue-source-learn1","slug":"Vue-source-learn1","date":"2020-05-22T02:37:35.963Z","updated":"2020-06-02T14:36:37.729Z","comments":true,"path":"2020/05/22/Vue-source-learn1/","link":"","permalink":"https://tsunamigg.github.io/2020/05/22/Vue-source-learn1/","excerpt":"title: vue源码学习（开篇）date: 2020-04-10 10:37:35tags: notes 应该如何学习源码？ 我觉得最开始有个全局观，然后切入细节的模块，带着问题去读。","text":"title: vue源码学习（开篇）date: 2020-04-10 10:37:35tags: notes 应该如何学习源码？ 我觉得最开始有个全局观，然后切入细节的模块，带着问题去读。 vue源码学习笔记 本篇结合了阅读 https://nlrx-wjc.github.io/Learn-Vue-Source-Code/ 的笔记，感谢wjc199366(wx)开源。 现在应该看不了了，因为发生了一些事情，大概是人民邮电出版社以影响旗下《深入浅出Vue.js》销量为由，联系微软，将电子书的仓库给关了….. 不过好在关闭之前，留了一份在本地，需要的加我微信取：tangtang1996918 阅读源码之前，建议去看看HcySunYang大佬对vue2/3中一些重要概念的解读： http://hcysun.me/vue-design/zh/essence-of-comp.html 例如：组件传出的本质是什么？Vnode是如何设计的？Vnode是如何挂载为真实DOM的？ 对阅读源码，理清思路是非常有帮助的~ 源码之中没有秘密~ 1.路线 变化侦测篇 学习Vue中如何实现数据的响应式系统，从而达到数据驱动视图。 虚拟DOM篇 学习什么是虚拟DOM，以及Vue中的DOM-Diff原理 模板编译篇 学习Vue内部是怎么把template模板编译成虚拟DOM,从而渲染出真实DOM 生命周期篇 学习Vue中组件的生命周期实现原理 实例方法篇 学习Vue中所有实例方法(即所有以$开头的方法)的实现原理 全局API篇 学习Vue中所有全局API的实现原理 指令篇 学习Vue中所有指令的实现原理 过滤器篇 学习Vue中所有过滤器的实现原理 内置组件篇 学习Vue中内置组件的实现原理 2.方法面对繁复的源码，我们应该怎么去读？ 说下适合我自己的读源码方法，抛砖引玉。 一本正经的一行行的看源码，我只能说兄弟，你他娘的真是个天才 1.一般我先扫一眼import引入的都是那些模块的js文件，一般源码的目录结构都清晰。根据引入的js文件大概都看出该js文件的依赖性，我们可以根据依赖项的多少来判断复杂程度，有个心理预期。 2.然后去看js文件主函数的输入和输出，即传参和返回都是什么，先搞清楚其主要功能。 对。不是一上来就一行行的看逻辑代码，除非你有超强的理解能力，一般是很吃力的。所以我们就先假装自己是个debug工具，先设置跳过全部函数内部细节，只观察主函数和各个内部子函数的输入和输出。(这期间肯定少不了去查看上一部引入的函数功能)。如果结合注释看了很多输入输出还是不明白其作用，那也很正常。 接下来，我们可以复制一下代码片段，做一些测试来证实部分我们对某些函数功能的猜想。有了这些，我们脑中大多都能有个框架。 其实这跟证明数学题的思路十分类似，先提出假设，然后用各种公理，定理来慢慢推导证明。 3.深入每个函数内部的细节。这个就八仙过海各显神通了。不过我觉得还可以先做减法，即根据注释解决兼容性和一些判断环境的hack先给屏蔽掉，关注每个函数主要的逻辑，等把整个模块的脉络弄清楚后，有空再去看看哪些hack。细节不清楚的同样测试，用结果去逆推过程。 4.做笔记，自己写一遍梳理清楚，把你觉得一些很精妙的思路，有趣的类比联想，方法总结，都可以记录下来 复杂的东西都是由简单的东西构成，人们擅长将东西变复杂，却不擅长将东西变简单。 3.目录结构强烈建议浏览一遍，源码中很多都是复用的，纵观全局，再某些判断上是能够帮上忙的~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120src├─ compiler│ ├─ codeframe.js│ ├─ codegen│ │ ├─ events.js│ │ └─ index.js│ ├─ create-compiler.js│ ├─ directives│ │ ├─ bind.js│ │ ├─ index.js│ │ ├─ model.js│ │ └─ on.js│ ├─ error-detector.js│ ├─ helpers.js│ ├─ index.js│ ├─ optimizer.js│ ├─ parser│ │ ├─ entity-decoder.js│ │ ├─ filter-parser.js│ │ ├─ html-parser.js│ │ ├─ index.js│ │ └─ text-parser.js│ └─ to-function.js├─ core│ ├─ components│ │ ├─ index.js│ │ └─ keep-alive.js│ ├─ config.js│ ├─ global-api│ │ ├─ assets.js│ │ ├─ extend.js│ │ ├─ index.js│ │ ├─ mixin.js│ │ └─ use.js│ ├─ index.js│ ├─ instance│ │ ├─ events.js│ │ ├─ index.js│ │ ├─ init.js│ │ ├─ inject.js│ │ ├─ lifecycle.js│ │ ├─ proxy.js│ │ ├─ render-helpers│ │ ├─ render.js│ │ └─ state.js│ ├─ observer│ │ ├─ array.js│ │ ├─ dep.js│ │ ├─ index.js│ │ ├─ scheduler.js│ │ ├─ traverse.js│ │ └─ watcher.js│ ├─ util│ │ ├─ debug.js│ │ ├─ env.js│ │ ├─ error.js│ │ ├─ index.js│ │ ├─ lang.js│ │ ├─ next-tick.js│ │ ├─ options.js│ │ ├─ perf.js│ │ └─ props.js│ └─ vdom│ ├─ create-component.js│ ├─ create-element.js│ ├─ create-functional-component.js│ ├─ helpers│ ├─ modules│ ├─ patch.js│ └─ vnode.js├─ platforms│ ├─ web│ │ ├─ compiler│ │ ├─ entry-compiler.js│ │ ├─ entry-runtime-with-compiler.js│ │ ├─ entry-runtime.js│ │ ├─ entry-server-basic-renderer.js│ │ ├─ entry-server-renderer.js│ │ ├─ runtime│ │ ├─ server│ │ └─ util│ └─ weex│ ├─ compiler│ ├─ entry-compiler.js│ ├─ entry-framework.js│ ├─ entry-runtime-factory.js│ ├─ runtime│ └─ util├─ server│ ├─ bundle-renderer│ │ ├─ create-bundle-renderer.js│ │ ├─ create-bundle-runner.js│ │ └─ source-map-support.js│ ├─ create-basic-renderer.js│ ├─ create-renderer.js│ ├─ optimizing-compiler│ │ ├─ codegen.js│ │ ├─ index.js│ │ ├─ modules.js│ │ ├─ optimizer.js│ │ └─ runtime-helpers.js│ ├─ render-context.js│ ├─ render-stream.js│ ├─ render.js│ ├─ template-renderer│ │ ├─ create-async-file-mapper.js│ │ ├─ index.js│ │ ├─ parse-template.js│ │ └─ template-stream.js│ ├─ util.js│ ├─ webpack-plugin│ │ ├─ client.js│ │ ├─ server.js│ │ └─ util.js│ └─ write.js├─ sfc│ └─ parser.js└─ shared ├─ constants.js └─ util.js","categories":[],"tags":[]},{"title":"Vue的变化侦测","slug":"Vue-source-learn2","date":"2020-05-22T00:40:28.000Z","updated":"2020-05-28T14:18:34.374Z","comments":true,"path":"2020/05/22/Vue-source-learn2/","link":"","permalink":"https://tsunamigg.github.io/2020/05/22/Vue-source-learn2/","excerpt":"Vue的响应式数据是如何做到的？","text":"Vue的响应式数据是如何做到的？ 变化侦测 变化侦测 = 数据观测+依赖收集+依赖更新 使用Object.defineProperty来使得数据变得可“观测” 依赖收集(Observer)：是指收集视图里的部分与数据绑定的关系 在getter中收集依赖，在setter中通知更新依赖 典型的发布-订阅模式,为了解耦，新增了一个管理对象 dep(收集某个数据相关的所有依赖)，watcher(被dep通知，更新依赖) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// observer.js// 收集依赖const Dep = require('./dep');export class Observer &#123; constructor(value) &#123; this.value = value; def(value, \"__ob__\", this); if (Array.isArray(value)) &#123; console.log(\"array\"); &#125; else &#123; this.walk(value); &#125; &#125; walk(obj) &#123; const keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj,keys[i]); &#125; &#125;&#125;function defineReactive(obj, key, val) &#123; if (arguments.length === 2) &#123; val = obj[key]; &#125; if (typeof val === 'object') &#123; new Observer(val); &#125; const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; dep.depend(); return val; &#125;, set(newval) &#123; if (val === newval) return; val = newval; dep.notify(); &#125; &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// dep.js// 依赖管理器： 1数据 ：n依赖 的一对多关系进行依赖管理，收集某个数据相关的所有依赖export default class Dep &#123; constructor() &#123; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; removeSub(sub) &#123; remove(this.subs, sub); &#125; depend() &#123; window.target &amp;&amp; this.addSub(window.target); &#125; notify() &#123; const subs = this.subs.slice(); for (let i = 0; i &lt; subs.length; i++) &#123; subs[i].update(); &#125; &#125;&#125;export function remove(arr, item) &#123; if (arr.length &gt; 1) &#123; const itemIndex = arr.indexOf(item); if (itemIndex &gt; 1) &#123; return arr.splice(itemIndex, 1); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// watcher.js// watcher表示依赖关系，通知视图更新// window.target是为了拷贝一份 watcher,添加到Dep的依赖数组中export default class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.vm = vm; this.cb = cb; this.getter = parsePath(expOrFn); this.value = this.get(); &#125; get() &#123; window.target = this; const vm = this.vm; let value = this.getter.call(vm, vm); window.target = undefined; return value; &#125; update() &#123; const oldValue = this.value; this.value = this.get(); this.cb.call(this.vm, this.value, oldValue); &#125;&#125;/** * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath('a.b.c')(data) // 2 */const bailRE = /[^\\w.$]/;export function parsePath(path) &#123; if (bailRE.test(path)) return; const segements = path.split('.'); return function (obj) &#123; for (let i = 0; i &lt; segements.length; i++) &#123; if (!obj) return; obj = obj[segements[i]]; &#125; return obj; &#125;&#125; 侦测流程 vue这套变化侦测的缺点很明显，因为利用defineProperty来进行收集，只限于读和写已有值，当我们对obj进行新增或者删除属性值时，它是监听不到的。所以在官网文档上的叙述上说明过，对数组或对象的直接增加或者删除会产生不期望的结果， 为了解决这一问题，特地增加了Vue.set和Vue.delete两个全局API 。 数组怎么办? 看到这里，对原型熟悉的人可能会问了，这种方法只针对于Obj类型，那剩下的常用的Arr类型或者其他类型呢？defineProperty数组是不可能使用的，那么我们应该怎么对数组进行依赖收集和通知更新？ 还是延续上面的思想：拦截，vue将所有数组的异变方法(能改变原有数组)拦截一波，就能知道arr啥时候被setter了。 经常面试被问到原型，原型链的what,why,那么how???? 我觉得这就是个很巧妙的实践~ 拦截数组原型上的异变方法(会改变原有宿主的方法)的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//代码位置 vue/src/core/observer/array.js/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 数组依赖收集 无论怎样,先得用walk让元素注入observer依赖，使得在getter中实例化Dep收集依赖并将数组方法拦截掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 源码位置：/src/core/observer/index.jsconst Dep = require(\"./dep\");const &#123; arrayKeys, arrayMethods &#125; = require(\"./array\");// 源码位置：src/core/observer/index.js// 使用 defineProperty 让数据可观测export class Observer &#123; constructor(value) &#123; this.value = value; this.dep = new Dep(); def(value, \"__ob__\", this); if (Array.isArray(value)) &#123; const agument = hasProto ? protoAugment : copyAugument; [agument](value, arrayMethods, arrayKeys); this.observerArray(value); &#125; else &#123; this.walk(value); &#125; &#125; walk(obj) &#123; const keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]); &#125; &#125; observerArray(ietms) &#123; for (let i = 0; i &lt; ietms.length; i++) &#123; observe(ietms[i]); &#125; &#125;&#125;export const hasProto = \"__proto__\" in &#123;&#125;;/* 复制原型属性，添加拦截*/function protoAugment(target, src, keys) &#123; target.__proto__ = src;&#125;function copyAugument(target, src, keys) &#123; for (let i = 0; i &lt; keys.length; i++) &#123; const key = key[i]; def(target, key, src[key]); &#125;&#125;/* * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。 * 如果 Value 已经存在一个Observer实例，则直接返回它 */function observe(value) &#123; if (!isObject(value) || value instanceof VNode) &#123; return; &#125; let ob; if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else &#123; ob = new Observer(value); &#125; return ob;&#125;function defineReactive(obj, key, val) &#123; let childOb = observe(val); if (arguments.length === 2) &#123; val = obj[key]; &#125; if (typeof val === \"object\") &#123; new Observer(val); &#125; const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; if (childOb) &#123; childOb.dep.depend(); &#125; return val; &#125;, set(newval) &#123; if (val === newval) return; val = newval; dep.notify(); &#125; &#125;);&#125; 通知更新 主要是还要对数组进行深度监测和新增元素侦测，在拦截的原型上进行依赖更新。 __ob__是在进行初始化observer的时候，在被监听者上面挂载了自己的实例，以便访问后进行依赖更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 源码位置：vue/src/core/observer/array.js/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 总结： vue的变化侦测与React对比Vdom和Angular的脏值检测都不一样。核心是利用defineProperty的能力，拦截所有绑定的响应式数据(data中),在拦截中添加依赖管理器Dep来收集管理依赖,用Watcher表示依赖关系本身，进行通知依赖更新。 其中，对于数组的侦测的思路是，覆盖所有数组原型的的异变方法，在覆盖后植入依赖逻辑。这套缺点就是对数组进行下标赋值操作时，vue是侦测不到的，官网文档上多处对此有说明。 相信下次，面试官问：为什么在vue中对数组下标进行赋值操作会导致不正确的响应式数据结果。这种类似的问题，你一定胸有成竹。","categories":[],"tags":[{"name":"Vue-2.6X-source-learn notes","slug":"Vue-2-6X-source-learn-notes","permalink":"https://tsunamigg.github.io/tags/Vue-2-6X-source-learn-notes/"}]},{"title":"fabric notes","slug":"fabric-notes","date":"2020-04-21T01:17:56.000Z","updated":"2020-05-28T14:41:44.183Z","comments":true,"path":"2020/04/21/fabric-notes/","link":"","permalink":"https://tsunamigg.github.io/2020/04/21/fabric-notes/","excerpt":"一次 fabric + customiseControls 制作涂鸦canvas画板实践","text":"一次 fabric + customiseControls 制作涂鸦canvas画板实践 制作图片涂鸦画板(微信浏览器) fabric+customiseControls简介 fabric是一个canvas库，其核心就是将canvasAPI转换为对象模型，让我们更加便捷的使用。 customiseControls则是基于fabric的插件，可为新建的fabric对象设置角标，并为其提供一系列事件：drag， scale，rotate，remove，或者自定义事件。 fabric:https://github.com/fabricjs/fabric.js customiseControls：https://github.com/pixolith/fabricjs-customise-controls-extension 效果说明(模糊的图片是故意的) 用户涂鸦环节： 涂鸦的构成 = 1.城市背景图 + 贴纸图片素材 + 文字图片素材 1点击缩略图切换，切换时2，3不变化。 2，3是可选中后可拖拽，拖拽时不影响其他图片素材，选中之后出现四个角的角标，角标的事件为放大，缩小，旋转，移除。 生成环节 根据用户涂鸦的结果，生成一张带有其他信息的海报(长按保存到手机相册)，比如： 用户地理位置信息，当前参与人数，二维码，昵称，头像等等 开撸 开撸之前还是梳理一下重点和优化点： A.涂鸦画板的交互(重点) B.精准生成海报(重点)和海报的清晰度(优化点) A部分： 用户选择对应背景或者涂鸦素材后有正确相应，设置边界值 1.初始化fabric插件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 设置部分角标不可见fabric.Object.prototype.setControlsVisibility(&#123; ml: false, mr: false, mtr: false, mt: false, mb: false&#125;);// 角标事件设置fabric.Canvas.prototype.customiseControls(&#123; br: &#123; action: \"rotate\" &#125;, bl: &#123; action: 'scale' &#125;, tl: &#123; action: function action(e, target) &#123; var canvas = target.canvas; canvas.remove(target).renderAll(); &#125; &#125;, tr: &#123; action: 'scale' &#125;&#125;);// 禁用选框fabric.Object.prototype.transparentCorners = false;// 角标基础设置fabric.Object.prototype.customiseCornerIcons(&#123; settings: &#123; borderColor: '#fff', cornerSize: 20, cornerBackgroundColor: 'transparent', cornerPadding: 5 &#125;, br: &#123; action: \"rotate\", icon: './imgs/icons/rotate.svg' &#125;, bl: &#123; action: 'scale', icon: './imgs/icons/resize.svg' &#125;, tl: &#123; icon: './imgs/icons/remove.svg', action: function action(e, target) &#123; var canvas = target.canvas; canvas.remove(target).renderAll(); &#125; &#125;, tr: &#123; action: 'scale', icon: './imgs/icons/resize.svg' &#125;&#125;, function () &#123; board.renderAll();&#125;);var ww = $(window).width();var wh = $(window).height();var board = new fabric.Canvas('drawBoard', &#123; backgroundColor: 'transparent', width: (ww * 0.92 height: (wh * 0.67&#125;); 2.添加用户点击交互(click -&gt; 新增对应素材至画板 或者切换城市背景) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var fabricItemList = [];// 设置图片背景function setImagebg(imgSrc) &#123; fabric.Image.fromURL(imgSrc, function (img) &#123; img.set(&#123; scaleX: board.width / img.width, scaleY: board.height / img.height &#125;); board.setBackgroundImage(img, board.renderAll.bind(board)); board.requestRenderAll(); &#125;, &#123; crossOrigin: 'anonymous' &#125;);&#125;// 设置自定义图片function setPicture(obj) &#123; obj.customiseCornerIcons(function () &#123; board.renderAll(); &#125;); fabricItemList.push(obj); board.add(obj); board.setActiveObject(obj);&#125;// 生成文字对象function addText(ctext) &#123; var color = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : \"#fff\"; var textObj = new fabric.Text(ctext, &#123; fontFamily: \"PingFang SC, Verdana, Helvetica Neue, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif\", fontSize: 30, top: 150, left: 150, originX: 'center', originY: 'center', fill: color &#125;); setPicture(textObj);&#125;// 生成图片对象function featImg(imgSrc, scale) &#123; fabric.Image.fromURL(imgSrc, function (img) &#123; img.set(&#123; scaleX: scale, scaleY: scale, angle: 0, left: Math.random() &lt; 0.5 ? Math.random() * 50 + 110 : -Math.random() * 50 + 110, top: Math.random() &lt; 0.5 ? Math.random() * 50 + 120 : -Math.random() * 50 + 120, hasControls: true, borderColor: '#fff' &#125;); setPicture(img); &#125;, &#123; crossOrigin: 'anonymous' &#125;);&#125; 3.生成画板图 1234567let drawImg = board.toDataURL(); // 生成后复原fabric对象fabricItemList.forEach(function (item) &#123; return board.remove(item);&#125;);fabricItemList = []; B部分： 如何根据设计稿精准绘制海报（重点）？ 1.使用现有成熟的方案： canvas2Image + html2canvas(高质量前端快照方案：来自页面的「自拍」) 详见网易云音乐团队的文章：https://juejin.im/post/5df2e8ab6fb9a0163770816d#heading-15 2.自己瞎折腾 最终选择：*自己瞎折腾 * 心路历程： ？？？？作者是不是脑子有病(小声BB)… 为什么我要做费力不讨好的事情？ 现成的库他不香吗？ 原因在于ios手机在授权后的：微信浏览器的白条问题 白条会使得整个可视区的DOM被向上顶一部分距离… 整个网上的方案都在现有资源下都不能好好解决，https://developers.weixin.qq.com/community/develop/doc/0000a09f840910386ee69390251c00 白条问题使得在使用前面的「自拍」方案时，生成的海报会错位…结果惨不忍睹！ html2canvas是根据遍历DOM样式信息来生成的，而且在遍历过程中，它会重新加载所有资源(在network自己看)，如果遇到质量较高或者像这样的数量的图片，会出现绘制空白的可能。 自己瞎折腾的结果： 根据canvas的drawimage写了个生成图的js，写的垃圾，大佬勿喷…https://github.com/tsunamiGG/utils/blob/master/makePoster.js。 大概思路： canvas图层堆叠是有顺序的，所以按照图层顺序进行传参。 为保证生成资源的完整性，必须先确保onload之后进入合成过程。 以左上角为原点，然后使用性能不错的drawimage(x,y,w,h)离屏渲染生成，从而避开了生成图被白条影响。 b部分：海报的清晰度(优化点) 可以看到上面的效果图清晰度是非常不理想的，需要优化。 为什么我们的canvas绘制的东西看上去总是比用DOM合成的东西糊一些？ 真实物理设备的像素和css的像素是有差距的，window.devicePixelRatio的值就反应了其比例。它告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。 同一个东西，你使用一个css像素来表示，假设在不同手机上分别浏览器本需要4个物理像素或8个物理像素。而canvas只用一个位图像素来填充4个物理像素或8个物理像素，不糊才怪呢.. 如果想深入了解，参考：https://juejin.im/post/5cbdda7bf265da036504fb46 1.js设置放大devicePixelRatio倍数宽高的canvas，css设置缩小devicePixelRatio倍数的canvas。扩大实际像素数量，视觉上保持跟原有尺寸一致，在API生成图片后会清晰很多。 这里需要注意的是，使用css缩小视觉画布时，由于fabirc会在html上生成两个canvas画布，分别是outer和inner，你需要把两个画布的css都缩小。 2.关闭canvas抗锯齿 123456789101112const canvas = document.createElement(\"canvas\");const scale = window.devicePixelRatio;canvas.width = width * scale;canvas.height = height * scale;const context = canvas.getContext(\"2d\").scale(scale, scale)// 关闭抗锯齿context.mozImageSmoothingEnabled = false;context.webkitImageSmoothingEnabled = false;context.msImageSmoothingEnabled = false;context.imageSmoothingEnabled = false; 优化后效果如下，手机保存图实际质量比这个高： 4.总结对十分陌生的canvas稍微有了一些认识，用canvas做动画的库非常多，但有个致命的缺点就是没办法进行调试… 其中还有很多微信浏览器的很多玄学问题就不展开了，白条问题确实是很头疼的。fabric可以整出很多惊艳的效果，但其乱七八糟的文档和糟糕的示例会带来很多麻烦，影响发挥…","categories":[],"tags":[{"name":"fabric canvas notes","slug":"fabric-canvas-notes","permalink":"https://tsunamigg.github.io/tags/fabric-canvas-notes/"}]},{"title":"创建对象的几种方式","slug":"object-create","date":"2019-08-25T11:45:38.000Z","updated":"2020-05-28T14:21:24.705Z","comments":true,"path":"2019/08/25/object-create/","link":"","permalink":"https://tsunamigg.github.io/2019/08/25/object-create/","excerpt":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式","text":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式 1.简单工厂模式：Simple Factory工厂模式什么意思？ 如果把我们编写业务代码的过程，比作造一台电视机，那么工厂模式就是先打造好生产电视机的流水线。如何打造生产线？？？ 我们将需要工厂制造的产物的特性抽象出来，在代码上表现为我们规定其属性名称，但其属性值又参数来决定。 1234567function createBook(name, pages, author) &#123; let newBook = &#123;&#125;; newBook.name = name; newBook.pages = pages; newBook.author = author; return newBook;&#125; 这是一种工厂模式，其实现方式与之前学基础的寄生继承有点相似，也是在一个新的变量上去添加属性，使用字面量方式创建对象会比使用new高效的多。 还有一种就是先将不同型号的电视机造出来，然后通过工厂来输送到不同的产品区。 这里的工厂不在制造，而是充当deliver的角色。 123456789101112131415161718192021222324function fictionBook() &#123; this.name = '九州缥缈录'; this.story = '铁甲依然在'; this.tellStory = function()&#123; console.log(this.story) &#125;&#125;function classicBook() &#123; this.name = '假如给我三天光明'; this.author = '海伦凯勒'; this.bookauthor = function () &#123; console.log(this.author) &#125;&#125;function createBook(type) &#123; switch (type) &#123; case 'fiction': return new fictionBook(); case 'classic': return new classicBook(); &#125;&#125; 两种方式优缺点十分明显， 第一种常见方式需要我们固定某些参数类型，限制了其多样性，但相比第二种省事多了。第二种则相反，每创造一种不同型号的电视机就需要我们去创建一个新的类并向分发类添加该选项。 2.工厂方法模式: Factory Method12345678910111213141516//安全模式 const Factory = function (type, content) &#123; if (this instanceof Factory) &#123; return new this[type](content); &#125; else &#123; return new Factory(type, content); &#125; &#125;Factory.prototype = &#123; show: function(content) &#123; this.content = content; console.log(content); &#125;&#125;const test = new Factory('show', '2'); 安全模式的好处在于，在简单工厂模式上加了一层限制，如果没有创建工厂类，就直接执行该函数而不是返回工厂对象。 12345678910111213141516171819202122232425262728293031323334353637383940//抽象模式const abstractFactory = function (superType, subType) &#123; if (typeof abstractFactory[superType] === 'function' ) &#123; function F() &#123;&#125;; F.prototype = new abstractFactory[superType](); subType.constructor = subType; subType.prototype = new F(); &#125; else &#123; throw new Error('未创建该抽象类') &#125;&#125;abstractFactory.desk = function() &#123; this.type = 'desk';&#125;abstractFactory.desk.prototype = &#123; getDeskSize: function () &#123; return new Error('抽象方法不能调用') &#125;, getDeskMaterial: function() &#123; return new Error('抽象方法不能调用') &#125;&#125;//实例化抽象desk类// 1.子类构造方法let machilusDesk = function(size, material) &#123; this.size = size; this.material = material;&#125;// 2. 将子类构造方法送入工厂，继承工厂抽象方法abstractFactory('desk', machilusDesk);// 3. 覆盖抽象方法machilusDesk.prototype.getDeskSize = function() &#123; return this.size;&#125;machilusDesk.prototype.getDeskMaterial = function() &#123; return this.material;&#125; 在JS中，abstract是一个保留关键字，所以想要实现抽象类，是不可能像传统的面向对象语言那么方便，但由于其灵活性，我们可以模拟出抽象类的主要行为。 抽象方法时不可调用的，会报错，所以我们模拟出其这个行为，并且采用寄生继承来继承父类。当工厂生成子类后，覆盖抽象方法，就不会报错了。 抽象模式是提前定义了类的结构，而不是直接创建类。就像建房子先画好房子的图纸一样，先描述出其轮廓~ 但JS中不支持抽象化创建和虚拟方法，所以其引用并不广泛，但也是面向对象编程中很经典常见的一种模式。 3.建造者模式： Builder如果说工厂模式的侧重点在创建的结果，那么建造者就是注重创建过程的一种模式。 建造者会注意创建过程的每个细节，就像我们捏橡皮人时，不光要注意身体的轮廓，还要注意头有多大，四肢有多长….理所当然的创建过程会复杂很多。 其过程就是将各种特性都封装成类，然后在主类里面根据不同参数，实例化不同的特性，组成新的子类，或者叫其复合对象。 123456789101112131415161718192021222324252627function House(parmas) &#123; this.material = parmas &amp;&amp; parmas.material || '**'; this.area = parmas &amp;&amp; parmas.area || '**';&#125;House.prototype = &#123; getMaterial: function() &#123; return this.material; &#125;, getArea: function() &#123; return this.area; &#125;&#125;function material(material) &#123; this.material = material;&#125;function area(m) &#123; this.area = m * m;&#125;function newHouse(material, m) &#123; let _house = new House(); _house.material = new material(material); _house.area = new area(area); return _house;&#125; 就像搭积木一样，先把各块积木的形状找好，然后组合在一起。抛出一个问题，如果要在一个网页上呈现卡片堆砌的效果，你会怎么做呢？ 个人理解，这个模式是我们经常解决生活中问题的一种方法的抽象，复杂的问题简单化，就是将一个复杂的事物拆分成多个简单的事物，再以某种方式组合起来，来解决问题的一种方法。 4.原型模式：prototype其被称为语言之魂，它将原型对象指向创建对象的类，使这些类共享原型对象的方法和属性。 存在即合理，那么它解决了什么问题？在很多复杂的功能下，我们的子类需要继承父类的一些属性与方法，但是并非所有子类需求的属性和方法都是一致的，所以子类会从父类继承一些不必要的，增加额外开销的属性和方法。例如，一个车的父类，子类可能是跑车，轿车，SUV，越野，跑车需要整个车体结构和轿车不一样，但父类因为考虑整体性不会有特殊的车体结构，而是通用的轿车结构，那么子类就从父类继承了一些额外的负担性质的属性和方法。而子类每次实例化都会造成很多不可避免的额外开销。 原型概念就此而出，它将某些可复用，可共享的，开销大的属性和方法从父类提取出来放在原型之中，子类通过前文的某些继承方式来继承，直接获得这些属性和方法而不是每次实例化重新创建这些属性和方法，节省了很多不必要的开销。 js在原型模式下实现的原型链，让所有内置的属性和方法都享受到该模式的好处。 其实现方式就是对一个对象的拷贝，也是一种继承方式，但很特殊的一点，创建过程于它无瓜，理解这一点很重要~ 5.单例模式： singleton这是js编程中很常见的一种模式，只允许实例化一次的对象类。有时生成命名空间namespace。多人协作开发或者加载独立的第三方库的时候，我们的词语总是有限的，怎么让它们的命名互不影响呢？答案说都开辟独立的命名空间，使得其方法名都可以区分开。同时，对我们在管理静态变量也非常有帮助。 风靡很多时的Jquery就是经典的例子，其$符就是命名空间，$(&#39;className&#39;).function这样的调用方式使得代码清晰明了，一看就知道是Jquery的方法。 1234567891011let mynamespace = &#123; utils: &#123; formate: function() &#123; ..... &#125; &#125;, ajax: function() &#123; ..... &#125; MYHEIGHT: 180&#125; 其实就是封装在一个对象里面，延展开来就是模块机制，把整个js文件作为一个对象，存放不同的命名空间，避免方法名的覆盖。 怎么实现只能实例化一次的对象类？ 妈耶，用个闭包记录，如果被实例化了，就return掉，easy。 什么？ 怎么创建一个闭包？？？ 建议你去看看《你不知道的javascript》,书中详细的论述了闭包是什么，怎么创建闭包，闭包的用途又是什么，闭包背后的作用机制其实是保持对作用域的引用等等。下次有空，结合书本我们来详解一下js中的闭包，解开其神秘的面纱。 总结 创建型设计模式是一些处理对象创建的模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。 创建单类简单对象的简单工厂模式，简单的缺点也很明显，于是工厂方法模式补足创建多类的实例(其实是传入不同参数的简单工厂模式和安全模式的混合)。建造者模式则是通过组合多种简单工厂模式，来创造复杂的对象。原型模式也被成为语言之魂，将某些属性和方法放在原型对象中作为所有对象的共有属性和方法，避免了子类每次实例化都会可能创建新的不必要的，开销大的属性和方法。单例模式则是为我们的代码管理做出了卓越的贡献。这五种模式中，原型模式并不关心对象创建过程，但对创建过程做出的贡献还是有目共睹，或许这就是大佬吧，润物细无声~","categories":[],"tags":[{"name":"javascript-native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"}]},{"title":"7.http缓存","slug":"http7","date":"2019-07-12T07:33:20.000Z","updated":"2020-06-01T14:36:56.099Z","comments":true,"path":"2019/07/12/http7/","link":"","permalink":"https://tsunamigg.github.io/2019/07/12/http7/","excerpt":"不打不相识之http缓存","text":"不打不相识之http缓存 初识http缓存近日，发现我打包的js代码上传到服务器后，并没有更新。想到用ng做了代理，可能是ng缓存的问题，就查资料学习了一下http（1.1）缓存的东西。 1.相关术语：(约定req为请求头，res响应头，C客户端，S服务端)1234567891011// response HeadersHTTP/1.1 200 OKServer: nginxDate: Wed, 04 Dec 2019 09:11:07 GMTContent-Type: text/cssVary: Accept-EncodingLast-Modified: Wed, 04 Dec 2019 09:03:18 GMTETag: W/\"5de77656-2340\"Expires: Wed, 04 Dec 2019 21:11:06 GMTCache-Control: max-age=43200Content-Encoding: gzip Expires ：res中为资源过期时间 Last-Modified： res中为资源最近修改时间 ETag： res中资源的唯一标识符(hash算法生成) If-Modified-Since ： req中的资源最近修改时间 If-None-Match ：req中的资源标识 Cache-Control ： res，req中表示缓存策略 req中常用指令 字段名称 说明 max-age= 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间 max-stale[=] C可接收一个已经过期的资源。设置一个可选的秒数，不接受超过给定时间的资源 min-fresh= C希望获取一个能在指定的秒数内保持其最新状态的res no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 no-store 不缓存有关客户端请求或服务器响应的任何内容 ​ 2. res中常用指令(req中重复的不列举，详见MDN) 字段名称 说明 public 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容 private 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容 must-revalidate 一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求 proxy-revalidate 与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略 s-maxage= 覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它 其中Last-Modified与If-Modified-Since，ETag与If-None-Match是在每次的res，req中配对使用的。 2. 常见缓存场景：(约定资源为app.js) Expires： 过程 C端请求app.js —-&gt; S端。 S端响应app.js 与Expires —-&gt; C端。(C端缓存app.js直到Expires) if 1 发生在Expires 前，会直接从缓存中取, else 2 重复以上 优势 相比于最原始的不带缓存的请求和相应，优势很明显，会直接从缓存中取，减少请求响应次数 缺陷 如果app.js在Expires 内发生了改变，C端呈现的资源不是最新的。 Expires + Last-Modified： 过程 C端请求app.js —-&gt; S端 S端响应app.js 与Expires*， *Last-Modified —-&gt; C端。(C端缓存app.js直到Expires,上次修改时间是 Last-Modified） if 1 发生在Expires 前，会直接从缓存中取(200)。 else C端请求S端，带上If-Modified-Since（等于上一次相应的Last-Modified） S端用req中的If-Modified-Since和res中的 Last-Modified比较。 if 一致，响应 C端：你可以继续用本地缓存(304) else,2 重复以上 优势 相比与只使用Expires，if app.js发生变化，可以更新缓存，C端呈现内容为最新，else 不会有新的res拉一次资源，直接读缓存 缺陷 Last-Modified精确到秒，实际中有很多一秒内会完成很多req和res,问题呼之欲出 在 Last-Modified内，app.js被修改多次，那么C端还是会从缓存中读，呈现内容不是最新 假设处于vue-cli开发下，因为某种原因，代码实际没有修改，但CI/CD重复构建打包了文件,app.js变为了app01.js(build.js生成的不同版本hash名称)，但代码只是名称变化，内容并不变化，却重新拉了一次资源 Expires + Last-Modified + ETag： 过程 C端请求app.js —-&gt; S端 S端响应app.js 与Expires*， *Last-Modified ,ETag—-&gt; C端。(C端缓存app.js直到Expires,上次修改时间是 Last-Modified,文件标识是ETag） if 1 发生在Expires 前，会直接从缓存中取(200)。 else C端请求S端，带上If-Modified-Since（等于上一次相应的Last-Modified）和If-None-Match（等于上一次相应的Etag） S端用req中的If-None-Match和res中的 Etag比较，忽略掉If-Modified-Since和Last-Modified的比较。(如果Etag变化，Last-Modified一定变化，充分条件) if 一致，响应 C端：你可以继续用本地缓存(304) else,2 重复以上 优势 相较于上一种，使得资源变更的验证更加严格。 缺陷 让我们设想这种情况，我们频繁的修改app.js，打包构建，处于某种原因，我们并不想C端呈现最新的app.js，而是一段时间后再读取最新的，显然还达不到我们的要求 Expires + Last-Modified + ETag + Cache-Control ： 过程 C端请求app.js —-&gt; S端 S端响应app.js 与Expires*， *Last-Modified ,ETag， *Cache-Control：max-age=43200 —-&gt; C端。(C端发现带有 Cache-Control：max-age=43200,忽略Expires，记住Last-Modified ,ETag） if 1 发生在（req发生的时间+ 12h(43200s)），会直接从缓存中取(200)。 else C端请求S端，带上If-Modified-Since（等于上一次相应的Last-Modified）和If-None-Match（等于上一次相应的Etag） S端用req中的If-None-Match和res中的 Etag比较，忽略掉If-Modified-Since和Last-Modified的比较。(如果Etag变化，Last-Modified一定变化，充分条件) if 一致，响应 C端：你可以继续用本地缓存(304) else,2 重复以上 优势 达到了我们上个方案达不到的效果 缺陷？ C端无法主动知道S端上我们请求的资源变化，只能被动的从res中得知，这算缺陷吗？我更多的认为是基于某种安全策略，所以这样规定。 3. 常见问题：(约定资源为app.js) 如何设置不缓存？ ng配置如下： 12345678910111213// 还有多种设置方法，举例一种// 重启ng不一定立即生效location / &#123; access_log /data/nginx/log/xxx.log api; root /home/www/html; if ($request_filename ~ .*\\.(htm|html)$) &#123; add_header Cache-Control no-cache; &#125;&#125; 打包html设置meta标签如下 123&lt;meta http-equiv=\"Cache-Control\" content=\"no-cache, no-store, must-revalidate\" /&gt;&lt;meta http-equiv=\"Pragma\" content=\"no-cache\" /&gt;&lt;meta http-equiv=\"Expires\" content=\"0\" /&gt; meta是用来在HTML文档中模拟HTTP协议的响应头报文。meta 标签用于网页的与中，meta 标签的用处很多。meta 的属性有两种：name和http-equiv。name属性主要用于描述网页，对应于content（网页内容），以便于搜索引擎机器人查找、分类（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）。这其中最重要的是description（站点在搜索引擎上的描述）和keywords（分类关键词），所以应该给每页加一个meta值。 如何清理缓存？ Nginx企业版提供了purger功能，对于社区版Nginx可以考虑使用ngx_cache_purge`（https://github.com/FRiCKLE/ngx_cache_purge）模块进行清理缓存。（该方法最好限制其访问权限，如只允许内网可以访问或者需要密码才能访问） 123456789location ~ /purge(/.*) &#123; allow 127.0.0.1; deny all; proxy_cache_purge cache$1$is_args$args; &#125; PS： 类似宝塔面板这种Ng都自动安装了ngx_cache_purge模块，如何设置详见下方参考。 找到缓存文件夹，直接kill。 如果发生缓存错误，检查的步骤？ 检查是否传错文件夹 打开项目打包后的js，检查app.js文件名。 打开浏览器控制台Network,勾选js,F5刷新后找到对应的app.xxx.js，比较。如果你发现名称不一样，而且res头部 Last-Modified也不对，那么大概率你传错文件夹了。 检查是否正确更新 记录现阶段 ETag 重新上传后刷新，比较两次 ETag是否一致 检查是否正确配置ng等Server 梳理构建部署步骤，逐步检查(只能帮你到这啦) 只是http（1.1）的部分常见场景，目前到这里已经足够，咱得一步一步来，切勿囫囵吞枣~ 思考有限，难免出现疏漏，欢迎诸位指出，集思广益。 reference 《面试精选之http缓存》 https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-2 《MDN - Cache-Control》https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control 《浅谈http中的Cache-Control》https://blog.csdn.net/u012375924/article/details/82806617 《Nginx缓存配置及nginx ngx_cache_purge模块的使用》https://www.cnblogs.com/Eivll0m/p/4921829.html","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://tsunamigg.github.io/tags/http/"}]},{"title":"6.http核心","slug":"http6","date":"2019-06-29T11:13:20.000Z","updated":"2020-06-01T14:38:49.164Z","comments":true,"path":"2019/06/29/http6/","link":"","permalink":"https://tsunamigg.github.io/2019/06/29/http6/","excerpt":"http报文是奠定其成为应用层大哥的核心，恕我HTTP直言，在座的应用层协议都是辣鸡~","text":"http报文是奠定其成为应用层大哥的核心，恕我HTTP直言，在座的应用层协议都是辣鸡~ HTTP的核心基于前面的基础知识复习，我发现所谓的HTTP协议其实“名不副实”。 因为它压根儿不管”传输“的过程，这部分的工作被TCP/IP老哥任劳任怨的干了。其工作模式很简单，“请求 - 应答”，但其就强在简单，奠定了现代web一哥的地位。 那么它的核心内容，是那些被传输的内容：http报文。 HTTP 协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略。 所以可以在 TCP/IP 层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。 报文结构和TCP/UDP一样，都需要在实际传输的数据前加一些“料”(附加头数据)，但它是一个“纯文本”的协议，所以头数据都是 ASCII 码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。 很常见的一个浏览器优化过的请求头例子： 1234567891011121314151617GeneralRequest URL: https://blog.csdn.net/weixin_44163780/article/uvc/90693902Request Method: GETStatus Code: 200 Remote Address: 127.0.0.1:7890Referrer Policy: unsafe-urlResponse HeadersAccess-Control-Allow-Origin: *cache-control: no-cacheContent-Security-Policy: script-src 'self' 'sha256-nl+LCdUZCsURbeBC1buBlAcvBhCD2/SswpeCH2ZaR34=' 'sha256-nuF8drPPKUM4+b3urtYHupidizytc1BonZF1t/vSzs0'; object-src 'self';Content-Type: text/cssETag: \"7UTBv1mKEz8B8cXsi14YOLWk94U=\"Request HeadersReferer: https://blog.csdn.net/weixin_44163780/article/details/90693902User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36Bodybody&gt;div#blockbyte-bs-indicator&gt;div&#123;opacity:0;pointer-events:none&#125;body&gt;iframe#blockbyte-bs-sidebar.blockbyte-bs-visible,body&gt;iframe#blockbyte-bs-overlay.blockbyte-bs-visible&#123;opacity:1;pointer-events:auto&#125;body.blockbyte-bs-noscroll&#123;overflow:hidden !important&#125;body&gt;div#blockbyte-bs-indicator&gt;div&#123;position:absolute;transform:translate3d(-\"%indicatorWidth\", 0, 0);top:0;left:0;width:\"%indicatorWidth\" !important;height:100%;background:\"%indicatorColor\";border-radius:0 10px 10px 0;transition:opacity 0.3s, transform 0.3s;z-index:2&#125;body&gt;div#blockbyte-bs-indicator&gt;div&gt;span&#123;-webkit-mask:no-repeat center/\"%indicatorIconSize\";-webkit-mask-image:url(chrome-extension://jdbnofccmhefkmjbkkdkfiicjkgofkdh/img/icon-bookmark.svg);background-color:\"%indicatorIconColor\";position:absolute;display:block;top:0;left:0;width:100%;height:100%&#125;body&gt;div#blockbyte-bs-indicator[data-pos='right']&#123;left:auto;right:0&#125;body&gt;div#blockbyte-bs-indicator[data-pos='right']&gt;div&#123;transform:translate3d(\"%indicatorWidth\", 0, 0);left:auto;right:0;border-radius:10px 0 0 10px&#125;body&gt;div#blockbyte-bs-indicator.blockbyte-bs-fullHeight&gt;div&#123;border-radius:0&#125;body&gt;div#blockbyte-bs-indicator.blockbyte-bs-hover&gt;div&#123;transform:translate3d(0, 0, 0);opacity:1&#125;body&gt;div#blockbyte-bs-indicator[data-pos='left'].blockbyte-bs-has-lsb&#123;height:100% !important;top:0 !important&#125;body&gt;div#blockbyte-bs-indicator[data-pos='left'].blockbyte-bs-has-lsb&gt;div&#123;background:transparent&#125;body&gt;div#blockbyte-bs-indicator[data-pos='left'].blockbyte-bs-has-lsb&gt;div&gt;span&#123;-webkit-mask-position-y:20px&#125;body&gt;iframe#blockbyte-bs-sidebar&#123;width:\"%sidebarWidth\";max-width:none;height:0;z-index:2147483646;background-color:\"%sidebarMaskColor\" !important;border:none;display:block !important;transform:translate3d(-\"%sidebarWidth\", 0, 0);transition:width 0s 0.3s, height 0s 0.3s, opacity 0.3s, transform 0.3s&#125;body&gt;iframe#blockbyte-bs-sidebar[data-pos='right']&#123;left:auto;right:0;transform:translate3d(\"%sidebarWidth\", 0, 0)&#125;body&gt;iframe#blockbyte-bs-sidebar.blockbyte-bs-visible&#123;width:calc(100% + %sidebarWidth);height:100%;transform:translate3d(0, 0, 0);transition:opacity 0.3s, transform 0.3s&#125;body&gt;iframe#blockbyte-bs-sidebar.blockbyte-bs-hideMask&#123;background:none !important&#125;body&gt;iframe#blockbyte-bs-sidebar.blockbyte-bs-hideMask:not(.blockbyte-bs-hover)&#123;width:calc(%sidebarWidth + 50px)&#125;body&gt;iframe#blockbyte-bs-overlay&#123;width:100%;max-width:none;height:100%;z-index:2147483647;border:none;background:\"%overlayMaskColor\" !important;transition:opacity 0.3s&#125; HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成： 起始行(start line): 描述请求或相应的基本信息； 头部字段集合（header）：使用 key-value 形式更详细地说明报文； 消息正文（body/entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。 这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。 HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。 一个真正的报文 = start line + header + CRLF(空行) + (body/entity) 由于“快递式”的包装，拆包装的工作方式，我们在TCP/IP上传输了太多对于真实数据无用的信息，header里面各种token，cookie验证的一大堆字符串泛滥。TCP/IP老哥，我太难了… 使用ABNF(扩充巴科斯-瑙尔范式)描述HTTP报文上面提到报文的结构，那么怎么科学严谨的描述它，就要使用ABNF了。 范式两个字是不是回想起大学时间老师教SQL数据库时的范式 巴科斯范式的英文缩写为BNF,它是以美国人巴科斯（Backus）和丹麦人（Naur）的名字命名的一种形式化的语法表示方法，用来描述语法的一种形式体系，是一种典型的元语言。又称巴科斯-诺尔形式（Backus-Naur form）。它不仅能严格的表示语法规则，而且所描述的语法与上下文无关的。它具有语法简单，表示明确，便于语法分析和编译的特点。 ABNF规则空白字符( SP )：用来分隔定义中的各个元素 method SP request-target SP HTTP-version CRLF 选择（ / ）：表示多个规则都是可供选择的规则 start-line=request-line / status-line 值范围 （ %c##-## ）： OCTAL=”0” / “1” / “2” / “3” / “4” / “5” / ”6“ / ”7“ 与 OCTAL=%x30-37 等价 序列组合（）:将规则组合起来，视为单个元素 不定量重复 （ m*n ）： * 元素表示零个或更多元素：*（header-field CRLF） 1* 元素表示一个或更多元素，2*4 元素表示两个至四个元素 可选序列（ [] ）： [ message-body ] 规则 形式定义 意义 ALPHA %x41-5A / %x61-7A 大小写字母（A-z） DIGIT %x30-39 数字（0-9） HEXDIG DIGIT/“A”/“B”/“C”/“D”/“E”/“F” 十六进制数(0-9,A-F,a-f) DQUOTE %x22 双引号 SP %x20 空格 HTAB %x09 横向制表符 WSP SP/HTAB 空格或横向制表符 LWSP *(WSP/CRLF WSP) 直线空白 VCHAR %x21-7E 可见字符 CHAR %x01-7F 任何7-位US-ASCII字符，不包括NUL OCTET %x00-FF 8位数据 CTL %x00-1F/%x7F 空值字符 CR %x0D 回车 （mac） LF %x0A 换行 （Linux） CRLF CR LF 标准换行（windows） BIT “0”/“1” 二进制数字 ABNF表示HTTP-message=start-line ( *header-filed** CRLF ) CRLF [ message-body ] start-line= request-line / status-line ​ request-line= method SP resquest-status SP HTTP-version CRLF ​ status-line= HTTP-version SP status-code SP reason-phrase CRLF header-filed= field-name “:” OWS field-value OWS ​ OWS= *(SP / HTAB) ​ field-name = token ​ field-value = *(field-content / obs-fold ) *message-body *= *OCTET 示例： 123456789101112131415161718192021# curl -I www.baidu.com&#x2F;&#x2F; 输出HTTP&#x2F;1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: keep-aliveContent-Length: 277Content-Type: text&#x2F;htmlDate: Fri, 29 May 2020 04:55:28 GMTEtag: &quot;575e1f71-115&quot;Last-Modified: Mon, 13 Jun 2016 02:50:25 GMTPragma: no-cacheServer: bfe&#x2F;1.0.8.18&#x2F;&#x2F; 状态行示例status-line&#x3D; HTTP-version SP status-code SP reason-phrase CRLFHTTP&#x2F;1.1 200 OKHTTP&#x2F;1.1 400 Bad Request................ 可见用这种元语言来描述HTTP的消息很方便，虽然有一些规定的理解成本，但有了约束会理解的更加清晰。 常用头字段HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类： 通用字段：在请求头和响应头里都可以出现； 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件； 响应字段：仅能出现在响应头里，补充说明响应报文的信息； 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。 1.Host： 它属于请求字段，只能出现在请求头里，它同时也是唯一一个 HTTP/1.1 规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文 2.User-Agent： 是请求字段，只出现在请求头里。它使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。 但由于历史的原因，User-Agent 非常混乱，每个浏览器都自称是“Mozilla”“Chrome”“Safari”，企图使用这个字段来互相“伪装”，导致 User-Agent 变得越来越长，最终变得毫无意义。 不过有的比较“诚实”的爬虫会在 User-Agent 里用“spider”标明自己是爬虫，所以可以利用这个字段实现简单的反爬虫策略 3.Date： 字段是一个通用字段，但通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略 4.Server： 是响应字段，只能出现在响应头里。它告诉客户端当前正在提供 Web 服务的软件名称和版本号。 Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在 bug，那么黑客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。 状态码描述 状态行的 范式：status-line= HTTP-version SP status-code SP reason-phrase CRLF的tatus-code是状态行中信息量最多的部分，HTTP-version大多都是HTTP/1.1，reason-phrase则是写很常见的短语：“OK”，“Not Found”，“Bad Request” 等等。 目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。但如果把代码简单地从 000 开始顺序编下去就显得有点太“low”，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。 RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 099 不用，这样状态码的实际可用范围就大大缩小了，由 000999 变成了 100~599。 总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。所以 Apache、Nginx 等 Web 服务器都定义了一些专有的状态码。如果你自己开发 Web 应用，也完全可以在不冲突的前提下定义新的代码。 这五类的具体含义是： 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作； 2××：成功，报文已经收到并被正确处理； 3××：重定向，资源位置发生变动，需要客户端重新发送请求； 4××：客户端错误，请求报文有误，服务器无法处理； 5××：服务器错误，服务器在处理请求时内部发生了错误。 从这五类的具体含义可以看出，状态码并不单单表明这次请求的客户端或者服务端的“反应结果”，而是表明双方进行处理后的结果，可能是客户端的请求报文有错误，也可能是服务端内部处理时发生了错误等等。 常见的状态码： 101 Switching Protocols: 它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了 206 Partial Content: 是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。 301 Moved Permanently: 俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。与302(Moved Temporarily)临时重定向，一词之差，应用场景却有很大不同。如果你的服务从http升级到https，就需要配置301，永久重定向后的跳转链接；如果今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。 304 Not Modified: 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。 400 Bad Request: 是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。 403 Forbidden: 实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。 405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET； 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文； 408 Request Timeout：请求超时，服务器等待了过长的时间； 409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态； 413 Request Entity Too Large：请求报文里的 body 太大； 414 Request-URI Too Long：请求行里的 URI 太大； 429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略； 431 Request Header Fields Too Large：请求头某个字段或总体太大； 500 Internal Server Error：与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。 500 Internal Server Error：与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。 502 Bad Gateway：通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的 503 Service Unavailable：表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个“Retry-After”字段，指示客户端可以在多久以后再次尝试发送请求 内容协商假如 HTTP 没有告知数据类型的功能，服务器把“一大坨”数据发给了浏览器，浏览器看到的是一个“黑盒子”，面对茫茫多的数据类型，猜不太可能，于是就有了两端的内容协商。 内容的数据类型HTTP用一部分的“MIME”来标记body中的数据类型，叫“MIME type”。用“Encoding type”来表明数据的压缩类型(编码格式)。还有语言类型，编码类型… 常见的MIME type: text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。 image：即图像文件，有 image/gif、image/jpeg、image/png 等。 audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。 application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。 常见的Encoding type: gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式； deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip； br：一种专门为 HTTP 优化的新压缩算法（Brotli）。 常见的Language type: zh-CN, zh, en 常见的Charset type: gbk, utf-8 上述的是“内容协商”的键值对的值，HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段作为“内容协商”的键值对的键。 也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。 例如上文中举例的报文： 12345Accept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: keep-aliveContent-Length: 277Content-Type: text/html 可以用“,”做分隔符列出多个类型，例如下面： 12345Accept-Encoding: gzip, deflate, brContent-Encoding: gzipAccept-Language: zh-CN, zh, enAccept-Charset: gbk, utf-8Content-Type: text/html; charset=utf-8 说完了表示数据类型的主体内容，还有一些辅助内容。 内容的选择权重在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级，这里的“q”是“quality factor”的意思。 权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加一个“;”，然后是“q=value”。 这里要提醒的是“;”的用法，在大多数编程语言里“;”的断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反了过来，“;”的意义是小于“,”的。 例如下面的 Accept 字段： 1Accept: text/html,application/xml;q=0.9,*/*;q=0.8 它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。 内容协商的结果内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样。但有的时候，服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段，给出一点信息，例如： 1Vary: Accept-Encoding,User-Agent,Accept 这个 Vary 字段表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。 Vary 字段可以认为是响应报文的一个特殊的“版本标记”。每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务。 Http缓存常用字段约定req为请求头，res响应头，C客户端，S服务端 Expires ：res中为资源过期时间 Last-Modified： res中为资源最近修改时间 ETag： res中资源的唯一标识符(hash算法生成) If-Modified-Since ： req中的资源最近修改时间 If-None-Match ：req中的资源标识 Cache-Control ： res，req中表示缓存策略 req中常用指令 字段名称 说明 max-age= 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间 max-stale[=] C可接收一个已经过期的资源。设置一个可选的秒数，不接受超过给定时间的资源 min-fresh= C希望获取一个能在指定的秒数内保持其最新状态的res no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 no-store 不缓存有关客户端请求或服务器响应的任何内容 ​ 2. res中常用指令(req中重复的不列举，详见MDN) 字段名称 说明 public 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容 private 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容 must-revalidate 一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求 proxy-revalidate 与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略 s-maxage= 覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它 其中Last-Modified与If-Modified-Since，ETag与If-None-Match是在每次的res，req中配对使用的。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://tsunamigg.github.io/tags/http/"}]},{"title":"5.从一次链接看TCP与HTTP","slug":"http5","date":"2019-06-22T12:22:40.000Z","updated":"2020-06-01T14:36:49.434Z","comments":true,"path":"2019/06/22/http5/","link":"","permalink":"https://tsunamigg.github.io/2019/06/22/http5/","excerpt":"使用Wireshark抓包，从一次链接看TCP与HTTP","text":"使用Wireshark抓包，从一次链接看TCP与HTTP TCPHeader 第一次请求包示例： 60738 -&gt; 8081 [SYN] Seq=0 Win=64240 Len=0 Mss=1460 Ws=256 SACK_PERM=1 请求信息字段名详解1. Win: TCP 窗口大小，是指TCP传输能接受的最大字节数，这个可以进行动态调节，也就是TCP的滑动窗口，通过动态调整窗口大小，来控制发送数据的速率。上图中占用2个字节，也就是16位，那么可以支持的最大数就是2^16=65536，所以默认情况下TCP头部标记能支持的最大窗口数是65536字节，也就是64KB。 2. Len: 消息长度就是指数据报文段，因为整个TCP报文=Header+packSize,所以这个消息长度就是指要传送的数据包总共长度，在本次分析中也就是HTTP报文的大小。 3. Mss: 最大报文段长度：这个就是规定最大的能传输报文的长度，为了达到最佳的传输效能，TCP协议在建立连接的时候通常要协商双方的MSS值，这个值TCP协议在实现的时候往往用MTU( 最大传输单元)值代替（以太网的1500减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以一般MSS值1460，而实际上的MSS值一般会比这个数字大。 TSO（TCP Segment Offload）的技术，该项技术是将部分的封包解包的处理工作交给了网卡，从而让CPU减少部分包处理的工作。 网卡支持TSO技术时，TCP层会逐渐的加大MSS（包大小超过MSS字节），当下层接收到这个大包时不会做分包而是直接下发给下一层，当到达网卡后网卡会将这个大的IP包拆分为N个包（小于等于MTU字节的包）发送出去，而接收端也是这样处理，这样就相当于把部分包的组装工作给网卡去做（硬件的处理速度会比软件快很多）。 4. Ws: 窗口缩放调整因子：在前面说TCP窗口大小中我们说到，默认情况下，TCP窗口大小最大只能支持64KB的缓冲数据，在今天这个高速上网时代，这个大小肯定不满足条件了，所以，为了能够支持更多的缓冲数据 RFC 1323中就规定了TCP的扩展选项，其中窗口缩放调整因子就是其中之一，这个是如何起作用的呢？首先说明，这个参数是在[SYN]同步阶段进行协商的，我们结合上面抓包数据分析下。我们看到第一次请求协商的结果是WS=256,然后再ACK阶段扩展因子生效，调整了窗口大小。 生效的抓包如下： 60738 -&gt;8081 [ACK] Seq=1 ACK=1 Win=66560 Len=0 我们发现这个窗口变成了66560，比默认的窗口要大，我们查看报文详情： 我们发现，实际请求声明的窗口是260，WS扩展因子是256，最终计算的窗口大小是66560，所以我们知道了，这个扩展因子的作用就是，用原窗口大小乘以扩展因子，得到最终的窗口大小，也就是260*256=66560. 5. SACK_PERM:SACK选项，我们知道TCP传输有包的确认机制，默认情况下，接受端接受到一个包后，发送ACK确认，但是，默认只支持顺序的确认，也就是说，发送A,B,C个包，如果我收到了A,C的包，B没有收到，那么对于C，这个包我是不会确认的，需要等B这个包收到后再确认，那么TCP有超时重传机制，如果一个包很久没有确认，就会当它丢失了，进行重传，这样会造成很多多余的包重传，浪费传输空间。为了解决这个问题，SACK就提出了选择性确认机制，启用SACK后，接受端会确认所有收到的包，这样发送端就只用重传真正丢失的包了。 三次握手TCP三次握手（建立连接过程） 角色发送 过程 报文首部 报文部分内容 状态 客户端 1次握手 SYN = 1 seq = x SYN_SENT 服务端 2次握手 SYN = 1, ACK= 1 ack = x +1, seq = y SYN_RECD 客户端 3次握手 ACK = 1 ack = y + 1,seq = x +1 ESTABLISHED 我们根据上面的流程梳理，可以知道，序号1-序号3是明显的三次握手，然后序号4进行了一次HTTP请求，接着序号5是对HTTP请求的一次接收确认，序号6是响应HTTP请求，序号7是对响应请求的确认。 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手？ 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 四次挥手TCP四次挥手（断开连接过程） 角色发送 过程 报文首部 报文部分内容 状态 客户端 1次挥手 FIN = 1 seq = u FIN_WAIT_1 服务端 2次挥手 ACK = 1 ack = u +1,seq = v CLOSE_WAIT 客户端 3次挥手 FIN = 1 ack = u + 1,seq = w LAST_ACK 服务端 4次挥手 ACK = 1 ack = w + 1，seq = u +1 TIME_WAIT 注意此时的TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才会进入CLOSED状态。 服务器收到客户端发送的确认，立即进入CLOSED状态。 可以从上面发现，服务端结束连接要比客户端早一些 PS： seq：序列号 ack：确认号 SYN：请求同步标志 ACK：确认标志 FIN ： 结束标志 “四次挥手”在抓包里没有出现，这是因为 HTTP/1.1 长连接特性，默认不会立即关闭连接。 正常情况下，连接断开是4次挥手的，4次挥手过程如下图： 我们分析这图，挥手流程是这样的： 第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次挥手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 上述序号8,9,10是我关闭浏览器后抓到的包，既然是关闭浏览器，我们肯定知道就是TCP连接的断开了。这里有同学应该已经发现了问题了，我们的断开是4次挥手，你这抓的包只有三条记录，是你写错了吧？我要告诉你的是，我没有写错，这是真实的抓包抓的，至于为什么是三次，我们来分析一下： 在 RFC 2581中的4.2节有提到，ack可以延迟确认，只要求保证在500ms之内保证确认包到达即可。在这样的标准下，TCP确认是有可能进行合并延迟确认的，所以，根据这一点，我们推断下面这个包： 9) 8081 -&gt; 60738 [FIN ACK] Seq=120 Ack=397 Win=30336 Len=0 合并了对客户端的ack确认以及服务端发送的FIN断开信号包。我们点击该包详情如下： 这里红框中体现了，这个9号包是对Frame500的ACK确认，我们根据最开始的截图可以知道，这个包就是8号包 8) 60738 -&gt; 8081 [FIN ACK] Seq=396 Ack=120 Win=66560 Len=0 并且9号包本身自己是发送的FIN信号包，所以，我们可以认为9号包合并了ACK和FIN的内容，所以通常的4次挥手，经过合并后变成了3次挥手。 Keep-Alive答案是：目前的协议是不用的 在HTTP0.9版本和HTTP1.0版本中，每次请求响应都是要三次握手的， 但是HTTP1.0开始尝试持续连接，也就是Keep-Alive参数，但是官方还没有正式支持，在HTTP1.1协议中，官方默认就是支持Keep-Alive参数的，默认是持续连接。Keep-Alive的作用主要有两点： 1.检查死节点 主要是为了让连接快速失败被发现，可以进行重新连接，比如A和B两端已经建立了连接，B节点因为 异常原因挂掉了，同时A节点并不知道，这时候有两种情况： 1.假设B节点还没有恢复，那么B节点不会回复ACK，A节点就会一直重试，重试到一定次数才能知道B节点是死节点。 2.B节点在A发送数据之前重启成功了，这个时候A节点发送数据，B节点并不会接受，而是会发送一个RST信号（在一个已关闭的socket上收到数据时，将发送RST数据包，要求对端关闭异常连接且对端不需要回复ACK）,然后A才知道B节点需要重连了。 以上两种情况，都会导致只有到发送数据的时候才知道对方已经出异常了。而Keep-Alive每隔一段时间就会发送心跳，就可以很快的知道服务端节点的情况。 2.防止连接由于不活跃而断开 我们知道，网络连接的建立和维持是消耗资源的，一个服务器上能建立的连接是有限的，所以像防火墙或者操作系统中会为了节省资源会释放掉不活跃的连接，而Keep-Alive每隔一段时间发送一个心跳包，就是告诉防火墙或者操作系统，我这个连接是活跃的，不要杀我。 后来重新抓了一次带有Keep-Alive的包，截图如下： 在上图中最后两个包就是发的Keep-Alive包，然后服务端进行ACK确认，我们看到keep-alive包，实际上是会发带有一个字节的包，这就是keep-alive的实现。 宏观上的输入网址后发生的事情如果你用的是电脑台式机，那么你可能会使用带水晶头的双绞线连上网口，由交换机接入固定网络。如果你用的是手机、平板电脑，那么你可能会通过蜂窝网络、WiFi，由电信基站、无线热点接入移动网络。 接入网络的同时，网络运行商会给你的设备分配一个 IP 地址，这个地址可能是静态分配的，也可能是动态分配的。静态 IP 就始终不变，而动态 IP 可能你下次上网就变了。 假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP 地址的，在浏览器里只能使用域名“www.apple.com”访问，那么接下来要做的必然是域名解析。这就要用 DNS 协议开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS 的层层解析，当然这中间有缓存，可能不会费太多时间就能拿到结果。 别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。 因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。 由 PHP、Java 等后台服务动态生成的页面属于“动态资源”，CDN 无法缓存，只能从目标网站获取。于是你发出的 HTTP 请求就要开始在互联网上的“漫长跋涉”，经过无数的路由器、网关、代理，最后到达目的地。 目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。 负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。 如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。 应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。 最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://tsunamigg.github.io/tags/http/"}]},{"title":"4.http世界","slug":"http4","date":"2019-06-18T13:32:25.000Z","updated":"2020-06-01T14:36:45.500Z","comments":true,"path":"2019/06/18/http4/","link":"","permalink":"https://tsunamigg.github.io/2019/06/18/http4/","excerpt":"http的运行依赖于下层的TCP/IP，绝不是单打独斗。 长文警告","text":"http的运行依赖于下层的TCP/IP，绝不是单打独斗。 长文警告 知识map http是整个OSI其中的一部分，而不是单打独斗的大侠，与其相关的协议有很多：TCP/IP、DNS、URI、HTTPS 等。我们应该弄清楚他们的联系。 应该了解方方面面我们能够说 我们熟悉某种东西，绝不仅仅是能够将它的概念说清楚，而应该了解它处于整个体系中的位置，以及它的各种应用场景。建立起自己的整个知识结构，而不是零散的知识点。 浏览器浏览器的正式名字叫“Web Browser”，顾名思义，就是检索、查看互联网上网页资源的应用程序。名字里的 Web，实际上指的就是“World Wide Web”，也就是万维网。 浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。当然，为了让我们更好地检索查看网页，它还集成了很多额外的功能。例如，HTML 排版引擎用来展示页面，JavaScript 引擎用来实现动态化效果，甚至还有开发者工具用来调试网页，以及五花八门的各种插件和扩展。 在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。 web服务器Web 服务器是一个很大也很重要的概念，它是 HTTP 协议里响应请求的主体，通常也把控着绝大多数的网络资源，在网络世界里处于强势地位。 当我们谈到“Web 服务器”时有两个层面的含义：硬件和软件。 硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”，各种阿里云，腾讯云… 软件含义的 Web 服务器可能我们更为关心，它就是提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。 比起层出不穷的各种 Web 浏览器，Web 服务器就要少很多了，一只手的手指头就可以数得过来。 Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品 Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选 还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少 CDN全称是“Content Delivery Network”，翻译过来就是“内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。 在http服务的两端，并不是直接连接的，中间的部分的一个重要角色就是CDN。 CDN的好处是：它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。 CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分。 爬虫前面说到过浏览器，它是一种用户代理，代替我们访问互联网。 但 HTTP 协议并没有规定用户代理后面必须是“真正的人类”，它也完全可以是“机器人”，这些“机器人”的正式名称就叫做“爬虫”（Crawler），实际上是一种可以自动访问 Web 资源的应用程序。 “爬虫”这个名字非常形象，它们就像是一只只不知疲倦的、辛勤的蚂蚁，在无边无际的网络上爬来爬去，不停地在网站间奔走，搜集抓取各种信息。 据估计，互联网上至少有 50% 的流量都是由爬虫产生的，某些特定领域的比例还会更高，也就是说，如果你的网站今天的访问量是十万，那么里面至少有五六万是爬虫机器人，而不是真实的用户。 爬虫怎么来的？ 绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。 爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。 Web ServiceWeb Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。 因为采用了 HTTP 协议传输数据，所以在 Web Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。 WAFWAF 是近几年比较“火”的一个词，意思是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。 WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。 TCP/IPTCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。协议的层级关系模型非常重要。 IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。 类比出生取名字一样，名字的很大一个目的，是为了与他人区分开来，IP则是为了标明你在互联网的身份。 可以对比一下现实中的电话系统，你拿着的手机相当于互联网上的计算机，而要打电话就必须接入电话网，由通信公司给你分配一个号码，这个号码就相当于 IP 地址。 现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了 TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。 “可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。 域名域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。 例如： www.time.geekbang.org =&gt; [com]是顶级域名，[geekbang]是二级域名，[time]是主机名，[www]则是万维网。 这样划分的好处是显而易见的, www.time.a.org 与 www.time.b.org；分层使得其称为一个个名字空间系统，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识。 DNS在 TCP/IP 协议中使用 IP 地址来标识计算机，数字形式的地址对于计算机来说是方便了，但人类不好分辨，于是“域名系统”（Domain Name System）出现了，用有意义的名字来作为 IP 地址的等价替代。设想一下，你是愿意记“95.211.80.227”这样枯燥的数字，还是“nginx.org”这样的词组呢？ 域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等，买火车票时的域名还记得吗？是“www.12306.cn”。 很多人在家第一次设置WiFi时，都叫你叫打开198.128.1之类的，也可以访问web，www.baidu.com也可以访问web，why? 这就是域名解析。 HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。 域名解析把域名做一个转换，“映射”到它的真实 IP。域名解析实际很复杂，因为互联网上的电脑实在是太多了。目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。 DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构： 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址； 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址； 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。 例如，你要访问“www.apple.com”，就要进行下面的三次查询： 访问根域名服务器，它会告诉你“com”顶级域名服务器的地址； 访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址； 最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。 全球那么多DNS，这么庞大的体量，还是用“缓存”来提高效率，省略很多不必要的寻址。 第一层，浏览器的缓存 第二层，操作系统缓存 第三层，host缓存 操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，称为host，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\\WINDOWS\\system32\\drivers\\etc\\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。 许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。 结合缓存的寻址过程就是：浏览器DNS缓存-&gt;操作系统缓存-&gt;Hosts文件-&gt;非权威域名服务器-&gt;根域名服务器-&gt;顶级域名服务器-&gt;权威域名服务器 域名解析的这种映射关系，让现在的很多种“骚操作”浮现出来，负载均衡，域名污染，域名屏蔽等等。 毕竟，你是帅哥变为你是A这种变化，有很大的可操作空间呐~ URI/URLURI（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。 URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。 来看看实际的例子： 1http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name URL = 协议(http) + 域名(www.aspxfans.com) + 端口(8080) + 路径(news) + 文件名(index.asp) + 传参(boardID=5&amp;ID=24618&amp;page=1) 其中端口，路径，文件名，传参不是必须部分，如下： 1https://www.baidu.com HTTPS它的全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。 SSL/TLS，它是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。 SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。 SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。 web攻击如果你是一名前端工程师，面试可能会被问到这类问题。稍微说一下经常提及的几种。 1.SQL注入漏洞，通过每种数据库的SQL语法和特性，进行攻击，例如：’or 1=1–’。 2.XSS跨站脚本漏洞攻击，通常是在网页中嵌入客户端脚本，比如js,在留言板上发表带有js内容的文本。 3.CSRF跨站请求伪造，通常表现为攻击者盗用的你身份（浏览器的会话，网上登录银行等），以你的名义进行某些非法操作。 4.URL跳转和钓鱼，一般都是检测URL是否是诈骗的，但是对于开发人员来说，通过URL不同形式的跳转可以避开，其中很多钓鱼也利用了。 5.WebServer远程部署（比如FTP,Tomcat,JBoss），如果远程部署配置不当，攻击者就可以通过远程部署功能入侵服务器。 6.WebShell就是以ASP,PHP,JSP或者CGI等网页文件形式存在的一种命令执行环境，也可以将其称为一种网页后门，黑客在入侵一个网站后，通常会将ASP或者PHP后门文件与网站服务器Web目录下正常文件混在一起，然后就可以使用浏览器登录页面，执行命令，以达到控制网站服务器的目的。 Proxy代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。 代理有很多的种类，常见的有： 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 反向代理：靠近服务器端，代表服务器响应客户端的请求； CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。 中介，也是一种代理，无论你买房，旅游，被他们掌握房源/旅游项目后，他为刀俎，你为鱼肉…. 由于代理在传输过程中插入了一个“中间层”，所以可以在这个环节做很多有意思的事情，比如： 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化； 内容缓存：暂存上下行的数据，减轻后端的压力； 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器； 数据处理：提供压缩、加密等额外的功能。 关于 HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订，但并不是 RFC 标准。 完整网络结构TCP/IP 网络分层模型(四层)TCP/IP 当初的设计者真的是非常聪明，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。 TCP/IP 协议总共有四层： 第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。 第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。 第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。 TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。 TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。。 第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。 MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。 OSI七层 TCP/IP 协议栈的工作方式你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。 假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容: HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。 你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。 接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。 之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。 快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。 这个比喻里省略了很多 TCP/IP 协议里的细节，比如建连、路由、数据切分与重组、错误检查等，但核心的数据传输过程是差不多的。 HTML流动过程： HTML -&gt; HTTP -&gt; TCP -&gt; IP/MAC -&gt; TCP -&gt; HTTP -&gt; HTML 快递员和物流系统过程： 包装 -&gt; -&gt; .. -&gt;传输 -&gt; .. -&gt;拆包装。 HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。 接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。 但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://tsunamigg.github.io/tags/http/"}]},{"title":"3.有必要分清的URIURL","slug":"http3","date":"2019-06-12T10:12:10.000Z","updated":"2020-06-01T14:36:41.871Z","comments":true,"path":"2019/06/12/http3/","link":"","permalink":"https://tsunamigg.github.io/2019/06/12/http3/","excerpt":"是一个很迷惑的点，所以查证后记录于此","text":"是一个很迷惑的点，所以查证后记录于此 URI/URLURI（Uniform Resource Identifier），中文名称是统一资源标识符，使用它就能够唯一地标记互联网上资源。 URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。 但需要注意的是，URI 不仅能够标记万维网的资源，也可以标记其他的，如邮件系统、本地文件系统等任意资源。而“资源”既可以是存在磁盘上的静态文本、页面数据，也可以是由 Java、PHP 提供的动态服务。 例如：windows系统中，你将一个图片拖入浏览器打开，也会得到这个图片的URI。 file:///C:/Users/%E7%94%98%E8%B6%85/Desktop/working/h5/img/bg.png 一个websocket协议的URI ws://newtest/zhouheiya.cn:1010/ URI = scheme + :// + user:passwd@ + host:port + path + query + #fragment URI = 协议 + :// + 身份信息 + 主机名：端口号 + 资源路径 + 查询参数 + 片段标识符 具有安全隐患的user:passwd@ 主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。 fragment 查询参数后的片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。 但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。原因是，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。 例如： 我们在浏览器的地址栏输入：https://www.baidu.com/?wd=1#test 打开浏览器的devtools查看发出的第一个请求的Referer：https://www.baidu.com/?wd=1 ，#test会被完全忽略掉。 是不是联想到了什么？对vue熟悉的都知道vue-router默认使用的是hash路由：localhost:8080/#/xxx fragment实现的单页面路由 JavaScript 提供了 location.hash 来操作当前 URI 的 fragment，同时提供了 Hashchange 事件监听 fragment 的变化。 修改 location.hash 值，触发 hashchange 事件，JS 处理对应的逻辑，改变页面 UI 实现页面的跳转，并在浏览器中产生历史记录。 比如地址栏： https://blog.csdn.net/#/testHash location.hash = “#/testHash” 通过caniuse的查询，hashchange event 目前的兼容性表现较好，主流浏览器都支持。 实现单页面路由还会使用 H5 为 history 新增的两个 API： History.pushState() , Histroy. replaceState ()。 具体代码实现可以参考 vue-router hash 模式下的实现 https://github.com/vuejs/vue-router/blob/dev/src/history/hash.js。 Vue的默认路由方式是hash，如何修改？ 1.实例化规则为“history”模式 const router = new VueRouter({mode: ‘history’,routes // （缩写）相当于 routes: routes}) 2.nginx 相应的配置 location / {try_files uriuriuri/ /index.html;} https://router.vuejs.org/zh/guide/essentials/history-mode.html中介绍了多种后端配置的例子，根据文档配置就好了 然而， fragment 会被 Google 搜索引擎忽略掉，因此对于用 hash 模式前端路由的应用的 SEO 来说是很不友好的。不过 Google 给了一个方案，就是在 # 紧跟一个 ! ，这样Google 搜索引擎就会将这个 URI 进行转换，如 https://domain/index.html#!L18转换后就成为了 https://domain/index.html?_escaped_fragment_=L18。这样搜索引擎就会携带上 URI’s fragment 直接去访问这个 URI，开发者可以利用这个 trick 优化网站的 SEO。 fragment实现的HTML锚点 在 HTML 中比较常见的一个应用 —— 页面内定位。 在页面中通过设置标签的 id 属性来定义锚点，从而实现锚点定位。实际上锚点定位的实现正是依赖了fragment 的特性 3。如这个 URI https://domain/index.html#L18，假设返回的文件类型是 text/html，则浏览器会读取 URI’s fragment，然后在页面中寻找 L18 这个锚点，并将页面滚动到该锚点的位置。 因此我们当点击 &lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;时，实际上处理过程是 URI 的 hash 发生变化，然后浏览器读取新的 fragment，并寻找 DOM 中是否存在对应的锚点，将该锚点显示到页面中。 在 MIME Type 为 HTML 或 XML 时，如https://domain/index.html#这个 URI 中是空的 fragment，则浏览器默认显示页面的最顶端。 这意味着我们可以通过一个&lt;a href=&quot;#&quot;&gt;返回顶部&lt;/a&gt;来简洁实现回到顶部的功能。 URI 对应的资源类型不同，浏览器对该 URI’s fragment 的处理方式就不一样，具体不同类型的处理方式可以参阅：[https://en.wikipedia.org/wiki/Fragment_identifier#Examples] 。 URL = scheme + :// + host + port +path + filename + query + #fragment http： 1http:&#x2F;&#x2F;www.aspxfans.com:8080&#x2F;news&#x2F;index.asp?boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1#name 其中端口，路径，文件名，传参不是必须部分，如下： 1https://www.baidu.com 我们不必刻意去区分 URI / URL / URN 。在 [RFC3986]上已经明确说明这个点： Future specifications and related documentation shoulduse the general term “URI” rather than the more restrictive terms“URL” and “URN”. 服务端与客户端的不同我们在浏览器地址栏输入www.baidu.com，在dev工具中看到request header中，有一个view source，点开后看到的就是发给服务端。仔细对比一下，会发现，协议名和主机名都不见了，只剩下了后面的部分。 这是因为协议名和主机名已经分别出现在了请求行的版本号和请求头的 Host 字段里，没有必要再重复。 我们可以断定的是，客户端和服务器看到的 URI 是不一样的。客户端看到的必须是完整的 URI，使用特定的协议去连接特定的主机，而服务器看到的只是报文请求行里被删除了协议名和主机名的 URI。 在web服务器中，例如配置nginx，它的 location、rewrite 等指令操作的 URI 其实指的是真正 URI 里的 path 和后续的部分，省略掉了path之前的协议名和主机名。 URI的编码在日常的开发中，我们经常会遇到如下的场景： 你找同事要一份资料，同事给你了一个网址：https://www.baidu.com/s?wd=%E4%BA%94%E6%9C%88%E5%A4%A9%E6%BC%94%E5%94%B1%E4%BC%9A&amp;rsv_spt=1。 你可能会马上懵一下，wd=%E4%BA%94%E6%9C%88%E5%A4%A9%E6%BC%94%E5%94%B1%E4%BC%9A。 这是什么鬼东西？你问同事，同事给你截图表明浏览器里面的是正常的中文。 浏览器掩盖了URI“丑陋”的一面，这个丑陋其实涉及编码。 URI引入的编码机制是：ASCII 码 + ASCII 码以外的字符集和特殊字符做转义。 URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。 现在多用：encodeURI其原理是把字符（unicode）编码成utf-8，utf-8是用1-4个字节表示的，所以每个字节转换成16进制并在前面用百分号（%）连接，最后并把每个字节转换的结果连接起来。","categories":[],"tags":[{"name":"http URI/URL","slug":"http-URI-URL","permalink":"https://tsunamigg.github.io/tags/http-URI-URL/"}]},{"title":"2.http是什么？","slug":"http2","date":"2019-06-06T09:42:10.000Z","updated":"2020-06-01T14:36:38.877Z","comments":true,"path":"2019/06/06/http2/","link":"","permalink":"https://tsunamigg.github.io/2019/06/06/http2/","excerpt":"http是什么？ 如何准确的一句话描述","text":"http是什么？ 如何准确的一句话描述 Http是什么？如果你是在面试，碰到这种问题，千万别用一句话回答：超文本传输协议。 把它拆解成有所属关系的三个词： 协议，传输协议，超文本传输协议。 协议你的人生应该是充满协议的，三方协议，租房协议等等…. 一般协议中都会有甲方乙方丙方等等。 我们为了达成某种目的，强制性的约束参与协议的各方，遵守协议的条款，违约了就会有相应的处罚。 广泛的来看，计算机中的协议则是指的是： 人与机或者机与机进行交互的规范。 http协议是使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 传输协议大多数人想到的就是A与B之间的传输，并且分为请求方与响应方。 如果从“A&lt;===&gt;B”，变成了“A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B” ？？？ 很多场景都是需要这样的中间人。 A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。 HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范，并不是计算机A和计算机B。 超文本传输协议“文本”，在协议中，是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理，而不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram）。 “超文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。 我们最熟悉的超文本就应该是 HTML 了，它本身只是纯文字文件，但内部用很多标签定义了对图片、音频、视频等的链接，再经过浏览器的解释，呈现在我们面前的就是一个含有多种视听信息的页面。 非要一句话？HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范、 HTTP 不是一个孤立的协议。俗话说“一个好汉三个帮”，HTTP 也是如此。在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。 知识map","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://tsunamigg.github.io/tags/http/"}]},{"title":"1.开始http之路","slug":"http1","date":"2019-06-01T14:12:42.000Z","updated":"2020-06-01T14:36:36.554Z","comments":true,"path":"2019/06/01/http1/","link":"","permalink":"https://tsunamigg.github.io/2019/06/01/http1/","excerpt":"http学习笔记开篇","text":"http学习笔记开篇 http前世今生1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。 URI：即统一资源标识符，作为互联网上资源的唯一身份； HTML：即超文本标记语言，描述超文本文档； HTTP：即超文本传输协议，用来传输超文本。 这三项技术在如今的我们看来已经是稀松平常，但在当时却是了不得的大发明。基于它们，就可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息，蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。 http/0.9这一时期的 HTTP 被定义为 0.9 版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯 - 李最初设想的系统里的文档都是只读的，所以只允许用“GET”动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接，功能非常有限。 HTTP/0.9 虽然很简单，但它作为一个“原型”，充分验证了 Web 服务的可行性，而“简单”也正是它的优点，蕴含了进化和扩展的可能性。 http/1.0于1996年正式发布，对0.9进行了加强，加强方面如下： 增加了 HEAD、POST 等新方法； 增加了响应状态码，标记可能的错误原因； 引入了协议版本号概念； 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活； 传输的数据不再仅限于文本 由于“浏览器大战”，这次的更新更像是一份备忘录，而不是标准，并没有引起web世界的激荡。 http/1.1在“浏览器大战”结束之后的 1999 年，HTTP/1.1 发布了 RFC 文档，编号为 2616，正式确立了延续十余年的传奇。修订如下： 增加了 PUT、DELETE 等新的方法； 增加了缓存管理和控制； 明确了连接管理，允许持久连接； 允许响应数据分块（chunked），利于传输大文件； 强制要求 Host 头，让互联网主机托管成为可能。 1.1是一个正式的标准，是血缘正统的下一代，互联网在它的“保驾护航”下迈开了大步，由此走上了“康庄大道”，开启了后续的“Web 1.0”“Web 2.0”时代。现在许多的知名网站都是在这个时间点左右创立的，例如 Google、新浪、搜狐、网易、腾讯等 不过由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动 http/2经过近10年的爆炸式增长后，1.1已经无法满足现代需求(主要是慢)。于是Google揭竿而起，用自家全球占有率60%的Chrome，顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。 HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有： 二进制协议，不再是纯文本； 可发起多个请求，废弃了 1.1 里的管道； 使用专用算法压缩头部，减少数据传输量； 允许服务器主动向客户端推送数据； 增强了安全性，“事实上”要求加密通信 虽然2诞生了已4年，但现今普及率还很低，基本都还是20年之前的1.1，可见1.1之经典与强大！ http/3在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。 在 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。 Http是什么？如果你是在面试，碰到这种问题，千万别用一句话回答：超文本传输协议。 把它拆解成有所属关系的三个词： 协议，传输协议，超文本传输协议。 协议你的人生应该是充满协议的，三方协议，租房协议等等…. 一般协议中都会有甲方乙方丙方等等。 我们为了达成某种目的，强制性的约束参与协议的各方，遵守协议的条款，违约了就会有相应的处罚。 广泛的来看，计算机中的协议则是指的是： 人与机或者机与机进行交互的规范。 http协议是使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 传输协议大多数人想到的就是A与B之间的传输，并且分为请求方与响应方。 如果从“A&lt;===&gt;B”，变成了“A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B” ？？？ 很多场景都是需要这样的中间人。 A 到 B 的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。 HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范，并不是计算机A和计算机B。 超文本传输协议“文本”，在协议中，是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理，而不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram）。 “超文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。 我们最熟悉的超文本就应该是 HTML 了，它本身只是纯文字文件，但内部用很多标签定义了对图片、音频、视频等的链接，再经过浏览器的解释，呈现在我们面前的就是一个含有多种视听信息的页面。 非要一句话？HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范、 HTTP 不是一个孤立的协议。俗话说“一个好汉三个帮”，HTTP 也是如此。在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。 知识map","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://tsunamigg.github.io/tags/http/"}]},{"title":"ESmodule","slug":"ESmodule","date":"2019-05-28T12:07:12.000Z","updated":"2020-05-28T14:21:05.901Z","comments":true,"path":"2019/05/28/ESmodule/","link":"","permalink":"https://tsunamigg.github.io/2019/05/28/ESmodule/","excerpt":"ESmodule的标准化完成一定会掀起波澜~","text":"ESmodule的标准化完成一定会掀起波澜~ 图说 ES Modules（转载译文）原文：ES modules: A cartoon deep-dive, Lin Clark ES modules（ESM） 是 JavaScript 官方的标准化模块系统。然而，它在标准化的道路上已经花费了近 10 年的时间。 可喜的是，标准化之路马上就要完成了。等到 2018 年 5 月 Firefox 60 发布之后，所有的主流浏览器就都支持 ESM 了。同时，Node 模块工作小组也正在为 Node.js 添加 ESM 支持。为 WebAssembly 提供 ESM 集成的工作也正在如火如荼的进行。 许多 JS 开发者都知道，对 ESM 的讨论从开始至今一直都没停过。但是很少有人真正理解 ESM 的工作原理。 今天，让我们来梳理梳理 ESM 到底解决了什么问题，以及它跟其他模块系统之间有什么区别。 为何要模块化说到 JS 编程，其实说的就是如何管理变量。编程的过程都是关于如何给变量赋值，要么直接赋值给变量，要么是把两个变量结合起来然后再把结果赋值给另一个变量 因为大部分代码都是关于改变变量的，所以如何组织这些变量就直接影响了编码质量，以及维护它们的成本。 如果代码中仅有少量的变量，那么组织起来其实是很简单的。JS 本身就提供了一种方式帮你组织变量，称为函数作用域。因为函数作用域的缘故，一个函数无法访问另一个函数中定义的变量。 这种方式是很有效的。它使得我们在写一个函数的时候，只需要考虑当前函数，而不必担心其它函数可能会改变当前函数的变量。不过，它也有不好的地方。它会让我们很难在不同函数之间共享变量。 如果我们想跟当前函数以外的函数共享变量要怎么办呢？一种通用的做法是把要共享的变量提升到上一层作用域，比如全局作用域。 在 jQuery 时代这种提升做法相当普遍。在我们加载任何 jQuery 插件之前，我们必须确保 jQuery 已经存在于全局作用域。 这种做法也确实行之有效，但是也带来了令人烦恼的影响。首先，所有的 &lt;script&gt; 必须以正确的顺序排列，开发者必须非常谨慎地确保没有任何一个脚本排列错误。 如果排列错了，那么在运行过程中，应用将会抛出错误。当函数在全局作用域寻找 jQuery 变量时，如果没有找到，那么它将会抛出异常错误，并且停止继续运行。 这同时也使得代码的后期维护变得困难。它会使得移除旧代码或者脚本标签变得充满不确定性。你根本不知道移除它会带来什么影响。代码之间的依赖是不透明的。任何函数都可能依赖全局作用域中的任何变量，以至于你也不知道哪个函数依赖哪个脚本。 其次，由于变量存在于全局作用域，所以任何代码都可以改变它。恶意的代码可能会故意改变全局变量，从而让你的代码做出危险行为。又或者，代码可能不是恶意的，但是却无意地改变了你期望的变量。、 模块化的作用模块化为你提供了一种更好的方式来组织变量和函数。你可以把相关的变量和函数放在一起组成一个模块。 这种组织方式会把函数和变量放在模块作用域中。模块中的函数可以通过模块作用域来共享变量。 不过，与函数作用域不同的是，模块作用域还提供了一种暴露变量给其他模块使用的方式。模块可以明确地指定哪些变量、类或函数对外暴露。 对外暴露的过程称为导出。一旦导出，其他模块就可以明确地声称它们依赖这些导出的变量、类或者函数。 因为这是一种明确的关系，所以你可以很简单地辨别哪些代码能移除，哪些不能移除。 拥有了在模块之间导出和导入变量的能力之后，你就可以把代码分割成更小的、可以独立运行地代码块了。然后，你就可以像搭乐高积木一样，基于这些代码块，创建所有不同类型的应用。 由于模块化是非常有用的，所以历史上曾经多次尝试为 JS 添加模块化的功能。不过截止到目前，真正得到广泛使用的只有两个模块系统。一个是 Node.js 使用的 CommonJS （CJS）；另一个是 JS 规范的新模块系统 EcmaScript modules（ESM），Node.js 也正在添加对 ESM 的支持。 下面就让我们来深入理解下这个新的模块系统是如何工作的。 ESM 原理当你在使用模块进行开发时，其实是在构建一张依赖关系图。不同模块之间的连线就代表了代码中的导入语句。 正是这些导入语句告诉浏览器或者 Node 该去加载哪些代码。我们要做的是为依赖关系图指定一个入口文件。从这个入口文件开始，浏览器或者 Node 就会顺着导入语句找出所依赖的其他代码文件。 但是呢，浏览器并不能直接使用这些代码文件。它需要解析所有的文件，并把它们变成一种称为模块记录（Module Record）的数据结构。只有这样，它才知道代码文件中到底发生了什么。 解析之后，还需要把模块记录变成一个模块实例。模块实例会把代码和状态结合起来。 所谓代码，基本上是一组指令集合。它就像是制作某样东西的配方，指导你该如何制作。但是它本身并不能让你完成制作。你还需要一些原料，这样才可以按照这些指令完成制作。 所谓状态，它就是原料。具体点，状态是变量在任何时候的真实值。当然，变量实际上就是内存地址的别名，内存才是正在存储值的地方。 所以，可以看出，模块实例中代码和状态的结合，就是指令集和变量值的结合。 对于模块而言，我们真正需要的是模块实例。模块加载会从入口文件开始，最终生成完整的模块实例关系图。 对于 ESM ，这个过程包含三个阶段： 构建：查找，下载，然后把所有文件解析成模块记录。 实例化：为所有模块分配内存空间（此刻还没有填充值），然后依照导出、导入语句把模块指向对应的内存地址。这个过程称为链接（Linking）。 运行：运行代码，从而把内存空间填充为真实值。 大家都说 ESM 是异步的。因为它把整个过程分为了三个不同的阶段：加载、实例化和运行，并且这三个阶段是可以独立进行的。 这意味着，ESM 规范确实引入了一种异步方式，且这种异步方式在 CJS 中是没有的。后面我们会详细说到为什么，然而在 CJS 中，一个模块及其依赖的加载、实例化和运行是一起顺序执行的，中间没有任何间断。 不过，这三个阶段本身是没必要异步化。它们可以同步执行，这取决于它是由谁来加载的。因为 ESM 标准并没有明确规范所有相关内容。实际上，这些工作分为两部分，并且分别是由不同的标准所规范的。 其中，ESM 标准 规范了如何把文件解析为模块记录，如何实例化和如何运行模块。但是它没有规范如何获取文件。 文件是由加载器来提取的，而加载器由另一个不同的标准所规范。对于浏览器来说，这个标准就是 HTML。但是你还可以根据所使用的平台使用不同的加载器。 加载器也同时控制着如何加载模块。它会调用 ESM 的方法，包括 ParseModule、Module.Instantiate 和 Module.Evaluate 。它就像是控制着 JS 引擎的木偶。 下面我们将更加详细地说明每一步。 构建对于每个模块，在构建阶段会做三个处理： 确定要从哪里下载包含该模块的文件，也称为模块定位（Module Resolution） 提取文件，通过从 URL 下载或者从文件系统加载 解析文件为模块记录 1.下载模块加载器负责定位文件并且提取。首先，它需要找到入口文件。在 HTML 中，你可以通过 &lt;script&gt; 标签来告诉加载器。 但是，加载器要如何定位 main.js 直接依赖的模块呢？这个时候导入语句就派上用场了。导入语句中有一部分称为模块定位符（Module Specifier），它会告诉加载器去哪定位模块。 对于模块定位符，有一点要注意的是：它们在浏览器和 Node 中会有不同的处理。每个平台都有自己的一套方式来解析模块定位符。这些方式称为模块定位算法，不同的平台会使用不同的模块定位算法。当前，一些在 Node 中能工作模块定位符并不能在浏览器中工作，但是已经有一项工作正在解决这个问题。 在这个问题被解决之前，浏览器只接受 URL 作为模块定位符。它们会从 URL 加载模块文件。但是，这并不是在整个关系图上同时发生的。因为在解析完这个模块之前，你根本不知道它依赖哪些模块。而且在它下载完成之前，你也无法解析它。 这就意味着，我们必须一层层遍历依赖树，先解析文件，然后找出依赖，最后又定位并加载这些依赖，如此往复。 如果主线程正在等待这些模块文件下载完成，许多其他任务将会堆积在任务队列中，造成阻塞。这是因为在浏览器中，下载会耗费大量的时间。 而阻塞主线程会使得应用变得卡顿，影响用户体验。这是 ESM 标准把算法分成多个阶段的原因之一。将构建划分为一个独立阶段后，浏览器可以在进入同步的实例化过程之前下载文件然后理解模块关系图。 ESM 和 CJS 之间最主要的区别之一就是，ESM 把算法化为为多个阶段。 CJS 使用不同的算法是因为它从文件系统加载文件，这耗费的时间远远小于从网络上下载。因此 Node 在加载文件的时候可以阻塞主线程，而不造成太大影响。而且既然文件已经加载完成了，那么它就可以直接进行实例化和运行。所以在 CJS 中实例化和运行并不是两个相互独立的阶段。这也意味着，你可以在返回模块实例之前，顺着整颗依赖树去逐一加载、实例化和运行每一个依赖。 CJS 的方式对 ESM 也有一些启发，这个后面会解释。其中一个就是，在 Node 的 CJS 中，你可以在模块定位符中使用变量。因为已经执行了 require 之前的代码，所以模块定位符中的变量此刻是有值的，这样就可以进行模块定位的处理了。 但是对于 ESM，在运行任何代码之前，你首先需要建立整个模块依赖的关系图。也就是说，建立关系图时变量是还没有值的，因为代码都还没运行。 不过呢，有时候我们确实需要在模块定位符中使用变量。比如，你可能需要根据当前的状况加载不同的依赖。 为了在 ESM 中实现这种方式，人们已经提出了一个动态导入提案。该提案允许你可以使用类似 import(\\${path}/foo.js)的导入语句。 这种方式实际上是把使用 import() 加载的文件当成了一个入口文件。动态导入的模块会开启一个全新的独立依赖关系树。 不过有一点要注意的是，这两棵依赖关系树共有的模块会共享同一个模块实例。这是因为加载器会缓存模块实例。在特定的全局作用域中，每个模块只会有一个与之对应的模块实例。 这种方式有助于提高 JS 引擎的性能。例如，一个模块文件只会被下载一次，即使有多个模块依赖它。这也是缓存模块的原因之一，后面说到运行的时候会介绍另一个原因。 加载器使用模块映射（Module Map）来管理缓存。每个全局作用域都在一个单独的模块映射中跟踪其模块。 当加载器要从一个 URL 加载文件时，它会把 URL 记录到模块映射中，并把它标记为正在下载的文件。然后它会发出这个文件请求并继续开始获取下一个文件。 当其他模块也依赖这个文件的时候会发生什么呢？加载器会查找模块映射中的每一个 URL 。如果发现 URL 的状态为正在下载，则会跳过该 URL ，然后开始下一个依赖的处理。 不过，模块映射的作用并不仅仅是记录哪些文件已经下载。下面我们将会看到，模块映射也可以作为模块的缓存。 2.解析模块至此，我们已经拿到了模块文件，我们需要把它解析为模块记录。这有助于浏览器理解模块的不同部分。 一旦模块记录创建完成，它就会被记录在模块映射中。所以，后续任何时候再次请求这个模块时，加载器就可以直接从模块映射中获取该模块。 解析过程中有一个看似微不足道的细节，但是实际造成的影响却很大。那就是所有的模块都按照严格模式来解析的。也还有其他的小细节，比如，关键字 await 在模块的最顶层是保留字， this 的值为 undefinded。 这种不同的解析方式称为解析目标（Parse Goal）。如果按照不同的解析目标来解析相同的文件，会得到不同的结果。因此，在解析文件之前，必须清楚地知道所解析的文件类型是什么，不管它是不是一个模块文件。 在浏览器中，知道文件类型是很简单的。只需要在 &lt;script&gt; 脚本中添加 type=&quot;module&quot; 属性即可。这告诉浏览器这个文件需要被解析为一个模块。而且，因为只有模块才能被导入，所以浏览器以此推测所有的导入也都是模块文件。 不过在 Node 中，我们并不使用 HTML 标签，所以也没办法通过 type 属性来辨别。社区提出一种解决办法是使用 .mjs 拓展名。使用该拓展名会告诉 Node 说“这是个模块文件”。你会看到大家正在讨论把这个作为解析目标。不过讨论仍在继续，所以目前仍不明确 Node 社区最终会采用哪种方式。 无论最终使用哪种方式，加载器都会决定是否把一个文件作为模块来解析。如果是模块，而且包含导入语句，那它会重新开始处理直至所有的文件都已提取和解析。 到这里，构建阶段差不多就完成了。在加载过程处理完成后，你已经从最开始只有一个入口文件，到现在得到了一堆模块记录。 下一步会实例化这些模块并且把所有的实例链接起来。 实例化正如前文所述，一个模块实例结合了代码和状态。状态存储在内存中，所以实例化的过程就是把所有值写入内存的过程。 首先，JS 引擎会创建一个模块环境记录（Module Environment Record）。它管理着模块记录的所有变量。然后，引擎会找出多有导出在内存中的地址。模块环境记录会跟踪每个导出对应于哪个内存地址。 这些内存地址此时还没有值，只有等到运行后它们才会被填充上实际值。有一点要注意，所有导出的函数声明都在这个阶段初始化，这会使得后面的运行阶段变得更加简单。 为了实例化模块关系图，引擎会采用深度优先的后序遍历方式。即，它会顺着关系图到达最底端没有任何依赖的模块，然后设置它们的导出。 最终，引擎会把模块下的所有依赖导出链接到当前模块。然后回到上一层把模块的导入链接起来。 这个过程跟 CJS 是不同的。在 CJS 中，整个导出对象在导出时都是值拷贝。即，所有的导出值都是拷贝值，而不是引用。所以，如果导出模块内导出的值改变了，导入模块中导入的值也不会改变。 相反，ESM 则使用称为实时绑定（Live Binding）的方式。导出和导入的模块都指向相同的内存地址（即值引用）。所以，当导出模块内导出的值改变后，导入模块中的值也实时改变了。 模块导出的值在任何时候都可以能发生改变，但是导入模块却不能改变它所导入的值，因为它是只读的。举例来说，如果一个模块导入了一个对象，那么它只能改变该对象的属性，而不能改变对象本身。 ESM 采用这种实时绑定的原因是，引擎可以在不运行任何模块代码的情况下完成链接。后面会解释到，这对解决运行阶段的循环依赖问题也是有帮助的。 实例化阶段完成后，我们得到了所有模块实例，以及已完成链接的导入、导出值。 现在我们可以开始运行代码并且往内存空间内填充值了。 运行最后一步是往已申请好的内存空间中填入真实值。JS 引擎通过运行顶层代码（函数外的代码）来完成填充。 除了填充值以外，运行代码也会引发一些副作用（Side Effect）。例如，一个模块可能会向服务器发起请求。 因为这些潜在副作用的存在，所以模块代码只能运行一次。前面我们看到，实例化阶段中发生的链接可以多次进行，并且每次的结果都一样。但是，如果运行阶段进行多次的话，则可能会每次都得到不一样的结果。 这正是为什么会使用模块映射的原因之一。模块映射会以 URL 为索引来缓存模块，以确保每个模块只有一个模块记录。这保证了每个模块只会运行一次。跟实例化一样，运行阶段也采用深度优先的后序遍历方式。 那对于前面谈到的循环依赖会怎么处理呢？ 循环依赖会使得依赖关系图中出现一个依赖环，即你依赖我，我也依赖你。通常来说，这个环会非常大。不过，为了解释好这个问题，这里我们举例一个简单的循环依赖。 counter 模块会试图去访问导出对象的 message 。不过，由于 main 模块中还没运行到 message 处，所以此时得到的 message 为 undefined。JS 引擎会为本地变量分配空间并把值设为 undefined 。 运行阶段继续往下执行，直到 counter 模块顶层代码的末尾处。我们想知道，当 counter 模块运行结束后，message 是否会得到真实值，所以我们设置了一个超时定时器。之后运行阶段便返回到 main.js 中。 这时，message 将会被初始化并添加到内存中。但是这个 message 与 counter 模块中的 message 之间并没有任何关联关系，所以 counter 模块中的 message 仍然为 undefined。 如果导出值采用的是实时绑定方式，那么 counter 模块最终会得到真实的 message 值。当超时定时器开始计时时，main.js 的运行就已经完成并设置了 message 值。 支持循环依赖是 ESM 设计之初就考虑到的一大原因。也正是这种分段设计使其成为可能。 ESM 的当前状态等到 2018 年 5 月 Firefox 60 发布后，所有的主流浏览器就都默认支持 ESM 了。Node 也正在添加 ESM 支持，为此还成立了工作小组来专门研究 CJS 和 ESM 之间的兼容性问题。 所以，在未来你可以直接在 &lt;script&gt; 标签中使用 type=&quot;module&quot;，并且在代码中使用 import 和 export 。同时，更多的模块功能也正在研究中。比如动态导入提案已经处于 Stage 3 状态；import.meta也被提出以便 Node.js 对 ESM 的支持；模块定位提案 也致力于解决浏览器和 Node.js 之间的差异。 相信在不久的未来，跟模块一起玩耍将会变成一件更加愉快的事！","categories":[],"tags":[{"name":"ESmodule","slug":"ESmodule","permalink":"https://tsunamigg.github.io/tags/ESmodule/"}]},{"title":"Event loop","slug":"Event loop","date":"2019-05-19T11:25:19.000Z","updated":"2020-05-23T14:52:52.835Z","comments":true,"path":"2019/05/19/Event loop/","link":"","permalink":"https://tsunamigg.github.io/2019/05/19/Event%20loop/","excerpt":"Event loop的粗浅认识","text":"Event loop的粗浅认识 事件轮询js是单线程的。其事件轮询由：同步任务，异步任务，macrotask（宏任务），microtask （微任务）组成。其执行过程如下： 同步任务： 主线程上的任务，前一个完成后后一个执行。 异步任务：不进入主线程，进入任务队列（task queue)中执行，等于macrotask。 macrotask：任务队列的主体，同一个队列内的“先进先出”执行。不同的队列之间“先进后出”执行。 microtask ：总在任务队列末尾执行，有新的microtask 继续加在末尾执行。 执行过程：1.同步任务执行 2. 任务按队列依次执行 3.微任务按队列依次执行 4.重复1-3 宏任务和微任务对于宏任务和微任务的概念的理解，一开始确实是不太清楚的。 先来说说宏任务，我们不妨这样来看，既然它是任务队列的主体，那么它一定由一个或者多个任务构成。抛开JS,[宏]这个字本身就不是单一的，在CS中的[宏]就是批量处理的意思。 对于稍微了解过一点点c的人来说，应该都不陌生，辟如：编译预处理命令，宏定义等等。 1234// 编译预处理命令#include&lt;stdio.h&gt;// 宏定义#define PI 3.14 我将[编译预处理命令]（在编译之前进行的处理）就看做是[宏任务]，就是你写了一系列的前置操作，在后面的代码执行之前，这些宏任务全部需要执行完毕~ 稍微生活化一点点，比如那个中国互联网起步的时候，我的同学之间，喜欢用QQ等级作为谈资。所以我让我的电脑开机后自动登录QQ；或者现今5G来临之前，男生多半玩过的MOBA类游戏，就拿LOL中的瞎子摸眼R闪这种操作，你完全可以选一个拥有宏命令的鼠标，设置测试后一键完成这种“用双手成就你的梦想”等秀的飞起的操作；还有诸如乔碧萝之类的人士，开启直播推流之前，对自己直播效果的优化。这些都是所谓宏任务。 至于微任务，相信聪明可爱的你一定能够举一反一，找到自己对其充分的理解~:smile: 常见的宏任务和微任务： 宏任务： setTimeout setInterval setImmediate requestAnimationFrame I/O UI rendering 微任务： process.nextTick Promises Object.observe MutationObserver 执行图例 希望执行帧动画能让你对整个过程的理解清晰许多 小练习11234567891011121314151617181920console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// 浏览器输出顺序：//script start//script end//promise1//promise2//setTimeout 小练习21234567891011121314151617181920212223242526272829async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout') &#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end')// 浏览器输出顺序：// script start//async1 start//async2//promise1//script end//async1 end//promise2//setTimeout await会将之后的代码抛入下一个执行队列，代码上的表现就是执行完await的会跳出函数体执行其他的同步任务。 setTimeout的回调函数会进入下一个同步任务队列中。 如果输出顺序不一致，是因为各大浏览器对异步的处理是不一样的，没什么奇怪的。 另外，node环境输出顺序也有很大差异。","categories":[],"tags":[{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"}]},{"title":"css tips","slug":"CSS-tips","date":"2019-04-11T05:14:16.000Z","updated":"2020-05-28T14:21:55.087Z","comments":true,"path":"2019/04/11/CSS-tips/","link":"","permalink":"https://tsunamigg.github.io/2019/04/11/CSS-tips/","excerpt":"如何进行命名是一件看上去微不足道但其实对代码整洁度破坏很大的事情，《代码整洁之道》建议的第一篇就是如何进行好的命名","text":"如何进行命名是一件看上去微不足道但其实对代码整洁度破坏很大的事情，《代码整洁之道》建议的第一篇就是如何进行好的命名 css杂项(命名，书写顺序，调试) BEMBEM是模块（Block）、元素（Element）、修饰符（Modifier）的简写。 BEM 是一种组件架构的命名方法，它的基本思想是将Html元素划分成独立的组件，然后用简单的规则链接起来，开发时不用担心不会取名字了，同时后期维护和多人协作上好处大大的。 其命名规则如下： 123Block - 模块，名字的单词之间用 &#96;-&#96; 符号连接Element - 元素，模块中的子元素，用 &#96;__&#96; 符号连接Modifier - 修饰符，表示父元素或子元素的其他形态，用 &#96;--&#96; 符号连接 优势 在没用 BEM 之前，我们可能会这样组织 CSS 类名： 12345678&lt;!-- Common命名的 Search Bar 模块 --&gt; &lt;div class=\"search-bar\"&gt; &lt;input class=\"input\"&gt; &lt;!-- / input 输入框 --&gt; &lt;button class=\"btn\"&gt; &lt;!-- / button 搜索按钮 --&gt; &lt;/div&gt; &lt;!-- E Search Bar 模块 --&gt; 用 BEM 命名重写之后： 12345678&lt;!-- BEM命名的 Search Bar 模块 --&gt; &lt;div class=\"search-bar\"&gt; &lt;input class=\"search-form__input\"/&gt; &lt;!-- / input 输入框子元素 --&gt; &lt;button class=\"search-form__button\"&gt;&lt;/button&gt; &lt;!-- / button 搜索按钮子元素 --&gt; &lt;/div&gt; &lt;!-- E Search Bar 模块 --&gt; 有对比高下立判~ 通常面试问的语义化(作用与实践)，这样就达到了，最终目的是减少代码阅读成本。 缺陷 优点也是缺点，当HTML元素层级繁多时，会使得命名越来越长，那样的话，文件会变得臃肿不堪，反而违背了我们的初心。乱七八糟的HTML谁会愿意看？ 姓氏命名法为了进一步简化 CSS 的命名，采用凹凸实验室团队推广的姓氏命名法。 感谢凹凸大大们~ 我们并不需要把每个元素的全部名称带上来表明主次关系。就像这份族谱一样，他的孩子只需要保留「贾」姓就可以了，名字是可以随便取的。 关联上 BEM 命名方法，姓氏命名法中的 Block 就是「姓」，Element 就是「名字」，而 Modifier 就表示这个人的某种状态，例如：「范 - - 冰冰 - - 很美」。这样就达到了取其精华，去其糟粕的作用。 1234567891011&lt;!-- am = app_market --&gt; &lt;div class=\"am_answer\"&gt; &lt;div class=\"am_secheader\"&gt;&lt;/div&gt; &lt;div class=\"am_answer_list\"&gt; &lt;div class=\"am_answer_item\"&gt; &lt;div class=\"am_answer_itop\"&gt;&lt;/div&gt; &lt;div class=\"am_answer_imid\"&gt;&lt;/div&gt; &lt;a href=\"javascript:;\" class=\"am_answer_ibtn\"&gt;去围观&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 将 app_market 可以看成是「复姓」，将两个单词的首字母结合在一起形成一个新的「单姓」，如 am ；将item中的子项类名直接简写为「ixx」，如：itop。追求便利的副作用之一是牺牲了一点代码的可读性。但多半项目上的文档可以注明命名方法和其他书写规范，如果团队有约束，那一定是极佳的实践。 小结 ClassName 的命名应该尽量精短、明确，以英文单词命名，且全部字母为小写，避免意义不明的缩写 单词之间统一使用下划线 _ 或 - 连接 定义样式模块，提高代码的可复用性 CSS推荐书写 推荐书写顺序 位置属性(position, top, right, z-index, display, float等) 大小(width, height, padding, margin) 文字系列(font, line-height, letter-spacing, color- text-align等) 背景(background, border等) 其他(animation, transition等) why this ? 主要从浏览器的渲染机制方面来考虑，减少重绘与重排,提高性能。 良好的习惯会使得你编写css代码时也更加清晰 拿到文件后浏览器的渲染流程为： （1）浏览器解析html构建dom树，解析css构建cssom树即css rule tree：将html和css都解析成树形的数据结构； dom树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 （2）构建render树：DOM树和cssom树合并之后形成render树。为了构建渲染树，浏览器大体完成了下列工作：从DOM树的根节点开始遍历每个可见节点。对于每个可见节点，为其找到适配的CSSOM规则并应用它们。发射可见节点，连同其内容和计算的样式。渲染树中包含了屏幕上所有可见内容及其样式信息。 （3）布局render树：有了render树，浏览器已经知道网页中有哪些节点，各个节点的css定义以及它们的从属关系，接着就开始布局，计算出每个节点在屏幕中的位置和大小。(html采用了一种流式布局的布局模型，从上到下，从左到右顺序布局，布局的起点是从render树的根节点开始的，对应dom树的document节点，其初始位置为(0,0)，详细的布局过程为：每个renderer的宽度由父节点的renderer确定。父节点遍历子节点，确定子节点的位置(x,y)，调用子节点的layout方法确定其高度，父节点根据子节点的height, margin, padding确定自身的高度)。 （4）渲染render树：浏览器已经知道啦哪些节点要显示，每个节点的css属性是什么，每个节点在屏幕中的位置是哪里。就进入啦最后一步，按照计算出来的规则，通过显卡把内容画在屏幕上。 DOM 的变化影响了元素的几何属性（宽和高）- 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）” 好了好了，照本宣科的东西终于没了，当然渲染过程没这么简单，这里也是借鉴一下啦。 1234width: 100px; height: 100px; background-color: red; position: absolute; 当浏览器解析到position的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，解除该元素在文档中所占位置，然而由于该元素的占位发生变化，其他元素也可能会受到回流的影响而重新排位，最终导致（3）步骤花费时间太久而影响 。 CSS便捷调试法 控制台输入神秘代码 12345678// 1javascript: var _q = !_q;document.querySelectorAll('*').forEach(q =&gt; q.style.outline = _q ? '1px solid red' : '')// 2$$('*').forEach(a=&gt;&#123;a.style.outline='1px solid red'&#125;)// 3xxxxxxxxx 插件： Keylines ( 一键+彩色线条 ) 优雅的xss 打开书签管理页 右上角三个点「添加新书签」 名称随意，粘贴以下代码到网址中 1234567891011121314151617javascript: (function() &#123; var elements = document.body.getElementsByTagName('*'); var items = []; for (var i = 0; i &lt; elements.length; i++) &#123; if (elements[i].innerHTML.indexOf('html * &#123; outline: 1px solid red &#125;') != -1) &#123; items.push(elements[i]); &#125; &#125; if (items.length &gt; 0) &#123; for (var i = 0; i &lt; items.length; i++) &#123; items[i].innerHTML = ''; &#125; &#125; else &#123; document.body.innerHTML += '&lt;style&gt;html * &#123; outline: 1px solid red &#125;&lt;/style&gt;'; &#125;&#125;)(); 然后我们就可以在任意网站上点击刚才创建的书签，内部会判断是否存在调试的 style。存在的话就删除，不存在的话就添加，通过这种方式我们就能很方便的通过这个技巧查看任意网页的布局了。 效果如下： reference： 浏览器渲染过程与性能优化： https://juejin.im/post/59d489156fb9a00a571d6509 ， CSS书写顺序 ：https://www.cnblogs.com/xuepei/p/8961809.html ， auto实验室 https://aotu.io/","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://tsunamigg.github.io/tags/css/"}]},{"title":"闭包详解","slug":"closure","date":"2019-02-12T02:10:01.000Z","updated":"2020-05-28T14:28:00.239Z","comments":true,"path":"2019/02/12/closure/","link":"","permalink":"https://tsunamigg.github.io/2019/02/12/closure/","excerpt":"结合《你不知道的JavaScript(上)》一书，详解闭包，理清关于闭包的三个问题，彻底认识闭包。","text":"结合《你不知道的JavaScript(上)》一书，详解闭包，理清关于闭包的三个问题，彻底认识闭包。 闭包详解1. 什么是闭包？ 闭包的定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 12345678910function foo() &#123; var a = 3; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz();-----&gt; '3' 这是一段非常经典的闭包代码，根据网上的说法，闭包的产生有三个条件：1. A函数内返回B函数。2.B函数调用了A函数的变量。3.B()。 很神奇有没有？ 我们在外部环境访问了内部环境的变量。并且正常执行了foo的作用域会被销毁掉，垃圾回收机制也会使的释放掉内存空间。显然闭包阻止了这件事情的发生。 2.闭包产生的条件？由于bar声明的位置，使其拥有涵盖了foo的内部作用域，当bar被调用后，会保持对foo作用域的引用，访问a变量。保持对外部作用域的引用，就会产生闭包，而不是非要返回函数。 123456function waiting(msg) &#123; setTimeout(function () &#123; console.log(msg) &#125;, 1000)&#125;waiting('js') 无论是什么其他的骚操作，只要你将内部函数传递到所在的词法作用域之外，他都会保持对内部作用域的引用，无论在哪里执行内部函数，都会创建闭包。这个例子中setTimeout保持对waiting的引用，在执行时也会创建闭包。 3. 闭包的用途？有时候，我们希望能够重用一个变量，并且其被保护起来不被污染篡改，就可以使用闭包。这种变量一般被称为私有变量或者局部变量。 123456//一个很经典的题for(var i = 1; i &lt;= 5; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, i* 1000)&#125; 嗯，我相信大多数搜集资料学习的人，都会清楚答案。 至于为什么，值得再复习一下。 每次循环，我们都会挑出一份i用来输出，但因为setTimeout会在循环完成后执行，每次的i都在同一全局作用域下，于是后来居上，覆盖了前面的i，再由setTimeout执行时，就全是6了。 怎么使得每次循环输出正确呢？ 我们只需要将每次的i变成一个私有变量，有独立的作用域，让其不在篡改就OK了。 使用IIFE 这里引入来自MDN的释义。 IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。 123(function () &#123; statements&#125;)(); 这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。 第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。 12345678// IIFE方法for(var i = 1; i &lt;= 5; i++) &#123; (function (j) &#123; setTimeout(function () &#123; console.log(j) &#125;, j* 1000) &#125;)(i);&#125; 这里利用IIFE拥有独立的此法作用域的特性，将变量私有化，这样在setTimeout执行时就会得到正确输出。没错，好像就是利用闭包将每次的变量缓存起来，放在独立的内存中。 使用ES6的let 123456// let方法for(let i = 1; i &lt;= 5; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, i* 1000)&#125; let会劫持块作用域，“劫持”就是把当前块作用域抢过来变为一个独立的，如果还不明白，请看下面代码。 123456for(var i = 1; i &lt;= 5; i++) &#123; let j = i; setTimeout(function () &#123; console.log(j) &#125;, j* 1000)&#125; let 遇见{}发生了奇妙的邂逅，于是他们“私奔”了~ 在每次循环中都被声明了一次，所以每次循环中的{}内的变量都不干扰。setTimeout很高兴的执行了。 摇晃一下你的小脑瓜，试想一下，如果我们将这些通过闭包产生的私有变量赋值给一个函数，你会联想到什么？ 1234567891011121314151617var foo = （function myModule() &#123; var myPublic = 'web工程师的自我修养'； var mywx = ['tangtang1996918']; function joinMyPublic() &#123; console.log('join web工程师的自我修养') &#125; function pushMywx() &#123; console.log(mywx.push('your')) &#125; return &#123; joinMyPublic: joinMyPublic, pushMywx: pushMywx &#125;&#125;）（）；foo.joinMyPublic();foo.pushMywx(); 是不是在项目中很常见？ 我靠，这就是模块机制啊，兄弟！！！把一些绝妙的方法都劫持过来放在自己的小空间里面，想拿来用就拿来用，岂不美哉？？？当然，现代的模块机制肯定没这么简单，嘻嘻。 4. 强大的闭包认识了闭包，好好想想过去一天中你所写的代码，里面有闭包吗？这是一种日常且强大的模式。 包管理器或者管理模块机制都会将模块定义和模块引入进行封装。封装到现在，已经变成了import和export或者其他的语法糖。","categories":[],"tags":[{"name":"javascript-native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"}]}],"categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://tsunamigg.github.io/tags/browser/"},{"name":"diary","slug":"diary","permalink":"https://tsunamigg.github.io/tags/diary/"},{"name":"Vue-2.6X-source-learn notes","slug":"Vue-2-6X-source-learn-notes","permalink":"https://tsunamigg.github.io/tags/Vue-2-6X-source-learn-notes/"},{"name":"fabric canvas notes","slug":"fabric-canvas-notes","permalink":"https://tsunamigg.github.io/tags/fabric-canvas-notes/"},{"name":"javascript-native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"},{"name":"http","slug":"http","permalink":"https://tsunamigg.github.io/tags/http/"},{"name":"http URI/URL","slug":"http-URI-URL","permalink":"https://tsunamigg.github.io/tags/http-URI-URL/"},{"name":"ESmodule","slug":"ESmodule","permalink":"https://tsunamigg.github.io/tags/ESmodule/"},{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"},{"name":"css","slug":"css","permalink":"https://tsunamigg.github.io/tags/css/"}]}