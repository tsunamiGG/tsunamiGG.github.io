{"meta":{"title":"Secret Garden","subtitle":"","description":"","author":"tsunamiGG","url":"https://tsunamiGG.github.io","root":"/"},"pages":[{"title":"所有分类","date":"2020-05-17T13:00:41.486Z","updated":"2020-05-17T13:00:41.486Z","comments":true,"path":"categories/index.html","permalink":"https://tsunamigg.github.io/categories/index.html","excerpt":"","text":"javascript"},{"title":"关于","date":"2020-05-17T12:59:07.730Z","updated":"2020-05-17T12:59:07.730Z","comments":true,"path":"about/index.html","permalink":"https://tsunamigg.github.io/about/index.html","excerpt":"","text":"占个位子"},{"title":"所有标签","date":"2020-05-17T13:01:21.307Z","updated":"2020-05-17T13:01:21.307Z","comments":true,"path":"tags/index.html","permalink":"https://tsunamigg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue的变化侦测","slug":"Vue-source-learn2","date":"2020-05-22T00:40:28.000Z","updated":"2020-05-22T03:16:32.396Z","comments":true,"path":"2020/05/22/Vue-source-learn2/","link":"","permalink":"https://tsunamigg.github.io/2020/05/22/Vue-source-learn2/","excerpt":"Vue的响应式数据是如何做到的？","text":"Vue的响应式数据是如何做到的？ 变化侦测 变化侦测 = 数据观测+依赖收集+依赖更新 使用Object.defineProperty来使得数据变得可“观测” 依赖收集(Observer)：是指收集视图里的部分与数据绑定的关系 在getter中收集依赖，在setter中通知更新依赖 典型的发布-订阅模式,为了解耦，新增了一个管理对象 dep(收集某个数据相关的所有依赖)，watcher(被dep通知，更新依赖) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// observer.js// 收集依赖const Dep = require('./dep');export class Observer &#123; constructor(value) &#123; this.value = value; def(value, \"__ob__\", this); if (Array.isArray(value)) &#123; console.log(\"array\"); &#125; else &#123; this.walk(value); &#125; &#125; walk(obj) &#123; const keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj,keys[i]); &#125; &#125;&#125;function defineReactive(obj, key, val) &#123; if (arguments.length === 2) &#123; val = obj[key]; &#125; if (typeof val === 'object') &#123; new Observer(val); &#125; const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; dep.depend(); return val; &#125;, set(newval) &#123; if (val === newval) return; val = newval; dep.notify(); &#125; &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142// dep.js// 依赖管理器： 1数据 ：n依赖 的一对多关系进行依赖管理，收集某个数据相关的所有依赖export default class Dep &#123; constructor() &#123; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; removeSub(sub) &#123; remove(this.subs, sub); &#125; depend() &#123; window.target &amp;&amp; this.addSub(window.target); &#125; notify() &#123; const subs = this.subs.slice(); for (let i = 0; i &lt; subs.length; i++) &#123; subs[i].update(); &#125; &#125;&#125;export function remove(arr, item) &#123; if (arr.length &gt; 1) &#123; const itemIndex = arr.indexOf(item); if (itemIndex &gt; 1) &#123; return arr.splice(itemIndex, 1); &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// watcher.js// watcher表示依赖关系，通知视图更新// window.target是为了拷贝一份 watcher,添加到Dep的依赖数组中export default class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.vm = vm; this.cb = cb; this.getter = parsePath(expOrFn); this.value = this.get(); &#125; get() &#123; window.target = this; const vm = this.vm; let value = this.getter.call(vm, vm); window.target = undefined; return value; &#125; update() &#123; const oldValue = this.value; this.value = this.get(); this.cb.call(this.vm, this.value, oldValue); &#125;&#125;/** * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来 * 例如： * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125; * parsePath('a.b.c')(data) // 2 */const bailRE = /[^\\w.$]/;export function parsePath(path) &#123; if (bailRE.test(path)) return; const segements = path.split('.'); return function (obj) &#123; for (let i = 0; i &lt; segements.length; i++) &#123; if (!obj) return; obj = obj[segements[i]]; &#125; return obj; &#125;&#125; 侦测流程 vue这套变化侦测的缺点很明显，因为利用defineProperty来进行收集，只限于读和写已有值，当我们对obj进行新增或者删除属性值时，它是监听不到的。所以在官网文档上的叙述上说明过，对数组或对象的直接增加或者删除会产生不期望的结果， 为了解决这一问题，特地增加了Vue.set和Vue.delete两个全局API 。 数组怎么办? 看到这里，对原型熟悉的人可能会问了，这种方法只针对于Obj类型，那剩下的常用的Arr类型或者其他类型呢？defineProperty数组是不可能使用的，那么我们应该怎么对数组进行依赖收集和通知更新？ 还是延续上面的思想：拦截，vue将所有数组的异变方法(能改变原有数组)拦截一波，就能知道arr啥时候被setter了。 经常面试被问到原型，原型链的what,why,那么how???? 我觉得这就是个很巧妙的实践~ 拦截数组原型上的异变方法(会改变原有宿主的方法)的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//代码位置 vue/src/core/observer/array.js/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 数组依赖收集 无论怎样,先得用walk让元素注入observer依赖，使得在getter中实例化Dep收集依赖并将数组方法拦截掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 源码位置：/src/core/observer/index.jsconst Dep = require(\"./dep\");const &#123; arrayKeys, arrayMethods &#125; = require(\"./array\");// 源码位置：src/core/observer/index.js// 使用 defineProperty 让数据可观测export class Observer &#123; constructor(value) &#123; this.value = value; this.dep = new Dep(); def(value, \"__ob__\", this); if (Array.isArray(value)) &#123; const agument = hasProto ? protoAugment : copyAugument; [agument](value, arrayMethods, arrayKeys); this.observerArray(value); &#125; else &#123; this.walk(value); &#125; &#125; walk(obj) &#123; const keys = Object.keys(obj); for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]); &#125; &#125; observerArray(ietms) &#123; for (let i = 0; i &lt; ietms.length; i++) &#123; observe(ietms[i]); &#125; &#125;&#125;export const hasProto = \"__proto__\" in &#123;&#125;;/* 复制原型属性，添加拦截*/function protoAugment(target, src, keys) &#123; target.__proto__ = src;&#125;function copyAugument(target, src, keys) &#123; for (let i = 0; i &lt; keys.length; i++) &#123; const key = key[i]; def(target, key, src[key]); &#125;&#125;/* * 尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。 * 如果 Value 已经存在一个Observer实例，则直接返回它 */function observe(value) &#123; if (!isObject(value) || value instanceof VNode) &#123; return; &#125; let ob; if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else &#123; ob = new Observer(value); &#125; return ob;&#125;function defineReactive(obj, key, val) &#123; let childOb = observe(val); if (arguments.length === 2) &#123; val = obj[key]; &#125; if (typeof val === \"object\") &#123; new Observer(val); &#125; const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get() &#123; if (childOb) &#123; childOb.dep.depend(); &#125; return val; &#125;, set(newval) &#123; if (val === newval) return; val = newval; dep.notify(); &#125; &#125;);&#125; 通知更新 主要是还要对数组进行深度监测和新增元素侦测，在拦截的原型上进行依赖更新。 __ob__是在进行初始化observer的时候，在被监听者上面挂载了自己的实例，以便访问后进行依赖更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 源码位置：vue/src/core/observer/array.js/* * not type checking this file because flow doesn't play well with * dynamically accessing methods on Array prototype */import &#123; def &#125; from '../util/index'const arrayProto = Array.prototypeexport const arrayMethods = Object.create(arrayProto)const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 总结： vue的变化侦测与React对比Vdom和Angular的脏值检测都不一样。核心是利用defineProperty的能力，拦截所有绑定的响应式数据(data中),在拦截中添加依赖管理器Dep来收集管理依赖,用Watcher表示依赖关系本身，进行通知依赖更新。 其中，对于数组的侦测的思路是，覆盖所有数组原型的的异变方法，在覆盖后植入依赖逻辑。这套缺点就是对数组进行下标赋值操作时，vue是侦测不到的，官网文档上多处对此有说明。 相信下次，面试官问：为什么在vue中对数组下标进行赋值操作会导致不正确的响应式数据结果。这种类似的问题，你一定胸有成竹。","categories":[],"tags":[]},{"title":"vue源码学习（开篇）","slug":"Vue-source-learn1","date":"2020-05-10T02:37:35.000Z","updated":"2020-05-22T02:53:25.923Z","comments":true,"path":"2020/05/10/Vue-source-learn1/","link":"","permalink":"https://tsunamigg.github.io/2020/05/10/Vue-source-learn1/","excerpt":"应该如何学习源码？ 我觉得最开始有个全局观，然后切入细节的模块，带着问题去读。","text":"应该如何学习源码？ 我觉得最开始有个全局观，然后切入细节的模块，带着问题去读。 vue源码学习笔记 本篇结合了阅读 https://nlrx-wjc.github.io/Learn-Vue-Source-Code/ 的笔记，感谢wjc199366(wx)开源。 现在应该看不了了，因为发生了一些事情，大概是人民邮电出版社以影响旗下《深入浅出Vue.js》销量为由，联系微软，将电子书的仓库给关了….. 不过好在关闭之前，留了一份在本地，需要的加我微信取：tangtang1996918 阅读源码之前，建议去看看HcySunYang大佬对vue2/3中一些重要概念的解读： http://hcysun.me/vue-design/zh/essence-of-comp.html 例如：组件传出的本质是什么？Vnode是如何设计的？Vnode是如何挂载为真实DOM的？ 对阅读源码，理清思路是非常有帮助的~ 源码之中没有秘密~ 1.路线 变化侦测篇 学习Vue中如何实现数据的响应式系统，从而达到数据驱动视图。 虚拟DOM篇 学习什么是虚拟DOM，以及Vue中的DOM-Diff原理 模板编译篇 学习Vue内部是怎么把template模板编译成虚拟DOM,从而渲染出真实DOM 生命周期篇 学习Vue中组件的生命周期实现原理 实例方法篇 学习Vue中所有实例方法(即所有以$开头的方法)的实现原理 全局API篇 学习Vue中所有全局API的实现原理 指令篇 学习Vue中所有指令的实现原理 过滤器篇 学习Vue中所有过滤器的实现原理 内置组件篇 学习Vue中内置组件的实现原理 2.方法面对繁复的源码，我们应该怎么去读？ 说下适合我自己的读源码方法，抛砖引玉。 一本正经的一行行的看源码，我只能说兄弟，你他娘的真是个天才 1.一般我先扫一眼import引入的都是那些模块的js文件，一般源码的目录结构都清晰。根据引入的js文件大概都看出该js文件的依赖性，我们可以根据依赖项的多少来判断复杂程度，有个心理预期。 2.然后去看js文件主函数的输入和输出，即传参和返回都是什么，先搞清楚其主要功能。 对。不是一上来就一行行的看逻辑代码，除非你有超强的理解能力，一般是很吃力的。所以我们就先假装自己是个debug工具，先设置跳过全部函数内部细节，只观察主函数和各个内部子函数的输入和输出。(这期间肯定少不了去查看上一部引入的函数功能)。如果结合注释看了很多输入输出还是不明白其作用，那也很正常。 接下来，我们可以复制一下代码片段，做一些测试来证实部分我们对某些函数功能的猜想。有了这些，我们脑中大多都能有个框架。 其实这跟证明数学题的思路十分类似，先提出假设，然后用各种公理，定理来慢慢推导证明。 3.深入每个函数内部的细节。这个就八仙过海各显神通了。不过我觉得还可以先做减法，即根据注释解决兼容性和一些判断环境的hack先给屏蔽掉，关注每个函数主要的逻辑，等把整个模块的脉络弄清楚后，有空再去看看哪些hack。细节不清楚的同样测试，用结果去逆推过程。 4.做笔记，自己写一遍梳理清楚，把你觉得一些很精妙的思路，有趣的类比联想，方法总结，都可以记录下来 复杂的东西都是由简单的东西构成，人们擅长将东西变复杂，却不擅长将东西变简单。 3.目录结构强烈建议浏览一遍，源码中很多都是复用的，纵观全局，再某些判断上是能够帮上忙的~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120src├─ compiler│ ├─ codeframe.js│ ├─ codegen│ │ ├─ events.js│ │ └─ index.js│ ├─ create-compiler.js│ ├─ directives│ │ ├─ bind.js│ │ ├─ index.js│ │ ├─ model.js│ │ └─ on.js│ ├─ error-detector.js│ ├─ helpers.js│ ├─ index.js│ ├─ optimizer.js│ ├─ parser│ │ ├─ entity-decoder.js│ │ ├─ filter-parser.js│ │ ├─ html-parser.js│ │ ├─ index.js│ │ └─ text-parser.js│ └─ to-function.js├─ core│ ├─ components│ │ ├─ index.js│ │ └─ keep-alive.js│ ├─ config.js│ ├─ global-api│ │ ├─ assets.js│ │ ├─ extend.js│ │ ├─ index.js│ │ ├─ mixin.js│ │ └─ use.js│ ├─ index.js│ ├─ instance│ │ ├─ events.js│ │ ├─ index.js│ │ ├─ init.js│ │ ├─ inject.js│ │ ├─ lifecycle.js│ │ ├─ proxy.js│ │ ├─ render-helpers│ │ ├─ render.js│ │ └─ state.js│ ├─ observer│ │ ├─ array.js│ │ ├─ dep.js│ │ ├─ index.js│ │ ├─ scheduler.js│ │ ├─ traverse.js│ │ └─ watcher.js│ ├─ util│ │ ├─ debug.js│ │ ├─ env.js│ │ ├─ error.js│ │ ├─ index.js│ │ ├─ lang.js│ │ ├─ next-tick.js│ │ ├─ options.js│ │ ├─ perf.js│ │ └─ props.js│ └─ vdom│ ├─ create-component.js│ ├─ create-element.js│ ├─ create-functional-component.js│ ├─ helpers│ ├─ modules│ ├─ patch.js│ └─ vnode.js├─ platforms│ ├─ web│ │ ├─ compiler│ │ ├─ entry-compiler.js│ │ ├─ entry-runtime-with-compiler.js│ │ ├─ entry-runtime.js│ │ ├─ entry-server-basic-renderer.js│ │ ├─ entry-server-renderer.js│ │ ├─ runtime│ │ ├─ server│ │ └─ util│ └─ weex│ ├─ compiler│ ├─ entry-compiler.js│ ├─ entry-framework.js│ ├─ entry-runtime-factory.js│ ├─ runtime│ └─ util├─ server│ ├─ bundle-renderer│ │ ├─ create-bundle-renderer.js│ │ ├─ create-bundle-runner.js│ │ └─ source-map-support.js│ ├─ create-basic-renderer.js│ ├─ create-renderer.js│ ├─ optimizing-compiler│ │ ├─ codegen.js│ │ ├─ index.js│ │ ├─ modules.js│ │ ├─ optimizer.js│ │ └─ runtime-helpers.js│ ├─ render-context.js│ ├─ render-stream.js│ ├─ render.js│ ├─ template-renderer│ │ ├─ create-async-file-mapper.js│ │ ├─ index.js│ │ ├─ parse-template.js│ │ └─ template-stream.js│ ├─ util.js│ ├─ webpack-plugin│ │ ├─ client.js│ │ ├─ server.js│ │ └─ util.js│ └─ write.js├─ sfc│ └─ parser.js└─ shared ├─ constants.js └─ util.js","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://tsunamigg.github.io/tags/notes/"}]},{"title":"创建对象的几种方式","slug":"object-create","date":"2019-08-25T11:45:38.000Z","updated":"2020-05-17T12:48:45.034Z","comments":true,"path":"2019/08/25/object-create/","link":"","permalink":"https://tsunamigg.github.io/2019/08/25/object-create/","excerpt":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式","text":"在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式 1.简单工厂模式：Simple Factory工厂模式什么意思？ 如果把我们编写业务代码的过程，比作造一台电视机，那么工厂模式就是先打造好生产电视机的流水线。如何打造生产线？？？ 我们将需要工厂制造的产物的特性抽象出来，在代码上表现为我们规定其属性名称，但其属性值又参数来决定。 1234567function createBook(name, pages, author) &#123; let newBook = &#123;&#125;; newBook.name = name; newBook.pages = pages; newBook.author = author; return newBook;&#125; 这是一种工厂模式，其实现方式与之前学基础的寄生继承有点相似，也是在一个新的变量上去添加属性，使用字面量方式创建对象会比使用new高效的多。 还有一种就是先将不同型号的电视机造出来，然后通过工厂来输送到不同的产品区。 这里的工厂不在制造，而是充当deliver的角色。 123456789101112131415161718192021222324function fictionBook() &#123; this.name = '九州缥缈录'; this.story = '铁甲依然在'; this.tellStory = function()&#123; console.log(this.story) &#125;&#125;function classicBook() &#123; this.name = '假如给我三天光明'; this.author = '海伦凯勒'; this.bookauthor = function () &#123; console.log(this.author) &#125;&#125;function createBook(type) &#123; switch (type) &#123; case 'fiction': return new fictionBook(); case 'classic': return new classicBook(); &#125;&#125; 两种方式优缺点十分明显， 第一种常见方式需要我们固定某些参数类型，限制了其多样性，但相比第二种省事多了。第二种则相反，每创造一种不同型号的电视机就需要我们去创建一个新的类并向分发类添加该选项。 2.工厂方法模式: Factory Method12345678910111213141516//安全模式 const Factory = function (type, content) &#123; if (this instanceof Factory) &#123; return new this[type](content); &#125; else &#123; return new Factory(type, content); &#125; &#125;Factory.prototype = &#123; show: function(content) &#123; this.content = content; console.log(content); &#125;&#125;const test = new Factory('show', '2'); 安全模式的好处在于，在简单工厂模式上加了一层限制，如果没有创建工厂类，就直接执行该函数而不是返回工厂对象。 12345678910111213141516171819202122232425262728293031323334353637383940//抽象模式const abstractFactory = function (superType, subType) &#123; if (typeof abstractFactory[superType] === 'function' ) &#123; function F() &#123;&#125;; F.prototype = new abstractFactory[superType](); subType.constructor = subType; subType.prototype = new F(); &#125; else &#123; throw new Error('未创建该抽象类') &#125;&#125;abstractFactory.desk = function() &#123; this.type = 'desk';&#125;abstractFactory.desk.prototype = &#123; getDeskSize: function () &#123; return new Error('抽象方法不能调用') &#125;, getDeskMaterial: function() &#123; return new Error('抽象方法不能调用') &#125;&#125;//实例化抽象desk类// 1.子类构造方法let machilusDesk = function(size, material) &#123; this.size = size; this.material = material;&#125;// 2. 将子类构造方法送入工厂，继承工厂抽象方法abstractFactory('desk', machilusDesk);// 3. 覆盖抽象方法machilusDesk.prototype.getDeskSize = function() &#123; return this.size;&#125;machilusDesk.prototype.getDeskMaterial = function() &#123; return this.material;&#125; 在JS中，abstract是一个保留关键字，所以想要实现抽象类，是不可能像传统的面向对象语言那么方便，但由于其灵活性，我们可以模拟出抽象类的主要行为。 抽象方法时不可调用的，会报错，所以我们模拟出其这个行为，并且采用寄生继承来继承父类。当工厂生成子类后，覆盖抽象方法，就不会报错了。 抽象模式是提前定义了类的结构，而不是直接创建类。就像建房子先画好房子的图纸一样，先描述出其轮廓~ 但JS中不支持抽象化创建和虚拟方法，所以其引用并不广泛，但也是面向对象编程中很经典常见的一种模式。 3.建造者模式： Builder如果说工厂模式的侧重点在创建的结果，那么建造者就是注重创建过程的一种模式。 建造者会注意创建过程的每个细节，就像我们捏橡皮人时，不光要注意身体的轮廓，还要注意头有多大，四肢有多长….理所当然的创建过程会复杂很多。 其过程就是将各种特性都封装成类，然后在主类里面根据不同参数，实例化不同的特性，组成新的子类，或者叫其复合对象。 123456789101112131415161718192021222324252627function House(parmas) &#123; this.material = parmas &amp;&amp; parmas.material || '**'; this.area = parmas &amp;&amp; parmas.area || '**';&#125;House.prototype = &#123; getMaterial: function() &#123; return this.material; &#125;, getArea: function() &#123; return this.area; &#125;&#125;function material(material) &#123; this.material = material;&#125;function area(m) &#123; this.area = m * m;&#125;function newHouse(material, m) &#123; let _house = new House(); _house.material = new material(material); _house.area = new area(area); return _house;&#125; 就像搭积木一样，先把各块积木的形状找好，然后组合在一起。抛出一个问题，如果要在一个网页上呈现卡片堆砌的效果，你会怎么做呢？ 个人理解，这个模式是我们经常解决生活中问题的一种方法的抽象，复杂的问题简单化，就是将一个复杂的事物拆分成多个简单的事物，再以某种方式组合起来，来解决问题的一种方法。 4.原型模式：prototype其被称为语言之魂，它将原型对象指向创建对象的类，使这些类共享原型对象的方法和属性。 存在即合理，那么它解决了什么问题？在很多复杂的功能下，我们的子类需要继承父类的一些属性与方法，但是并非所有子类需求的属性和方法都是一致的，所以子类会从父类继承一些不必要的，增加额外开销的属性和方法。例如，一个车的父类，子类可能是跑车，轿车，SUV，越野，跑车需要整个车体结构和轿车不一样，但父类因为考虑整体性不会有特殊的车体结构，而是通用的轿车结构，那么子类就从父类继承了一些额外的负担性质的属性和方法。而子类每次实例化都会造成很多不可避免的额外开销。 原型概念就此而出，它将某些可复用，可共享的，开销大的属性和方法从父类提取出来放在原型之中，子类通过前文的某些继承方式来继承，直接获得这些属性和方法而不是每次实例化重新创建这些属性和方法，节省了很多不必要的开销。 js在原型模式下实现的原型链，让所有内置的属性和方法都享受到该模式的好处。 其实现方式就是对一个对象的拷贝，也是一种继承方式，但很特殊的一点，创建过程于它无瓜，理解这一点很重要~ 5.单例模式： singleton这是js编程中很常见的一种模式，只允许实例化一次的对象类。有时生成命名空间namespace。多人协作开发或者加载独立的第三方库的时候，我们的词语总是有限的，怎么让它们的命名互不影响呢？答案说都开辟独立的命名空间，使得其方法名都可以区分开。同时，对我们在管理静态变量也非常有帮助。 风靡很多时的Jquery就是经典的例子，其$符就是命名空间，$(&#39;className&#39;).function这样的调用方式使得代码清晰明了，一看就知道是Jquery的方法。 1234567891011let mynamespace = &#123; utils: &#123; formate: function() &#123; ..... &#125; &#125;, ajax: function() &#123; ..... &#125; MYHEIGHT: 180&#125; 其实就是封装在一个对象里面，延展开来就是模块机制，把整个js文件作为一个对象，存放不同的命名空间，避免方法名的覆盖。 怎么实现只能实例化一次的对象类？ 妈耶，用个闭包记录，如果被实例化了，就return掉，easy。 什么？ 怎么创建一个闭包？？？ 建议你去看看《你不知道的javascript》,书中详细的论述了闭包是什么，怎么创建闭包，闭包的用途又是什么，闭包背后的作用机制其实是保持对作用域的引用等等。下次有空，结合书本我们来详解一下js中的闭包，解开其神秘的面纱。 总结 创建型设计模式是一些处理对象创建的模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。 创建单类简单对象的简单工厂模式，简单的缺点也很明显，于是工厂方法模式补足创建多类的实例(其实是传入不同参数的简单工厂模式和安全模式的混合)。建造者模式则是通过组合多种简单工厂模式，来创造复杂的对象。原型模式也被成为语言之魂，将某些属性和方法放在原型对象中作为所有对象的共有属性和方法，避免了子类每次实例化都会可能创建新的不必要的，开销大的属性和方法。单例模式则是为我们的代码管理做出了卓越的贡献。这五种模式中，原型模式并不关心对象创建过程，但对创建过程做出的贡献还是有目共睹，或许这就是大佬吧，润物细无声~","categories":[],"tags":[{"name":"javascript native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"}]},{"title":"Event loop","slug":"Event loop","date":"2019-05-19T11:25:19.000Z","updated":"2020-05-17T11:46:13.652Z","comments":true,"path":"2019/05/19/Event loop/","link":"","permalink":"https://tsunamigg.github.io/2019/05/19/Event%20loop/","excerpt":"","text":"Event loop的粗浅认识事件轮询js是单线程的。其事件轮询由：同步任务，异步任务，macrotask（宏任务），microtask （微任务）组成。其执行过程如下： 同步任务： 主线程上的任务，前一个完成后后一个执行。 异步任务：不进入主线程，进入任务队列（task queue)中执行，等于macrotask。 macrotask：任务队列的主体，同一个队列内的“先进先出”执行。不同的队列之间“先进后出”执行。 microtask ：总在任务队列末尾执行，有新的microtask 继续加在末尾执行。 执行过程：1.同步任务执行 2. 任务按队列依次执行 3.微任务按队列依次执行 4.重复1-3 宏任务和微任务对于宏任务和微任务的概念的理解，一开始确实是不太清楚的。 先来说说宏任务，我们不妨这样来看，既然它是任务队列的主体，那么它一定由一个或者多个任务构成。抛开JS,[宏]这个字本身就不是单一的，在CS中的[宏]就是批量处理的意思。 对于稍微了解过一点点c的人来说，应该都不陌生，辟如：编译预处理命令，宏定义等等。 1234// 编译预处理命令#include&lt;stdio.h&gt;// 宏定义#define PI 3.14 我将[编译预处理命令]（在编译之前进行的处理）就看做是[宏任务]，就是你写了一系列的前置操作，在后面的代码执行之前，这些宏任务全部需要执行完毕~ 稍微生活化一点点，比如那个中国互联网起步的时候，我的同学之间，喜欢用QQ等级作为谈资。所以我让我的电脑开机后自动登录QQ；或者现今5G来临之前，男生多半玩过的MOBA类游戏，就拿LOL中的瞎子摸眼R闪这种操作，你完全可以选一个拥有宏命令的鼠标，设置测试后一键完成这种“用双手成就你的梦想”等秀的飞起的操作；还有诸如乔碧萝之类的人士，开启直播推流之前，对自己直播效果的优化。这些都是所谓宏任务。 至于微任务，相信聪明可爱的你一定能够举一反一，找到自己对其充分的理解~:smile: 常见的宏任务和微任务： 宏任务： setTimeout setInterval setImmediate requestAnimationFrame I/O UI rendering 微任务： process.nextTick Promises Object.observe MutationObserver 执行图例 希望执行帧动画能让你对整个过程的理解清晰许多 小练习11234567891011121314151617181920console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// 浏览器输出顺序：//script start//script end//promise1//promise2//setTimeout 小练习21234567891011121314151617181920212223242526272829async function async1()&#123; console.log('async1 start') await async2() console.log('async1 end')&#125;async function async2()&#123; console.log('async2')&#125;console.log('script start')setTimeout(function()&#123; console.log('setTimeout') &#125;,0) async1();new Promise(function(resolve)&#123; console.log('promise1') resolve();&#125;).then(function()&#123; console.log('promise2')&#125;)console.log('script end')// 浏览器输出顺序：// script start//async1 start//async2//promise1//script end//async1 end//promise2//setTimeout await会将之后的代码抛入下一个执行队列，代码上的表现就是执行完await的会跳出函数体执行其他的同步任务。 setTimeout的回调函数会进入下一个同步任务队列中。 如果输出顺序不一致，是因为各大浏览器对异步的处理是不一样的，没什么奇怪的。 另外，node环境输出顺序也有很大差异。","categories":[],"tags":[{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"}]}],"categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://tsunamigg.github.io/tags/notes/"},{"name":"javascript native","slug":"javascript-native","permalink":"https://tsunamigg.github.io/tags/javascript-native/"},{"name":"javascript event loop","slug":"javascript-event-loop","permalink":"https://tsunamigg.github.io/tags/javascript-event-loop/"}]}