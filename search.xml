<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>chrome调试骚操作</title>
      <link href="/2020/05/28/Chrome-debugging-ways/"/>
      <url>/2020/05/28/Chrome-debugging-ways/</url>
      
        <content type="html"><![CDATA[<p>解锁chrome调试黑科技</p><a id="more"></a><h3 id="chrome调试骚操作"><a href="#chrome调试骚操作" class="headerlink" title="chrome调试骚操作"></a>chrome调试骚操作</h3><ul><li><strong>通用篇</strong>(Windows)</li></ul><ol><li><p>切换DevTools窗口的布局（下右）</p><p>Ctrl + Shift + D</p></li><li><p>切换DevTools选项卡 (Element-NetWork-Audits)</p><p>Ctrl + [ 或 ]： 向左和向右 </p><p>Ctrl + 1 到 9：DevTools&gt;Settings&gt;Preferences&gt;<em>Appearance</em>中打开 (开启之后，浏览器网页选项卡也可以切换)</p></li><li><p>Styles数值调整</p><ol><li>Alt +上下箭头 0.1</li><li>上下箭头 1</li><li>Shfit+上下箭头 10</li><li>Ctrl  +上下箭头 100</li></ol></li><li><p>elements，logs， sources &amp; network 皆可使用 <code>Ctrl+F</code></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/168747e72320ff3a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p></li></ol><ol start="5"><li><p>Element中的HTML可以直接<code>Ctrl+C</code>保存</p></li><li><p>copy(全局对象或者DOM or 一些太长的对象)，可直接复制到编辑器中查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; console板块</span><br><span class="line">window </span><br><span class="line"></span><br><span class="line">....blabllabla</span><br><span class="line"></span><br><span class="line">copy(window)</span><br><span class="line"></span><br><span class="line">Ctrl+V</span><br></pre></td></tr></table></figure></li><li><p><strong>debugger</strong></p><ol><li>越过下一个函数调用 :  F10、Ctrl + ‘ ;</li><li>进入下一个函数调用 :  F11、Ctrl + ;</li><li>跳出当前函数 :  Shift + F11、Ctrl + Shift + ; </li><li>切换断点条件:  点击行号、Ctrl + B;</li></ol></li></ol><p>   只列举出来我认为很常用的，详见： <a href="https://developers.google.com/web/tools/chrome-devtools/shortcuts" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/shortcuts</a> </p><ul><li><strong>Command篇</strong></li></ul><p> 打开<code>devtools</code>,  <code>[Ctrl]</code> + <code>[Shift]</code> + <code>[P]</code> (Mac： <code>[⌘]</code> + <code>[Shift]</code>+ <code>[P]</code> ) ,会进入这样的界面。</p><p>   <img src="http://m.qpic.cn/psc?/V14Ny1NJ1hfPZT/T0po5IVZeaNliPGRfxFJTjWkbJLQdBzTBxncRVLU4zX.9Ke.VrR..ZxL4bIp2huDYS16YS*5dRRJqyX2aBXDwoKFRkHT52qkDU57QASbzfU!/b&bo=MQRdAzEEXQMDCSw!&rf=viewer_4" alt="img"> </p><p><strong>截屏方式</strong></p><p>没错，有好几种截屏的方式，但微信截图他不香吗？</p><p>不不不，第三方工具只能截满你的屏幕尺寸大小，比如：web长度大于1080，而你要看到所有的element?</p><p>选择上图中的： full size 即可。 长图示例预警:</p><p> <img src="http://m.qpic.cn/psc?/V14Ny1NJ1hfPZT/T0po5IVZeaNliPGRfxFJTs8xvNC3*1c1Y3tKKn0tO2reR6MOmfEeeWx1XFH1EyE5UFFeibbtOSgyl6N7.JfOwD6DYXIflRFDXmPzLnACM9k!/b&bo=gAI1C28HUiEDCYs!&rf=viewer_4" alt="img"> </p><p> <strong>切换主题</strong></p><p>当你在晚上工作，讨厌白闪闪的<code>devtools</code>,Commond输入： theme。</p><p>里面还有很多很多功能~  模块如下：</p><p> <img src="https://user-gold-cdn.xitu.io/2018/12/11/1679a2e13926d71b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p><ul><li><p>Snippets</p><p>位于<code>Sources</code>模块的，很常用的除了<code>page</code>来看一些err和源码。还有一个<code>snippets</code>也很实用。</p><p>1.新建代码块</p><p> <img src="http://m.qpic.cn/psc?/V14Ny1NJ1hfPZT/T0po5IVZeaNliPGRfxFJTgNHP3DU2sEDrYpYWTYc6g0yX*aY3DfX.4qoOFPGiXmS35FuIu*5fyXZpnF1tKj9hHpVjNOu.ZeiXOh6EtpjxPo!/b&bo=2wRKA9sESgMDCSw!&rf=viewer_4" alt="img"> </p></li></ul><p>  2.执行(!+代码块序号)</p><p>   <img src="http://m.qpic.cn/psc?/V14Ny1NJ1hfPZT/T0po5IVZeaNliPGRfxFJTirodoWVtU2LOMPMI2PY42IPEjbj731rWnkjVax6wWsgxxJ1PlWD6kBiER8jktkY6nBszV8LZT63H0Gz..IolNM!/b&bo=2wRKA9sESgMDCSw!&rf=viewer_4" alt="img"> </p><p>这样就可以输出对应代码块的结果啦。 可以理解为给你开了个沙箱，所以你可以<strong>引入其他来源代码块来执行</strong>。</p><p>测试证明，清cookie ，清缓存，关闭浏览器都不会导致snippets丢失，而且是跨域名全局可用，应该是强存储于浏览器上的 。有点硬~</p><hr><blockquote><p>Date: 2020/2/28</p></blockquote><ul><li><p><code>Console</code>模块篇</p><p><strong><code>$</code>符号</strong></p><p>1.调试的过程中，你经常会通过打印查看一些变量的值，但如果你想看一下上次执行的结果呢？再输一遍表达式吗？</p><p>这时候 <code>$_</code> 就派上了用场，<code>$_</code> 是对上次执行的结果的 <strong>引用</strong> ：</p><p> <img src="https://user-gold-cdn.xitu.io/2018/12/7/16785d333e7c1d7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> </p></li></ul><ol start="2"><li><p><code>$</code> 变量在 <code>console</code> 中就是对这一大串函数 <code>document.querySelector</code> 的别名。</p><p><code>$$</code>变量执行 <code>document.QuerySelectorAll</code> 并且它返回的是：一个节点的 <strong>数组</strong> ，而不是一个 <code>Node list</code></p><p>例如：<code>Array.from(document.querySelectorAll(&#39;div&#39;)) === $$(&#39;div&#39;)</code>  。</p><p>查找<code>Node</code>可比对着<code>Element</code>看强太多啦！</p></li></ol><p>   <img src="http://m.qpic.cn/psc?/V14Ny1NJ1hfPZT/T0po5IVZeaNliPGRfxFJTlO30ye.GCHcUg72OjXZ3D*K3xdVSMvsrvj9jVOjebAZHM2bIfbNer5Mpx165ndHiU5WkZLdWYxPTOUfbwj4fFs!/b&bo=MQTVAjEE1QIDByI!&rf=viewer_4" alt="img"> </p><p>   <strong>结合起来就有一个很妙的css调试法~</strong></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Console输入！</span></span><br><span class="line">$$(<span class="string">'*'</span>).forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;item.style.outline=<span class="string">'1px solid red'</span>&#125;)</span><br></pre></td></tr></table></figure><p>   效果如下：</p><p>   <img src="http://m.qpic.cn/psb?/V14Ny1NJ1hfPZT/kIdOUSJYDH6NCqVQAq*dhPn2fnHwFebgM1p9XdBNvsE!/b/dDYBAAAAAAAA&bo=QQd6AgAAAAADBxw!&rf=viewer_4" alt=""></p><p> <strong><code>custom formatter</code> 自定义格式转换器</strong></p><p>我们习惯使用 <code>DevTools</code> 的 <code>console</code> 默认对 <code>object</code> 的转换(例如上图)，但有时候我们想用与众不同的方式来处理。 那我们就可以自定义输出对象的函数 <code>custom formatter</code>~</p><blockquote><p>具体的官网介绍在这里：  <a href="https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview" target="_blank" rel="noopener">https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview</a> </p></blockquote><p>开启方法：打开<code>devtools</code>,按下<code>F1</code>。勾选如下~</p><p> <img src="https://www.mattzeunert.com/img/blog/custom-formatters/custom-formatters-setting.png" alt="Custom formatters checkbox in Chrome"> </p><p><code>formatter</code>： 它是一个对象，包含三个方法：</p><ul><li><code>header</code> : 处理如何展示在 <code>console</code> 的日志中的主要部分。</li><li><code>hasbody</code> : 如果你想显示一个用来展开对象的 <code>▶</code> 箭头，返回 <code>true</code></li><li><code>body</code> : 定义将会被显示在展开部分的内容中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.devtoolsFormatters = [&#123;</span><br><span class="line">    header: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"div"</span>, &#123;&#125;, obj.toString()]</span><br><span class="line">    &#125;,</span><br><span class="line">    hasBody: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><blockquote><p>其中<code>header</code> 方法返回了一个 <a href="http://www.jsonml.org/" target="_blank" rel="noopener">JsonML</a> (注： <code>JsonML</code> : <code>JSON Markup Language</code> - <code>JSON</code> 标记语言) 数组，由这些组成：</p><ol><li>标签名</li><li>属性对象</li><li>内容 (文本值或者其他元素)</li></ol></blockquote><p>让我们看看发生了什么：</p><p> <img src="https://miro.medium.com/max/884/1*NnDpCTFRTiXg8K6HZS9rng.gif" alt="img"> </p><p><strong>amazing</strong></p><p>现有好几种 <code>custom formatter</code> 可供选择，例如：你可以在这个 <a href="https://github.com/andrewdavey/immutable-devtools" target="_blank" rel="noopener">immutable-devtools </a>仓库中找到对于 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable.js</a> 结构的完美展示。但你同样可以自己造一个。</p><p>如果你遇到结构不寻常的对象时，或大量的日志(最好避免这样的情况，但是有时候很有用)而你想从中做区分时，你可以采用 <code>custom formatter</code> 来处理。</p><p>一个很实用的窍门：直接将你不关心，不需要区别对待的对象过滤出来，直接在 <code>header</code> 方法里面 <code>return null</code>。让 <code>DevTools</code> 使用默认的格式化方式来处理这些值。</p><p>让我们来找点乐子，让开让开，我要装逼啦！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.devtoolsFormatters = [&#123;</span><br><span class="line">    header: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj.__clown) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> obj.__clown;</span><br><span class="line">      <span class="keyword">const</span> style = <span class="string">`</span></span><br><span class="line"><span class="string">        color: red;</span></span><br><span class="line"><span class="string">        border: dotted 2px gray;</span></span><br><span class="line"><span class="string">        border-radius: 4px;</span></span><br><span class="line"><span class="string">        padding: 5px;</span></span><br><span class="line"><span class="string">      `</span>;</span><br><span class="line">      <span class="keyword">const</span> content = <span class="string">`🤡 <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'div'</span>, &#123;style&#125;, content]</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123; <span class="comment">// for circular structures</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// use the default formatter</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    hasBody: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.clown = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;...obj, <span class="attr">__clown</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;<span class="attr">message</span>: <span class="string">'hello!'</span>&#125;);   <span class="comment">// normal log</span></span><br><span class="line"><span class="built_in">console</span>.clown(&#123;<span class="attr">message</span>: <span class="string">'hello!'</span>&#125;); <span class="comment">// a silly log</span></span><br></pre></td></tr></table></figure><p> <img src="http://m.qpic.cn/psc?/V14Ny1NJ1hfPZT/T0po5IVZeaNliPGRfxFJTmN5OIMlgjK19VsPJ2c8GD8z79Ko0f833BFLviAzMAIr9SrXhgMy560daCVlLxjibatifncFYU5ZbqlSbqjtLXc!/b&bo=MQTbAzEE2wMRBzA!&rf=viewer_4" alt="img"> </p><p>可以在<code>massage</code>里面加入一个<code>emoji</code>表情。当然，**他的实际作用是<code>tag</code>，可以通过不同的<code>tag</code>来表示不同的项目，便于区分~</p>]]></content>
      
      
      
        <tags>
            
            <tag> browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走好下一步</title>
      <link href="/2020/05/23/reload/"/>
      <url>/2020/05/23/reload/</url>
      
        <content type="html"><![CDATA[<p>抛下过去，走向未来，成就自己</p><a id="more"></a><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>大三下学期，觉得自己不能就此沉沦。想着自己好歹算个计算机沾边的专业，去找一份编程相关的工作，应该还是有搞头的。</p><p>在图书馆看到一本《web工程师的自我修养》，心里波澜起伏。于是，就在前端的路上一去不复返~</p><h6 id="折戟"><a href="#折戟" class="headerlink" title="折戟"></a>折戟</h6><p>实习去了一家高歌猛进，疯狂增长的现已上市的在线教育公司，当我满怀憧憬，准备大干一场，现实却给我来了一记狠狠的patch。</p><p>对于没有任何项目经验，只学了俩个月基础的我来说；每天醍醐灌顶，很多事情并没有做到自己能做到的最好，更多的失误，脑子犯浑，给决定我实习是否通过的师傅留下了能力不足的印象。</p><p>从未想过会有这样的结果，每天睡不着，很多就来到工位学习知道晚上9点，与大家一起开早会，完成几个简单的任务，一起极乐汤团建，参加年会….</p><p> 对我的打击是巨大的，听着HRBP安慰的语音，思绪翻涌。我甚至开始怀疑自己真正是否能够胜任这份工作，我是不是应该听爸妈的话，回去小县城去考公务员….各种怀疑，不自信的负面情绪就像潮汐一般，想要推得越远，却弹回来越远。我知道，我失去了这辈子最重要的第二次机会。</p><h6 id="重启？改变？"><a href="#重启？改变？" class="headerlink" title="重启？改变？"></a>重启？改变？</h6><p>在颓废2个月后，房租，电费，燃气费，一条条短信提醒着我，不能再这样下去了。</p><p>于是降低自己的要求，在武汉这样一个大环境都是外包的条件下，匆匆就签了一个40人，只有1个前端的科技公司….</p><p>嗯，是的，对于现状非常不满意。每天写着不太感兴趣的业务，改着稀烂的代码。 如果非要说进步，那大概是磨平了棱角，刷新了对客户的认知，熟悉了微信这样稀烂的开发环境… 我仍然没有放弃，努力在工作空余时间，去看点东西，但就像一只无头苍蝇一般，乱撞。</p><p>着学习的事情不能一蹴而就，得持之以恒，系统的学。就从<strong>红宝书</strong>开始，重学基础，然后就去肯Vue源码。现在对Vue2.x的双向绑定，虚拟DOM，模板编译都有一定理解，源码中没有秘密。</p><h6 id="如果迷茫了就开始制定计划吧"><a href="#如果迷茫了就开始制定计划吧" class="headerlink" title="如果迷茫了就开始制定计划吧"></a>如果迷茫了就开始制定计划吧</h6><p>迷茫来自于下时代5G的浪潮，每次通信革命都让人们的生活发生翻天覆地的变化..这次也毫不例外。是继续在本就过饱和的互联网继续挣扎还是去把握住新的风口机会？但相信自己的条件，并没有机会去抓住新风口，只能继续前进，但紧跟变化发展，发挥自己的洞察力，找到合适的机会！</p><p>刚毕业快一年，想着给自己定一个目标。</p><p>毕业3年内，在武汉工资过万或者进入一家心里满意的公司。对前端的技能很熟练，可以独自解决业务难点，养成良好编码习惯。熟练Vue与react，啃完Vue2.x,3.x源码；深入使用canvas或者进击数据可视化等等有深度的领域。 能够写py或者其他后端语言，去捡起SQL，碰碰服务端的数据库，服务器等等。</p><p>今年，一定要跳槽！ </p><p>冲鸭！</p>]]></content>
      
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-source-learn1</title>
      <link href="/2020/05/22/Vue-source-learn1/"/>
      <url>/2020/05/22/Vue-source-learn1/</url>
      
        <content type="html"><![CDATA[<hr><p>title: vue源码学习（开篇）<br>date: 2020-05-10 10:37:35<br>tags: notes</p><hr><p>应该如何学习源码？ 我觉得最开始有个全局观，然后切入细节的模块，带着问题去读。</p><a id="more"></a><h3 id="vue源码学习笔记"><a href="#vue源码学习笔记" class="headerlink" title="vue源码学习笔记"></a>vue源码学习笔记</h3><blockquote><p>本篇结合了阅读 <a href="https://nlrx-wjc.github.io/Learn-Vue-Source-Code/" target="_blank" rel="noopener">https://nlrx-wjc.github.io/Learn-Vue-Source-Code/</a> 的笔记，感谢wjc199366(wx)开源。</p><p>现在应该看不了了，因为发生了一些事情，大概是人民邮电出版社以影响旗下《深入浅出Vue.js》销量为由，联系微软，将电子书的仓库给关了…..</p><p>不过好在关闭之前，留了一份在本地，需要的加我微信取：tangtang1996918</p><p>阅读源码之前，建议去看看<a href="https://github.com/HcySunYang" target="_blank" rel="noopener">HcySunYang</a>大佬对vue2/3中一些重要概念的解读：</p><p><a href="http://hcysun.me/vue-design/zh/essence-of-comp.html" target="_blank" rel="noopener">http://hcysun.me/vue-design/zh/essence-of-comp.html</a></p><p>例如：组件传出的本质是什么？Vnode是如何设计的？Vnode是如何挂载为真实DOM的？</p><p>对阅读源码，理清思路是非常有帮助的~</p><p>源码之中没有秘密~</p></blockquote><h5 id="1-路线"><a href="#1-路线" class="headerlink" title="1.路线"></a>1.路线</h5><ol><li><p>变化侦测篇</p><p>学习<code>Vue</code>中如何实现数据的响应式系统，从而达到数据驱动视图。</p></li><li><p>虚拟DOM篇</p><p>学习什么是虚拟DOM，以及<code>Vue</code>中的<code>DOM-Diff</code>原理</p></li><li><p>模板编译篇</p><p>学习<code>Vue</code>内部是怎么把<code>template</code>模板编译成虚拟<code>DOM</code>,从而渲染出真实<code>DOM</code></p></li><li><p>生命周期篇</p><p>学习<code>Vue</code>中组件的生命周期实现原理</p></li><li><p>实例方法篇</p><p>学习<code>Vue</code>中所有实例方法(即所有以<code>$</code>开头的方法)的实现原理</p></li><li><p>全局API篇</p><p>学习<code>Vue</code>中所有全局<code>API</code>的实现原理</p></li><li><p>指令篇</p><p>学习<code>Vue</code>中所有指令的实现原理</p></li><li><p>过滤器篇</p><p>学习<code>Vue</code>中所有过滤器的实现原理</p></li><li><p>内置组件篇</p><p>学习<code>Vue</code>中内置组件的实现原理</p></li></ol><h5 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h5><p>面对繁复的源码，我们应该怎么去读？ 说下适合我自己的读源码方法，<strong>抛砖引玉</strong>。</p><p>一本正经的一行行的看源码，我只能说兄弟，你他娘的真是个天才</p><p>1.一般我先扫一眼import引入的都是那些模块的js文件，一般源码的目录结构都清晰。根据引入的js文件大概都看出该js文件的依赖性，我们可以根据依赖项的多少来判断复杂程度，有个心理预期。</p><p>2.然后去看js文件主函数的输入和输出，即传参和返回都是什么，先搞清楚其主要功能。</p><p>对。不是一上来就一行行的看逻辑代码，除非你有超强的理解能力，一般是很吃力的。所以我们就先假装自己是个debug工具，先设置跳过全部函数内部细节，只观察主函数和各个内部子函数的输入和输出。(这期间肯定少不了去查看上一部引入的函数功能)。如果结合注释看了很多输入输出还是不明白其作用，那也很正常。</p><p>接下来，我们可以复制一下代码片段，做一些测试来证实部分我们对某些函数功能的猜想。有了这些，我们脑中大多都能有个框架。</p><p>其实这跟证明数学题的思路十分类似，先提出假设，然后用各种公理，定理来慢慢推导证明。</p><p>3.深入每个函数内部的细节。这个就八仙过海各显神通了。不过我觉得还可以先做减法，即根据注释解决兼容性和一些判断环境的hack先给屏蔽掉，关注每个函数主要的逻辑，等把整个模块的脉络弄清楚后，有空再去看看哪些hack。细节不清楚的同样测试，用结果去逆推过程。</p><p>4.做笔记，自己写一遍梳理清楚，把你觉得一些很精妙的思路，有趣的类比联想，方法总结，都可以记录下来</p><p>复杂的东西都是由简单的东西构成，人们擅长将东西变复杂，却不擅长将东西变简单。</p><h5 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3.目录结构"></a>3.目录结构</h5><p>强烈建议浏览一遍，源码中很多都是复用的，纵观全局，再某些判断上是能够帮上忙的~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├─ compiler</span><br><span class="line">│    ├─ codeframe.js</span><br><span class="line">│    ├─ codegen</span><br><span class="line">│    │    ├─ events.js</span><br><span class="line">│    │    └─ index.js</span><br><span class="line">│    ├─ create-compiler.js</span><br><span class="line">│    ├─ directives</span><br><span class="line">│    │    ├─ bind.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    ├─ model.js</span><br><span class="line">│    │    └─ on.js</span><br><span class="line">│    ├─ error-detector.js</span><br><span class="line">│    ├─ helpers.js</span><br><span class="line">│    ├─ index.js</span><br><span class="line">│    ├─ optimizer.js</span><br><span class="line">│    ├─ parser</span><br><span class="line">│    │    ├─ entity-decoder.js</span><br><span class="line">│    │    ├─ filter-parser.js</span><br><span class="line">│    │    ├─ html-parser.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    └─ text-parser.js</span><br><span class="line">│    └─ to-function.js</span><br><span class="line">├─ core</span><br><span class="line">│    ├─ components</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    └─ keep-alive.js</span><br><span class="line">│    ├─ config.js</span><br><span class="line">│    ├─ global-api</span><br><span class="line">│    │    ├─ assets.js</span><br><span class="line">│    │    ├─ extend.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    ├─ mixin.js</span><br><span class="line">│    │    └─ use.js</span><br><span class="line">│    ├─ index.js</span><br><span class="line">│    ├─ instance</span><br><span class="line">│    │    ├─ events.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    ├─ init.js</span><br><span class="line">│    │    ├─ inject.js</span><br><span class="line">│    │    ├─ lifecycle.js</span><br><span class="line">│    │    ├─ proxy.js</span><br><span class="line">│    │    ├─ render-helpers</span><br><span class="line">│    │    ├─ render.js</span><br><span class="line">│    │    └─ state.js</span><br><span class="line">│    ├─ observer</span><br><span class="line">│    │    ├─ array.js</span><br><span class="line">│    │    ├─ dep.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    ├─ scheduler.js</span><br><span class="line">│    │    ├─ traverse.js</span><br><span class="line">│    │    └─ watcher.js</span><br><span class="line">│    ├─ util</span><br><span class="line">│    │    ├─ debug.js</span><br><span class="line">│    │    ├─ env.js</span><br><span class="line">│    │    ├─ error.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    ├─ lang.js</span><br><span class="line">│    │    ├─ next-tick.js</span><br><span class="line">│    │    ├─ options.js</span><br><span class="line">│    │    ├─ perf.js</span><br><span class="line">│    │    └─ props.js</span><br><span class="line">│    └─ vdom</span><br><span class="line">│           ├─ create-component.js</span><br><span class="line">│           ├─ create-element.js</span><br><span class="line">│           ├─ create-functional-component.js</span><br><span class="line">│           ├─ helpers</span><br><span class="line">│           ├─ modules</span><br><span class="line">│           ├─ patch.js</span><br><span class="line">│           └─ vnode.js</span><br><span class="line">├─ platforms</span><br><span class="line">│    ├─ web</span><br><span class="line">│    │    ├─ compiler</span><br><span class="line">│    │    ├─ entry-compiler.js</span><br><span class="line">│    │    ├─ entry-runtime-with-compiler.js</span><br><span class="line">│    │    ├─ entry-runtime.js</span><br><span class="line">│    │    ├─ entry-server-basic-renderer.js</span><br><span class="line">│    │    ├─ entry-server-renderer.js</span><br><span class="line">│    │    ├─ runtime</span><br><span class="line">│    │    ├─ server</span><br><span class="line">│    │    └─ util</span><br><span class="line">│    └─ weex</span><br><span class="line">│           ├─ compiler</span><br><span class="line">│           ├─ entry-compiler.js</span><br><span class="line">│           ├─ entry-framework.js</span><br><span class="line">│           ├─ entry-runtime-factory.js</span><br><span class="line">│           ├─ runtime</span><br><span class="line">│           └─ util</span><br><span class="line">├─ server</span><br><span class="line">│    ├─ bundle-renderer</span><br><span class="line">│    │    ├─ create-bundle-renderer.js</span><br><span class="line">│    │    ├─ create-bundle-runner.js</span><br><span class="line">│    │    └─ source-map-support.js</span><br><span class="line">│    ├─ create-basic-renderer.js</span><br><span class="line">│    ├─ create-renderer.js</span><br><span class="line">│    ├─ optimizing-compiler</span><br><span class="line">│    │    ├─ codegen.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    ├─ modules.js</span><br><span class="line">│    │    ├─ optimizer.js</span><br><span class="line">│    │    └─ runtime-helpers.js</span><br><span class="line">│    ├─ render-context.js</span><br><span class="line">│    ├─ render-stream.js</span><br><span class="line">│    ├─ render.js</span><br><span class="line">│    ├─ template-renderer</span><br><span class="line">│    │    ├─ create-async-file-mapper.js</span><br><span class="line">│    │    ├─ index.js</span><br><span class="line">│    │    ├─ parse-template.js</span><br><span class="line">│    │    └─ template-stream.js</span><br><span class="line">│    ├─ util.js</span><br><span class="line">│    ├─ webpack-plugin</span><br><span class="line">│    │    ├─ client.js</span><br><span class="line">│    │    ├─ server.js</span><br><span class="line">│    │    └─ util.js</span><br><span class="line">│    └─ write.js</span><br><span class="line">├─ sfc</span><br><span class="line">│    └─ parser.js</span><br><span class="line">└─ shared</span><br><span class="line">       ├─ constants.js</span><br><span class="line">       └─ util.js</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue的变化侦测</title>
      <link href="/2020/05/22/Vue-source-learn2/"/>
      <url>/2020/05/22/Vue-source-learn2/</url>
      
        <content type="html"><![CDATA[<p>Vue的响应式数据是如何做到的？</p><a id="more"></a><h4 id="变化侦测"><a href="#变化侦测" class="headerlink" title="变化侦测"></a>变化侦测</h4><ul><li><p>变化侦测 = 数据观测+依赖收集+依赖更新</p><ol><li>使用Object.defineProperty来使得数据变得可“观测”</li><li>依赖收集(Observer)：是指收集视图里的部分与数据绑定的关系</li><li>在getter中收集依赖，在setter中通知更新依赖</li><li>典型的发布-订阅模式,为了解耦，新增了一个管理对象</li><li>dep(收集某个数据相关的所有依赖)，watcher(被dep通知，更新依赖)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer.js</span></span><br><span class="line"><span class="comment">// 收集依赖</span></span><br><span class="line"><span class="keyword">const</span> Dep = <span class="built_in">require</span>(<span class="string">'./dep'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">def(value, <span class="string">"__ob__"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"array"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.walk(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk(obj) &#123;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">defineReactive(obj,keys[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">        val = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            dep.depend();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newval) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newval) <span class="keyword">return</span>;</span><br><span class="line">            val = newval;</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dep.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖管理器： 1数据 ：n依赖 的一对多关系进行依赖管理，收集某个数据相关的所有依赖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    removeSub(sub) &#123;</span><br><span class="line">        remove(<span class="keyword">this</span>.subs, sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    depend() &#123;</span><br><span class="line">        <span class="built_in">window</span>.target &amp;&amp; <span class="keyword">this</span>.addSub(<span class="built_in">window</span>.target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subs.length; i++) &#123;</span><br><span class="line">            subs[i].update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> itemIndex = arr.indexOf(item);</span><br><span class="line">        <span class="keyword">if</span> (itemIndex &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr.splice(itemIndex, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  watcher表示依赖关系，通知视图更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// window.target是为了拷贝一份 watcher,添加到Dep的依赖数组中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class="line">        <span class="keyword">this</span>.vm = vm;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">        <span class="keyword">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="built_in">window</span>.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line">        <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.value, oldValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把一个形如'data.a.b.c'的字符串路径所表示的值，从真实的data对象中取出来</span></span><br><span class="line"><span class="comment"> * 例如：</span></span><br><span class="line"><span class="comment"> * data = &#123;a:&#123;b:&#123;c:2&#125;&#125;&#125;</span></span><br><span class="line"><span class="comment"> * parsePath('a.b.c')(data)  // 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bailRE.test(path)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> segements = path.split(<span class="string">'.'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segements.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">            obj = obj[segements[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="侦测流程"><a href="#侦测流程" class="headerlink" title="侦测流程"></a>侦测流程</h4></li></ul><p>  <img src="http://m.qpic.cn/psc?/V14Ny1NJ1hfPZT/T0po5IVZeaNliPGRfxFJTpvnvhXceHb2BiTFiZAVRik4Grz5Ucuvqxon5*B7hvq9Qw7z*mYj8iEw.fLaTwl76xwAhLUJ5aOEfe8M*lTjbz8!/b&bo=lAPgAZQD4AEDCSw!&rf=viewer_4" alt=""><strong><code>vue</code>这套变化侦测的缺点很明显，因为利用<code>defineProperty</code>来进行收集，只限于读和写已有值，当我们对<code>obj</code>进行新增或者删除属性值时，它是监听不到的</strong>。所以在官网文档上的叙述上说明过，对数组或对象的直接增加或者删除会产生不期望的结果， 为了解决这一问题，特地增加了<code>Vue.set</code>和<code>Vue.delete</code>两个全局API 。</p><p>  <strong>数组怎么办</strong>?</p><p>  看到这里，对原型熟悉的人可能会问了，这种方法只针对于<code>Obj</code>类型，那剩下的常用的<code>Arr</code>类型或者其他类型呢？<code>defineProperty</code>数组是不可能使用的，那么我们应该怎么对数组进行依赖收集和通知更新？</p><p>  还是延续上面的思想：拦截，<code>vue</code>将所有数组的异变方法(能改变原有数组)拦截一波，就能知道<code>arr</code>啥时候被<code>setter</code>了。</p><p>  经常面试被问到原型，原型链的what,why,那么how????  我觉得这就是个很巧妙的实践~</p><p>  拦截数组原型上的异变方法(会改变原有宿主的方法)的代码：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码位置 vue/src/core/observer/array.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * not type checking this file because flow doesn't play well with</span></span><br><span class="line"><span class="comment"> * dynamically accessing methods on Array prototype</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="数组依赖收集"><a href="#数组依赖收集" class="headerlink" title="数组依赖收集"></a>数组依赖收集</h4><p>  无论怎样,先得用<code>walk</code>让元素注入observer依赖，使得在<code>getter</code>中实例化<code>Dep</code>收集依赖并将数组方法拦截掉</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码位置：/src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">const</span> Dep = <span class="built_in">require</span>(<span class="string">"./dep"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; arrayKeys, arrayMethods &#125; = <span class="built_in">require</span>(<span class="string">"./array"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码位置：src/core/observer/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 defineProperty 让数据可观测</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(value) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line"><span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">def(value, <span class="string">"__ob__"</span>, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line"><span class="keyword">const</span> agument = hasProto ? protoAugment : copyAugument;</span><br><span class="line">[agument](value, arrayMethods, arrayKeys);</span><br><span class="line"><span class="keyword">this</span>.observerArray(value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.walk(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk(obj) &#123;</span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">defineReactive(obj, keys[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">observerArray(ietms) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ietms.length; i++) &#123;</span><br><span class="line">observe(ietms[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hasProto = <span class="string">"__proto__"</span> <span class="keyword">in</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    复制原型属性，添加拦截</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src, keys</span>) </span>&#123;</span><br><span class="line">target.__proto__ = src;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugument</span>(<span class="params">target, src, keys</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> key = key[i];</span><br><span class="line">def(target, key, src[key]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  尝试为value创建一个0bserver实例，如果创建成功，直接返回新创建的Observer实例。</span></span><br><span class="line"><span class="comment"> *  如果 Value 已经存在一个Observer实例，则直接返回它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ob;</span><br><span class="line">    <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">        ob = value.__ob__;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> childOb = observe(val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">val = obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">"object"</span>) &#123;</span><br><span class="line"><span class="keyword">new</span> Observer(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">enumerable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">true</span>,</span><br><span class="line"><span class="keyword">get</span>() &#123;</span><br><span class="line"><span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">childOb.dep.depend();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">set</span>(newval) &#123;</span><br><span class="line"><span class="keyword">if</span> (val === newval) <span class="keyword">return</span>;</span><br><span class="line">val = newval;</span><br><span class="line">dep.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通知更新"><a href="#通知更新" class="headerlink" title="通知更新"></a>通知更新</h4><p>   主要是还要对数组进行深度监测和新增元素侦测，在拦截的原型上进行依赖更新。</p><p>  <code>__ob__</code>是在进行初始化observer的时候，在被监听者上面挂载了自己的实例，以便访问后进行依赖更新。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码位置：vue/src/core/observer/array.js</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * not type checking this file because flow doesn't play well with</span></span><br><span class="line"><span class="comment"> * dynamically accessing methods on Array prototype</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>总结： <code>vue</code>的变化侦测与<code>React</code>对比Vdom和<code>Angular</code>的脏值检测都不一样。核心是利用<code>defineProperty</code>的能力，拦截所有绑定的响应式数据(data中),在拦截中添加依赖管理器<code>Dep</code>来收集管理依赖,用<code>Watcher</code>表示依赖关系本身，进行通知依赖更新。</p><p>其中，对于数组的侦测的思路是，覆盖所有数组原型的的异变方法，在覆盖后植入依赖逻辑。这套缺点就是对数组进行下标赋值操作时，vue是侦测不到的，官网文档上多处对此有说明。</p><p>相信下次，面试官问：为什么在<code>vue</code>中对数组下标进行赋值操作会导致不正确的响应式数据结果。这种类似的问题，你一定胸有成竹。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue-2.6X-source-learn notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric notes</title>
      <link href="/2020/04/21/fabric-notes/"/>
      <url>/2020/04/21/fabric-notes/</url>
      
        <content type="html"><![CDATA[<p>一次 fabric + customiseControls 制作涂鸦canvas画板实践</p><a id="more"></a><h3 id="制作图片涂鸦画板-微信浏览器"><a href="#制作图片涂鸦画板-微信浏览器" class="headerlink" title="制作图片涂鸦画板(微信浏览器)"></a>制作图片涂鸦画板(微信浏览器)</h3><ol><li><h5 id="fabric-customiseControls简介"><a href="#fabric-customiseControls简介" class="headerlink" title="fabric+customiseControls简介"></a>fabric+customiseControls简介</h5></li></ol><p>fabric是一个canvas库，其核心就是将canvasAPI转换为对象模型，让我们更加便捷的使用。</p><p>customiseControls则是基于fabric的插件，可为新建的fabric对象设置角标，并为其提供一系列事件：drag，</p><p>scale，rotate，remove，或者自定义事件。</p><blockquote><p>fabric:<a href="https://github.com/fabricjs/fabric.js" target="_blank" rel="noopener">https://github.com/fabricjs/fabric.js</a></p><p>customiseControls：<a href="https://github.com/pixolith/fabricjs-customise-controls-extension" target="_blank" rel="noopener">https://github.com/pixolith/fabricjs-customise-controls-extension</a></p></blockquote><ol start="2"><li><h5 id="效果说明-模糊的图片是故意的"><a href="#效果说明-模糊的图片是故意的" class="headerlink" title="效果说明(模糊的图片是故意的)"></a>效果说明(模糊的图片是故意的)</h5></li></ol><ul><li>用户涂鸦环节：</li></ul><p><img src="https://i.loli.net/2020/05/16/fEbJB9A8orHQycX.png" alt="1.png"></p><p>涂鸦的构成 = 1.城市背景图 + 贴纸图片素材 + 文字图片素材</p><p>1点击缩略图切换，切换时2，3不变化。 2，3是可选中后可拖拽，拖拽时不影响其他图片素材，选中之后出现四个角的角标，角标的事件为放大，缩小，旋转，移除。</p><ul><li>生成环节</li></ul><p><img src="https://i.loli.net/2020/05/16/jCVOFeaHRX7JldT.png" alt="2.png"></p><p>根据用户涂鸦的结果，生成一张带有其他信息的海报(长按保存到手机相册)，比如： 用户地理位置信息，当前参与人数，二维码，昵称，头像等等</p><ol start="3"><li><h4 id="开撸"><a href="#开撸" class="headerlink" title="开撸"></a>开撸</h4></li></ol><p>开撸之前还是梳理一下重点和优化点：</p><p>A.涂鸦画板的交互(重点)</p><p>B.精准生成海报(重点)和海报的清晰度(优化点)</p><p><strong>A部分</strong>： 用户选择对应背景或者涂鸦素材后有正确相应，设置边界值</p><p><strong>1.初始化fabric插件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置部分角标不可见</span></span><br><span class="line">fabric.Object.prototype.setControlsVisibility(&#123;</span><br><span class="line">  ml: <span class="literal">false</span>,</span><br><span class="line">  mr: <span class="literal">false</span>,</span><br><span class="line">  mtr: <span class="literal">false</span>,</span><br><span class="line">  mt: <span class="literal">false</span>,</span><br><span class="line">  mb: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角标事件设置</span></span><br><span class="line">fabric.Canvas.prototype.customiseControls(&#123;</span><br><span class="line">  br: &#123;</span><br><span class="line">    action: <span class="string">"rotate"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bl: &#123;</span><br><span class="line">    action: <span class="string">'scale'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tl: &#123;</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params">e, target</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = target.canvas;</span><br><span class="line">      canvas.remove(target).renderAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  tr: &#123;</span><br><span class="line">    action: <span class="string">'scale'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用选框</span></span><br><span class="line">fabric.Object.prototype.transparentCorners = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角标基础设置</span></span><br><span class="line">fabric.Object.prototype.customiseCornerIcons(&#123;</span><br><span class="line">  settings: &#123;</span><br><span class="line">    borderColor: <span class="string">'#fff'</span>,</span><br><span class="line">    cornerSize: <span class="number">20</span>,</span><br><span class="line">    cornerBackgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">    cornerPadding: <span class="number">5</span></span><br><span class="line">  &#125;,</span><br><span class="line">  br: &#123;</span><br><span class="line">    action: <span class="string">"rotate"</span>,</span><br><span class="line">    icon: <span class="string">'./imgs/icons/rotate.svg'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  bl: &#123;</span><br><span class="line">    action: <span class="string">'scale'</span>,</span><br><span class="line">    icon: <span class="string">'./imgs/icons/resize.svg'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  tl: &#123;</span><br><span class="line">    icon: <span class="string">'./imgs/icons/remove.svg'</span>,</span><br><span class="line">    action: <span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params">e, target</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = target.canvas;</span><br><span class="line">      canvas.remove(target).renderAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  tr: &#123;</span><br><span class="line">    action: <span class="string">'scale'</span>,</span><br><span class="line">    icon: <span class="string">'./imgs/icons/resize.svg'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  board.renderAll();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> ww = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">var</span> wh = $(<span class="built_in">window</span>).height();</span><br><span class="line"><span class="keyword">var</span> board = <span class="keyword">new</span> fabric.Canvas(<span class="string">'drawBoard'</span>, &#123;</span><br><span class="line">  backgroundColor: <span class="string">'transparent'</span>,</span><br><span class="line">  width: (ww * <span class="number">0.92</span></span><br><span class="line">  height: (wh * <span class="number">0.67</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2.添加用户点击交互(click -&gt; 新增对应素材至画板 或者切换城市背景)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fabricItemList = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置图片背景</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setImagebg</span>(<span class="params">imgSrc</span>) </span>&#123;</span><br><span class="line">  fabric.Image.fromURL(imgSrc, <span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    img.set(&#123;</span><br><span class="line">      scaleX: board.width / img.width,</span><br><span class="line">      scaleY: board.height / img.height</span><br><span class="line">    &#125;);</span><br><span class="line">    board.setBackgroundImage(img, board.renderAll.bind(board));</span><br><span class="line">    board.requestRenderAll();</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    crossOrigin: <span class="string">'anonymous'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置自定义图片</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPicture</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.customiseCornerIcons(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    board.renderAll();</span><br><span class="line">  &#125;);</span><br><span class="line">  fabricItemList.push(obj);</span><br><span class="line">  board.add(obj);</span><br><span class="line">  board.setActiveObject(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成文字对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addText</span>(<span class="params">ctext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">1</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">1</span>] : <span class="string">"#fff"</span>;</span><br><span class="line">  <span class="keyword">var</span> textObj = <span class="keyword">new</span> fabric.Text(ctext, &#123;</span><br><span class="line">    fontFamily: <span class="string">"PingFang SC, Verdana, Helvetica Neue, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif"</span>,</span><br><span class="line">    fontSize: <span class="number">30</span>,</span><br><span class="line">    top: <span class="number">150</span>,</span><br><span class="line">    left: <span class="number">150</span>,</span><br><span class="line">    originX: <span class="string">'center'</span>,</span><br><span class="line">    originY: <span class="string">'center'</span>,</span><br><span class="line">    fill: color</span><br><span class="line">  &#125;);</span><br><span class="line">  setPicture(textObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成图片对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">featImg</span>(<span class="params">imgSrc, scale</span>) </span>&#123;</span><br><span class="line">  fabric.Image.fromURL(imgSrc, <span class="function"><span class="keyword">function</span> (<span class="params">img</span>) </span>&#123;</span><br><span class="line">    img.set(&#123;</span><br><span class="line">      scaleX: scale,</span><br><span class="line">      scaleY: scale,</span><br><span class="line">      angle: <span class="number">0</span>,</span><br><span class="line">      left: <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? <span class="built_in">Math</span>.random() * <span class="number">50</span> + <span class="number">110</span> : -<span class="built_in">Math</span>.random() * <span class="number">50</span> + <span class="number">110</span>,</span><br><span class="line">      top: <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? <span class="built_in">Math</span>.random() * <span class="number">50</span> + <span class="number">120</span> : -<span class="built_in">Math</span>.random() * <span class="number">50</span> + <span class="number">120</span>,</span><br><span class="line">      hasControls: <span class="literal">true</span>,</span><br><span class="line">      borderColor: <span class="string">'#fff'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    setPicture(img);</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    crossOrigin: <span class="string">'anonymous'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.生成画板图</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drawImg = board.toDataURL();   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成后复原fabric对象</span></span><br><span class="line">fabricItemList.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> board.remove(item);</span><br><span class="line">&#125;);</span><br><span class="line">fabricItemList = [];</span><br></pre></td></tr></table></figure><p><strong>B部分</strong>： 如何根据设计稿精准绘制海报（重点）？</p><p>1.使用现有成熟的方案： canvas2Image + html2canvas(高质量前端快照方案：来自页面的「自拍」)</p><p>详见网易云音乐团队的文章：<a href="https://juejin.im/post/5df2e8ab6fb9a0163770816d#heading-15" target="_blank" rel="noopener">https://juejin.im/post/5df2e8ab6fb9a0163770816d#heading-15</a></p><p>2.自己瞎折腾</p><p>最终选择：*<em>自己瞎折腾 *</em>    </p><p>心路历程：</p><p>？？？？作者是不是脑子有病(小声BB)…</p><p>为什么我要做费力不讨好的事情？ 现成的库他不香吗？</p><p>原因在于ios手机在授权后的：<strong>微信浏览器的白条问题</strong></p><blockquote><p>白条会使得整个可视区的DOM被向上顶一部分距离…</p><p>整个网上的方案都在现有资源下都不能好好解决，<a href="https://developers.weixin.qq.com/community/develop/doc/0000a09f840910386ee69390251c00" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/develop/doc/0000a09f840910386ee69390251c00</a></p></blockquote><p>白条问题使得在使用前面的「自拍」方案时，生成的海报会错位…结果惨不忍睹！</p><p>html2canvas是根据遍历DOM样式信息来生成的，而且在遍历过程中，<strong>它会重新加载所有资源</strong>(在network自己看)，如果遇到质量较高或者像这样的数量的图片，会出现绘制空白的可能。</p><p>自己瞎折腾的结果：</p><p>根据canvas的drawimage写了个生成图的js，写的垃圾，大佬勿喷…<br><a href="https://github.com/tsunamiGG/utils/blob/master/makePoster.js。" target="_blank" rel="noopener">https://github.com/tsunamiGG/utils/blob/master/makePoster.js。</a></p><p>大概思路： </p><p>canvas图层堆叠是有顺序的，所以按照图层顺序进行传参。</p><p>为保证生成资源的完整性，必须先确保onload之后进入合成过程。</p><p>以左上角为原点，然后使用性能不错的drawimage(x,y,w,h)离屏渲染生成，从而避开了生成图被白条影响。</p><p><strong>b部分</strong>：海报的清晰度(优化点)</p><p>可以看到上面的效果图清晰度是非常不理想的，需要优化。</p><hr><p>为什么我们的canvas绘制的东西看上去总是比用DOM合成的东西糊一些？</p><p>真实物理设备的像素和css的像素是有差距的，window.devicePixelRatio的值就反应了其比例。它告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。</p><p>同一个东西，你使用一个css像素来表示，假设在不同手机上分别浏览器本需要4个物理像素或8个物理像素。而canvas只用一个位图像素来填充4个物理像素或8个物理像素，不糊才怪呢..</p><p>如果想深入了解，参考：<a href="https://juejin.im/post/5cbdda7bf265da036504fb46" target="_blank" rel="noopener">https://juejin.im/post/5cbdda7bf265da036504fb46</a></p><hr><p>1.js设置放大<code>devicePixelRatio</code>倍数宽高的canvas，css设置缩小<code>devicePixelRatio</code>倍数的canvas。扩大实际像素数量，视觉上保持跟原有尺寸一致，在API生成图片后会清晰很多。</p><blockquote><p>这里需要注意的是，使用css缩小视觉画布时，由于fabirc会在html上生成两个canvas画布，分别是outer和inner，你需要把两个画布的css都缩小。</p></blockquote><p>2.关闭canvas抗锯齿</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">const</span> scale = <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line">canvas.width = width * scale;</span><br><span class="line">canvas.height = height * scale;</span><br><span class="line"><span class="keyword">const</span> context = canvas.getContext(<span class="string">"2d"</span>).scale(scale, scale)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭抗锯齿</span></span><br><span class="line">context.mozImageSmoothingEnabled = <span class="literal">false</span>;</span><br><span class="line">context.webkitImageSmoothingEnabled = <span class="literal">false</span>;</span><br><span class="line">context.msImageSmoothingEnabled = <span class="literal">false</span>;</span><br><span class="line">context.imageSmoothingEnabled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>优化后效果如下，手机保存图实际质量比这个高：</p><p><img src="https://i.loli.net/2020/05/16/hmHFyS4axcbZ8OC.png" alt="3.png"></p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>对十分陌生的canvas稍微有了一些认识，用canvas做动画的库非常多，但有个致命的缺点就是没办法进行调试…</p><p>其中还有很多微信浏览器的很多玄学问题就不展开了，白条问题确实是很头疼的。fabric可以整出很多惊艳的效果，但其乱七八糟的文档和糟糕的示例会带来很多麻烦，影响发挥…</p>]]></content>
      
      
      
        <tags>
            
            <tag> fabric canvas notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象的几种方式</title>
      <link href="/2019/08/25/object-create/"/>
      <url>/2019/08/25/object-create/</url>
      
        <content type="html"><![CDATA[<p>在native中，创建对象的方式千差万别，设计模式中的创建型则基于这些不同的方式</p><a id="more"></a><h5 id="1-简单工厂模式：Simple-Factory"><a href="#1-简单工厂模式：Simple-Factory" class="headerlink" title="1.简单工厂模式：Simple Factory"></a>1.简单工厂模式：Simple Factory</h5><p>工厂模式什么意思？ 如果把我们编写业务代码的过程，比作造一台电视机，那么工厂模式就是先打造好生产电视机的流水线。如何打造生产线？？？ 我们将需要工厂制造的产物的特性抽象出来，在代码上表现为我们规定其属性名称，但其属性值又参数来决定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">name, pages, author</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newBook = &#123;&#125;;</span><br><span class="line">    newBook.name = name;</span><br><span class="line">    newBook.pages = pages;</span><br><span class="line">    newBook.author = author;</span><br><span class="line">    <span class="keyword">return</span> newBook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种工厂模式，其实现方式与之前学基础的<em>寄生继承</em>有点相似，也是在一个新的变量上去添加属性，使用字面量方式创建对象会比使用<code>new</code>高效的多。</p><p>还有一种就是先将不同型号的电视机造出来，然后通过工厂来输送到不同的产品区。 这里的工厂不在制造，而是充当<code>deliver</code>的角色。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fictionBook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'九州缥缈录'</span>;</span><br><span class="line">    <span class="keyword">this</span>.story = <span class="string">'铁甲依然在'</span>;</span><br><span class="line">    <span class="keyword">this</span>.tellStory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.story)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classicBook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'假如给我三天光明'</span>;</span><br><span class="line">    <span class="keyword">this</span>.author = <span class="string">'海伦凯勒'</span>;</span><br><span class="line">    <span class="keyword">this</span>.bookauthor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'fiction'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> fictionBook();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'classic'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> classicBook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式优缺点十分明显， 第一种常见方式需要我们固定某些参数类型，限制了其多样性，但相比第二种省事多了。第二种则相反，每创造一种不同型号的电视机就需要我们去创建一个新的类并向分发类添加该选项。</p><h5 id="2-工厂方法模式-Factory-Method"><a href="#2-工厂方法模式-Factory-Method" class="headerlink" title="2.工厂方法模式: Factory Method"></a>2.工厂方法模式: Factory Method</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全模式    </span></span><br><span class="line"><span class="keyword">const</span> Factory = <span class="function"><span class="keyword">function</span> (<span class="params">type, content</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Factory) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>[type](content);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Factory(type, content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Factory.prototype = &#123;</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="built_in">console</span>.log(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Factory(<span class="string">'show'</span>, <span class="string">'2'</span>);</span><br></pre></td></tr></table></figure><p>安全模式的好处在于，在简单工厂模式上加了一层限制，如果没有创建工厂类，就直接执行该函数而不是返回工厂对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象模式</span></span><br><span class="line"><span class="keyword">const</span> abstractFactory = <span class="function"><span class="keyword">function</span> (<span class="params">superType, subType</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> abstractFactory[superType] === <span class="string">'function'</span> ) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">        F.prototype = <span class="keyword">new</span> abstractFactory[superType]();</span><br><span class="line">        subType.constructor = subType;</span><br><span class="line">        subType.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'未创建该抽象类'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstractFactory.desk = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'desk'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstractFactory.desk.prototype = &#123;</span><br><span class="line">    getDeskSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    getDeskMaterial: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象方法不能调用'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化抽象desk类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.子类构造方法</span></span><br><span class="line"><span class="keyword">let</span> machilusDesk = <span class="function"><span class="keyword">function</span>(<span class="params">size, material</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">this</span>.material = material;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 将子类构造方法送入工厂，继承工厂抽象方法</span></span><br><span class="line">abstractFactory(<span class="string">'desk'</span>, machilusDesk);</span><br><span class="line"><span class="comment">// 3. 覆盖抽象方法</span></span><br><span class="line">machilusDesk.prototype.getDeskSize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">&#125;</span><br><span class="line">machilusDesk.prototype.getDeskMaterial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>JS</code>中，<code>abstract</code>是一个保留关键字，所以想要实现抽象类，是不可能像传统的面向对象语言那么方便，但由于其灵活性，我们可以模拟出抽象类的主要行为。</p><p>抽象方法时不可调用的，会报错，所以我们模拟出其这个行为，并且采用寄生继承来继承父类。当工厂生成子类后，覆盖抽象方法，就不会报错了。</p><p>抽象模式是提前定义了类的结构，而不是直接创建类。就像建房子先画好房子的图纸一样，先描述出其轮廓~ </p><p>但<code>JS</code>中不支持抽象化创建和虚拟方法，所以其引用并不广泛，但也是面向对象编程中很经典常见的一种模式。</p><h5 id="3-建造者模式：-Builder"><a href="#3-建造者模式：-Builder" class="headerlink" title="3.建造者模式： Builder"></a>3.建造者模式： Builder</h5><p>如果说工厂模式的侧重点在创建的结果，那么建造者就是注重创建过程的一种模式。</p><p>建造者会注意创建过程的每个细节，就像我们捏橡皮人时，不光要注意身体的轮廓，还要注意头有多大，四肢有多长….理所当然的创建过程会复杂很多。 其过程就是将各种特性都封装成类，然后在主类里面根据不同参数，实例化不同的特性，组成新的子类，或者叫其复合对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">House</span>(<span class="params">parmas</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.material = parmas &amp;&amp; parmas.material || <span class="string">'**'</span>;</span><br><span class="line">    <span class="keyword">this</span>.area = parmas &amp;&amp; parmas.area || <span class="string">'**'</span>;</span><br><span class="line">&#125;</span><br><span class="line">House.prototype = &#123;</span><br><span class="line">    getMaterial: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.material;</span><br><span class="line">    &#125;,</span><br><span class="line">    getArea: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">material</span>(<span class="params">material</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.material = material;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.area = m * m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newHouse</span>(<span class="params">material, m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _house = <span class="keyword">new</span> House();</span><br><span class="line">    _house.material = <span class="keyword">new</span> material(material);</span><br><span class="line">    _house.area = <span class="keyword">new</span> area(area);</span><br><span class="line">    <span class="keyword">return</span> _house;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像搭积木一样，先把各块积木的形状找好，然后组合在一起。抛出一个问题，如果要在一个网页上呈现卡片堆砌的效果，你会怎么做呢？ 个人理解，这个模式是我们经常解决生活中问题的一种方法的抽象，复杂的问题简单化，就是将一个复杂的事物拆分成多个简单的事物，再以某种方式组合起来，来解决问题的一种方法。</p><h5 id="4-原型模式：prototype"><a href="#4-原型模式：prototype" class="headerlink" title="4.原型模式：prototype"></a>4.原型模式：prototype</h5><p>其被称为语言之魂，它将原型对象指向创建对象的类，使这些类共享原型对象的方法和属性。</p><p>存在即合理，那么它解决了什么问题？在很多复杂的功能下，我们的子类需要继承父类的一些属性与方法，但是并非所有子类需求的属性和方法都是一致的，所以子类会从父类继承一些不必要的，增加额外开销的属性和方法。例如，一个车的父类，子类可能是跑车，轿车，SUV，越野，跑车需要整个车体结构和轿车不一样，但父类因为考虑整体性不会有特殊的车体结构，而是通用的轿车结构，那么子类就从父类继承了一些额外的负担性质的属性和方法。而子类每次实例化都会造成很多不可避免的额外开销。</p><p>原型概念就此而出，它将某些可复用，可共享的，开销大的属性和方法从父类提取出来放在原型之中，子类通过前文的某些继承方式来继承，直接获得这些属性和方法而不是每次实例化重新创建这些属性和方法，节省了很多不必要的开销。</p><p><code>js</code>在原型模式下实现的原型链，让所有内置的属性和方法都享受到该模式的好处。</p><p>其实现方式就是对一个对象的拷贝，也是一种继承方式，但很特殊的一点，创建过程于它无瓜，理解这一点很重要~</p><h5 id="5-单例模式：-singleton"><a href="#5-单例模式：-singleton" class="headerlink" title="5.单例模式： singleton"></a>5.单例模式： singleton</h5><p>这是<code>js</code>编程中很常见的一种模式，只允许实例化一次的对象类。有时生成命名空间<code>namespace</code>。多人协作开发或者加载独立的第三方库的时候，我们的词语总是有限的，怎么让它们的命名互不影响呢？答案说都开辟独立的命名空间，使得其方法名都可以区分开。同时，对我们在管理静态变量也非常有帮助。</p><p>风靡很多时的<code>Jquery</code>就是经典的例子，其<code>$</code>符就是命名空间，<code>$(&#39;className&#39;).function</code>这样的调用方式使得代码清晰明了，一看就知道是<code>Jquery</code>的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mynamespace = &#123;</span><br><span class="line">utils: &#123;</span><br><span class="line">formate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">.....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ajax: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">.....</span><br><span class="line">    &#125;</span><br><span class="line">MYHEIGHT: <span class="number">180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是封装在一个对象里面，延展开来就是模块机制，把整个<code>js</code>文件作为一个对象，存放不同的命名空间，避免方法名的覆盖。</p><p>怎么实现只能实例化一次的对象类？ 妈耶，用个闭包记录，如果被实例化了，就<code>return</code>掉，easy。</p><p>什么？ 怎么创建一个闭包？？？ 建议你去看看《你不知道的javascript》,书中详细的论述了闭包是什么，怎么创建闭包，闭包的用途又是什么，闭包背后的作用机制其实是保持对作用域的引用等等。下次有空，结合书本我们来详解一下<code>js</code>中的闭包，解开其神秘的面纱。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>创建型设计模式是一些处理对象创建的模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。</p></blockquote><p>创建单类简单对象的简单工厂模式，简单的缺点也很明显，于是工厂方法模式补足创建多类的实例(其实是传入不同参数的简单工厂模式和安全模式的混合)。建造者模式则是通过组合多种简单工厂模式，来创造复杂的对象。原型模式也被成为语言之魂，将某些属性和方法放在原型对象中作为所有对象的共有属性和方法，避免了子类每次实例化都会可能创建新的不必要的，开销大的属性和方法。单例模式则是为我们的代码管理做出了卓越的贡献。这五种模式中，原型模式并不关心对象创建过程，但对创建过程做出的贡献还是有目共睹，或许这就是大佬吧，润物细无声~</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识`http`缓存</title>
      <link href="/2019/06/22/http-cache/"/>
      <url>/2019/06/22/http-cache/</url>
      
        <content type="html"><![CDATA[<p>不打不相识之http缓存</p><a id="more"></a><h2 id="初识http缓存"><a href="#初识http缓存" class="headerlink" title="初识http缓存"></a>初识<code>http</code>缓存</h2><p>近日，发现我打包的<code>js</code>代码上传到服务器后，并没有更新。想到用<code>ng</code>做了代理，可能是<code>ng</code>缓存的问题，就查资料学习了一下<code>http</code>（1.1）缓存的东西。</p><p><img src="http://09imgmini.eastday.com/mobile/20191029/2019102911_fc3f4eb4301b40d58a50935f5cf234c4_3917_cover_mwpm_03201609.jpg" alt=""></p><h4 id="1-相关术语：-约定req为请求头，res响应头，C客户端，S服务端"><a href="#1-相关术语：-约定req为请求头，res响应头，C客户端，S服务端" class="headerlink" title="1.相关术语：(约定req为请求头，res响应头，C客户端，S服务端)"></a>1.相关术语：(约定<code>req</code>为请求头，<code>res</code>响应头，<code>C</code>客户端，<code>S</code>服务端)</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// response Headers</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 04 Dec 2019 09:11:07 GMT</span><br><span class="line">Content-Type: text/css</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Last-Modified: Wed, 04 Dec 2019 09:03:18 GMT</span><br><span class="line">ETag: W/"5de77656-2340"</span><br><span class="line">Expires: Wed, 04 Dec 2019 21:11:06 GMT</span><br><span class="line">Cache-Control: max-age=43200</span><br><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><ul><li><p>Expires ：<code>res</code>中为资源过期时间</p></li><li><p>Last-Modified： <code>res</code>中为资源最近修改时间</p></li><li><p>ETag： <code>res</code>中资源的唯一标识符(hash算法生成)</p></li><li><p>If-Modified-Since ： <code>req</code>中的资源最近修改时间</p></li><li><p>If-None-Match ：<code>req</code>中的资源标识 </p></li><li><p>Cache-Control ： <code>res</code>，<code>req</code>中表示缓存策略</p><ol><li>req中常用指令</li></ol></li></ul><table><thead><tr><th align="center">字段名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">max-age=<seconds></td><td align="center">设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与<code>Expires</code>相反，时间是相对于请求的时间</td></tr><tr><td align="center">max-stale[=<seconds>]</td><td align="center"><code>C</code>可接收一个已经过期的资源。设置一个可选的秒数，不接受超过给定时间的资源</td></tr><tr><td align="center">min-fresh=<seconds></td><td align="center"><code>C</code>希望获取一个能在指定的秒数内保持其最新状态的<code>res</code></td></tr><tr><td align="center">no-cache</td><td align="center">在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证</td></tr><tr><td align="center">no-store</td><td align="center">不缓存有关客户端请求或服务器响应的任何内容</td></tr></tbody></table><p>​        2. res中常用指令(req中重复的不列举，详见MDN)</p><table><thead><tr><th align="center">字段名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容</td></tr><tr><td align="center">private</td><td align="center">表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容</td></tr><tr><td align="center">must-revalidate</td><td align="center">一旦资源过期（比如已经超过<code>max-age</code>），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求</td></tr><tr><td align="center">proxy-revalidate</td><td align="center">与<code>must-revalidate</code>作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略</td></tr><tr><td align="center">s-maxage=<seconds></td><td align="center">覆盖<code>max-age</code>或者<code>Expires</code>头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它</td></tr></tbody></table><p> 其中<code>Last-Modified</code>与<code>If-Modified-Since</code>，<code>ETag</code>与<code>If-None-Match</code>是在每次的res，req中配对使用的。</p><h4 id="2-常见缓存场景：-约定资源为app-js"><a href="#2-常见缓存场景：-约定资源为app-js" class="headerlink" title="2. 常见缓存场景：(约定资源为app.js)"></a>2. 常见缓存场景：(约定资源为app.js)</h4><ol><li><h5 id="Expires："><a href="#Expires：" class="headerlink" title="Expires："></a>Expires：</h5><ul><li><p>过程</p><ol><li><code>C</code>端请求<em>app.js</em>  —-&gt;  <code>S</code>端。</li><li><code>S</code>端响应<em>app.js</em> 与<em>Expires</em>  —-&gt; <code>C</code>端。(<code>C</code>端缓存<em>app.js<em>直到</em>Expires</em>)</li><li>if <strong>1</strong> 发生在<em>Expires</em> 前，会直接从缓存中取, else <strong>2</strong></li><li>重复以上</li></ol></li><li><p>优势</p><p>相比于最原始的不带缓存的请求和相应，优势很明显，会直接从缓存中取，减少请求响应次数</p></li><li><p>缺陷</p><p>如果<em>app.js<em>在</em>Expires</em>  内发生了改变，<code>C</code>端呈现的资源不是最新的。</p></li></ul></li></ol><ol start="2"><li><h5 id="Expires-Last-Modified："><a href="#Expires-Last-Modified：" class="headerlink" title="Expires + Last-Modified："></a>Expires + Last-Modified：</h5><ul><li><p>过程</p><ol><li><p><code>C</code>端请求<em>app.js</em>  —-&gt;  <code>S</code>端</p></li><li><p><code>S</code>端响应<em>app.js</em> 与<em>Expires*， *Last-Modified</em> —-&gt; <code>C</code>端。(<code>C</code>端缓存<em>app.js<em>直到</em>Expires</em>,上次修改时间是 <em>Last-Modified</em>）</p></li><li><ul><li><p>if <strong>1</strong> 发生在<em>Expires</em> 前，会直接从缓存中取(200)。</p></li><li><p>else <code>C</code>端请求<code>S</code>端，带上<em>If-Modified-Since</em>（等于上一次相应的<em>Last-Modified</em>）</p><ul><li><code>S</code>端用<code>req</code>中的<em>If-Modified-Since</em>和<code>res</code>中的 <em>Last-Modified</em>比较。<ul><li>if 一致，响应 <code>C</code>端：你可以继续用本地缓存(304)</li><li>else,<strong>2</strong></li></ul></li></ul></li></ul></li><li><p>重复以上</p></li></ol></li><li><p>优势</p><p>相比与只使用<em>Expires</em>，if <em>app.js</em>发生变化，可以更新缓存，<code>C</code>端呈现内容为最新，else 不会有新的<code>res</code>拉一次资源，直接读缓存</p></li><li><p>缺陷</p><p><em>Last-Modified</em>精确到秒，实际中有很多一秒内会完成很多<code>req</code>和<code>res</code>,问题呼之欲出</p><ul><li>在 <em>Last-Modified</em>内，<em>app.js</em>被修改多次，那么<code>C</code>端还是会从缓存中读，呈现内容不是最新</li><li>假设处于<code>vue-cli</code>开发下，因为某种原因，代码实际没有修改，但CI/CD重复构建打包了文件,<em>app.js<em>变为了</em>app01.js</em>(build.js生成的不同版本hash名称)，但代码只是名称变化，内容并不变化，却重新拉了一次资源</li></ul></li></ul></li></ol><ol start="3"><li><h5 id="Expires-Last-Modified-ETag："><a href="#Expires-Last-Modified-ETag：" class="headerlink" title="Expires + Last-Modified + ETag："></a>Expires + Last-Modified + ETag：</h5><ul><li><p>过程</p><ol><li><p><code>C</code>端请求<em>app.js</em>  —-&gt;  <code>S</code>端</p></li><li><p><code>S</code>端响应<em>app.js</em> 与<em>Expires*， *Last-Modified</em> ,<em>ETag</em>—-&gt; <code>C</code>端。(<code>C</code>端缓存<em>app.js<em>直到</em>Expires</em>,上次修改时间是 <em>Last-Modified</em>,文件标识是<em>ETag</em>）</p></li><li><ul><li><p>if <strong>1</strong> 发生在<em>Expires</em> 前，会直接从缓存中取(200)。</p><ul><li>else <code>C</code>端请求<code>S</code>端，带上<em>If-Modified-Since</em>（等于上一次相应的<em>Last-Modified</em>）和<em>If-None-Match</em>（等于上一次相应的<em>Etag</em>）<ul><li><code>S</code>端用<code>req</code>中的<em>If-None-Match</em>和<code>res</code>中的 <em>Etag</em>比较，<strong>忽略</strong>掉<em>If-Modified-Since</em>和<em>Last-Modified</em>的比较。(如果<em>Etag</em>变化，<em>Last-Modified</em>一定变化，充分条件)</li><li>if 一致，响应 <code>C</code>端：你可以继续用本地缓存(304)</li><li>else,<strong>2</strong></li></ul></li></ul></li></ul></li><li><p>重复以上</p></li></ol></li><li><p>优势</p><p>相较于上一种，使得资源变更的验证更加严格。</p></li><li><p>缺陷</p><p>让我们设想这种情况，我们频繁的修改<em>app.js</em>，打包构建，处于某种原因，我们并不想<code>C</code>端呈现最新的<em>app.js</em>，而是一段时间后再读取最新的，显然还达不到我们的要求</p></li></ul></li></ol><ol start="4"><li><h5 id="Expires-Last-Modified-ETag-Cache-Control-："><a href="#Expires-Last-Modified-ETag-Cache-Control-：" class="headerlink" title="Expires + Last-Modified + ETag + Cache-Control ："></a>Expires + Last-Modified + ETag + Cache-Control ：</h5><ul><li><p>过程</p><ol><li><p><code>C</code>端请求<em>app.js</em>  —-&gt;  <code>S</code>端</p></li><li><p><code>S</code>端响应<em>app.js</em> 与<em>Expires*， *Last-Modified</em> ,<em>ETag<em>， *Cache-Control</em>：max-age=43200 —-&gt; <code>C</code>端。(<code>C</code>端发现带有 <em>Cache-Control</em>：max-age=43200,<strong>忽略</strong>Expires<em>，记住</em>Last-Modified</em> ,<em>ETag</em>）</p></li><li><ul><li><p>if <strong>1</strong> 发生在（<code>req</code>发生的时间+ 12h(43200s)），会直接从缓存中取(200)。</p><ul><li>else <code>C</code>端请求<code>S</code>端，带上<em>If-Modified-Since</em>（等于上一次相应的<em>Last-Modified</em>）和<em>If-None-Match</em>（等于上一次相应的<em>Etag</em>）<ul><li><code>S</code>端用<code>req</code>中的<em>If-None-Match</em>和<code>res</code>中的 <em>Etag</em>比较，<strong>忽略</strong>掉<em>If-Modified-Since</em>和<em>Last-Modified</em>的比较。(如果<em>Etag</em>变化，<em>Last-Modified</em>一定变化，充分条件)</li><li>if 一致，响应 <code>C</code>端：你可以继续用本地缓存(304)</li><li>else,<strong>2</strong></li></ul></li></ul></li></ul></li><li><p>重复以上</p></li></ol></li><li><p>优势</p><p>达到了我们上个方案达不到的效果</p></li><li><p>缺陷？</p><p><code>C</code>端无法主动知道<code>S</code>端上我们请求的资源变化，只能被动的从<code>res</code>中得知，这算缺陷吗？我更多的认为是基于某种安全策略，所以这样规定。</p></li></ul></li></ol><h4 id="3-常见问题：-约定资源为app-js"><a href="#3-常见问题：-约定资源为app-js" class="headerlink" title="3. 常见问题：(约定资源为app.js)"></a>3. 常见问题：(约定资源为app.js)</h4><ol><li><p>如何设置不缓存？</p><ul><li><p>ng配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 还有多种设置方法，举例一种</span><br><span class="line">// 重启ng不一定立即生效</span><br><span class="line">location / &#123;</span><br><span class="line">    access_log /data/nginx/log/xxx.log api;</span><br><span class="line">    </span><br><span class="line">    root /home/www/html;</span><br><span class="line">    </span><br><span class="line">    if ($request_filename ~ .*\.(htm|html)$)</span><br><span class="line">    </span><br><span class="line">     &#123;</span><br><span class="line">            add_header Cache-Control no-cache;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打包<code>html</code>设置<code>meta</code>标签如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache, no-store, must-revalidate"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> meta是用来在HTML文档中模拟HTTP协议的响应头报文。meta 标签用于网页的<head>与</head>中，meta 标签的用处很多。meta 的属性有两种：name和http-equiv。name属性主要用于描述网页，对应于content（网页内容），以便于搜索引擎机器人查找、分类（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）。这其中最重要的是description（站点在搜索引擎上的描述）和keywords（分类关键词），所以应该给每页加一个meta值。</p></blockquote></li></ul></li><li><p>如何清理缓存？</p><ul><li><p>Nginx<code>企业版提供了purger功能，对于社区版Nginx可以考虑使用</code>ngx_cache_purge`（<a href="https://github.com/FRiCKLE/ngx_cache_purge）模块进行清理缓存。（该方法最好限制其访问权限，如只允许内网可以访问或者需要密码才能访问）" target="_blank" rel="noopener">https://github.com/FRiCKLE/ngx_cache_purge）模块进行清理缓存。（该方法最好限制其访问权限，如只允许内网可以访问或者需要密码才能访问）</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location ~ /purge(/.*) &#123;</span><br><span class="line">     </span><br><span class="line"> allow 127.0.0.1;</span><br><span class="line">     </span><br><span class="line"> deny all;</span><br><span class="line">     </span><br><span class="line"> proxy_cache_purge cache$1$is_args$args;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS： 类似宝塔面板这种Ng都自动安装了<code>ngx_cache_purge</code>模块，如何设置详见下方参考。</p></li><li><p>找到缓存文件夹，直接kill。</p></li></ul></li><li><p>如果发生缓存错误，检查的步骤？</p><ol><li><p>检查是否传错文件夹</p><ul><li>打开项目打包后的js，检查<em>app.js</em>文件名。</li><li>打开浏览器控制台<code>Network</code>,勾选<em>js</em>,<code>F5</code>刷新后找到对应的app.xxx.js，比较。如果你发现名称不一样，而且<code>res</code>头部 Last-<em>Modified</em>也不对，那么大概率你传错文件夹了。</li></ul></li><li><p>检查是否正确更新</p><ul><li>记录现阶段 <em>ETag</em></li><li>重新上传后刷新，比较两次 <em>ETag</em>是否一致</li></ul></li><li><p>检查是否正确配置ng等<code>Server</code></p></li><li><p>梳理构建部署步骤，逐步检查(只能帮你到这啦)</p></li></ol></li></ol><p>只是<code>http</code>（1.1）的部分常见场景，目前到这里已经足够，咱得一步一步来，切勿囫囵吞枣~</p><p>思考有限，难免出现疏漏，欢迎诸位指出，集思广益。</p><h6 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h6><ol><li>《面试精选之http缓存》 <a href="https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-2</a></li><li>《MDN - Cache-Control》<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</a></li><li>《浅谈http中的Cache-Control》<a href="https://blog.csdn.net/u012375924/article/details/82806617" target="_blank" rel="noopener">https://blog.csdn.net/u012375924/article/details/82806617</a></li><li>《Nginx缓存配置及nginx ngx_cache_purge模块的使用》<a href="https://www.cnblogs.com/Eivll0m/p/4921829.html" target="_blank" rel="noopener">https://www.cnblogs.com/Eivll0m/p/4921829.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ESmodule</title>
      <link href="/2019/05/28/ESmodule/"/>
      <url>/2019/05/28/ESmodule/</url>
      
        <content type="html"><![CDATA[<p>ESmodule的标准化完成一定会掀起波澜~</p><a id="more"></a><h2 id="图说-ES-Modules（转载译文）"><a href="#图说-ES-Modules（转载译文）" class="headerlink" title="图说 ES Modules（转载译文）"></a>图说 ES Modules（转载译文）</h2><p>原文：<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noopener">ES modules: A cartoon deep-dive, Lin Clark</a></p><p>ES modules（ESM） 是 JavaScript 官方的标准化模块系统。<br>然而，它在标准化的道路上已经花费了近 10 年的时间。</p><p>可喜的是，标准化之路马上就要完成了。等到 2018 年 5 月 Firefox 60 发布之后，所有的主流浏览器就都支持 ESM 了。同时，Node 模块工作小组也正在为 Node.js 添加 ESM 支持。<a href="https://www.youtube.com/watch?v=qR_b5gajwug" target="_blank" rel="noopener">为 WebAssembly 提供 ESM 集成</a>的工作也正在如火如荼的进行。</p><p>许多 JS 开发者都知道，对 ESM 的讨论从开始至今一直都没停过。但是很少有人真正理解 ESM 的工作原理。</p><p>今天，让我们来梳理梳理 ESM 到底解决了什么问题，以及它跟其他模块系统之间有什么区别。</p><h4 id="为何要模块化"><a href="#为何要模块化" class="headerlink" title="为何要模块化"></a>为何要模块化</h4><p>说到 JS 编程，其实说的就是<strong>如何管理变量</strong>。<br>编程的过程都是关于如何给变量赋值，要么直接赋值给变量，要么是把两个变量结合起来然后再把结果赋值给另一个变量</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/01_variables-500x178.png" alt="Code showing variables being manipulated"></p><p>因为大部分代码都是关于改变变量的，所以如何组织这些变量就直接影响了编码质量，以及维护它们的成本。</p><p>如果代码中仅有少量的变量，那么组织起来其实是很简单的。<br>JS 本身就提供了一种方式帮你组织变量，称为<strong>函数作用域</strong>。因为函数作用域的缘故，一个函数无法访问另一个函数中定义的变量。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/02_module_scope_01-500x292.png" alt="Two function scopes with one trying to reach into another but failing"></p><p>这种方式是很有效的。它使得我们在写一个函数的时候，只需要考虑当前函数，而不必担心其它函数可能会改变当前函数的变量。<br>不过，它也有不好的地方。它会让我们很难在不同函数之间<strong>共享变量</strong>。</p><p>如果我们想跟当前函数以外的函数共享变量要怎么办呢？一种通用的做法是把要共享的变量提升到上一层作用域，比如全局作用域。</p><p>在 jQuery 时代这种提升做法相当普遍。在我们加载任何 jQuery 插件之前，我们必须确保 jQuery 已经存在于全局作用域。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/02_module_scope_02-500x450.png" alt="Two function scopes in a global, with one putting jQuery into the global"></p><p>这种做法也确实行之有效，但是也带来了令人烦恼的影响。<br>首先，所有的 <code>&lt;script&gt;</code> 必须<strong>以正确的顺序排列</strong>，开发者必须非常谨慎地确保没有任何一个脚本排列错误。</p><p>如果排列错了，那么在运行过程中，应用将会抛出错误。当函数在全局作用域寻找 jQuery 变量时，如果没有找到，那么它将会抛出异常错误，并且停止继续运行。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/02_module_scope_03-500x450.png" alt="The top function scope has been removed and now the second function scope can’t find jQuery on the global"></p><p>这同时也使得代码的后期维护变得困难。<br>它会使得移除旧代码或者脚本标签变得充满不确定性。你根本不知道移除它会带来什么影响。<strong>代码之间的依赖是不透明的</strong>。任何函数都可能依赖全局作用域中的任何变量，以至于你也不知道哪个函数依赖哪个脚本。</p><p>其次，由于变量存在于全局作用域，所以<strong>任何代码都可以改变它</strong>。<br>恶意的代码可能会故意改变全局变量，从而让你的代码做出危险行为。又或者，代码可能不是恶意的，但是却无意地改变了你期望的变量。、</p><h4 id="模块化的作用"><a href="#模块化的作用" class="headerlink" title="模块化的作用"></a>模块化的作用</h4><p><strong>模块化为你提供了一种更好的方式来组织变量和函数</strong>。你可以把相关的变量和函数放在一起组成一个模块。</p><p>这种组织方式会把函数和变量放在<strong>模块作用域</strong>中。模块中的函数可以通过模块作用域来共享变量。</p><p>不过，与函数作用域不同的是，模块作用域还提供了一种暴露变量给其他模块使用的方式。模块可以明确地指定哪些变量、类或函数对外暴露。</p><p>对外暴露的过程称为<strong>导出</strong>。一旦导出，其他模块就可以明确地声称它们依赖这些导出的变量、类或者函数。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/02_module_scope_04-500x450.png" alt="Two module scopes, with one reaching into the other to grab an export"></p><p>因为这是一种明确的关系，所以你可以很简单地辨别哪些代码能移除，哪些不能移除。</p><p>拥有了在模块之间导出和导入变量的能力之后，你就可以把代码分割成更小的、可以独立运行地代码块了。然后，你就可以像搭乐高积木一样，基于这些代码块，创建所有不同类型的应用。</p><p>由于模块化是非常有用的，所以历史上曾经多次尝试为 JS 添加模块化的功能。不过截止到目前，真正得到广泛使用的只有两个模块系统。<br>一个是 Node.js 使用的 CommonJS （CJS）；另一个是 JS 规范的新模块系统 EcmaScript modules（ESM），Node.js 也正在添加对 ESM 的支持。</p><p>下面就让我们来深入理解下这个新的模块系统是如何工作的。</p><h4 id="ESM-原理"><a href="#ESM-原理" class="headerlink" title="ESM 原理"></a>ESM 原理</h4><p>当你在使用模块进行开发时，其实是在构建一张<strong>依赖关系图</strong>。不同模块之间的连线就代表了代码中的导入语句。</p><p>正是这些导入语句告诉浏览器或者 Node 该去加载哪些代码。<br>我们要做的是为依赖关系图指定一个<strong>入口文件</strong>。从这个入口文件开始，浏览器或者 Node 就会顺着导入语句找出所依赖的其他代码文件。</p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/04_import_graph-500x291.png" alt="A module with two dependencies. The top module is the entry. The other two are related using import statements"  /><p>但是呢，浏览器并不能直接使用这些代码文件。它需要解析所有的文件，并把它们变成一种称为<strong>模块记录</strong>（Module Record）的数据结构。只有这样，它才知道代码文件中到底发生了什么。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/05_module_record-500x287.png" alt="A module record with various fields, including RequestedModules and ImportEntries"></p><p>解析之后，还需要把模块记录变成一个<strong>模块实例</strong>。模块实例会把<strong>代码和状态</strong>结合起来。</p><p>所谓代码，基本上是一组指令集合。它就像是制作某样东西的配方，指导你该如何制作。<br>但是它本身并不能让你完成制作。你还需要一些原料，这样才可以按照这些指令完成制作。</p><p>所谓状态，它就是原料。具体点，状态是变量在任何时候的真实值。<br>当然，变量实际上就是内存地址的别名，内存才是正在存储值的地方。</p><p>所以，可以看出，<strong>模块实例中代码和状态的结合，就是指令集和变量值的结合</strong>。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/06_module_instance-500x372.png" alt="A module instance combining code and state"></p><p>对于模块而言，我们真正需要的是模块实例。<br>模块加载会从入口文件开始，最终生成完整的模块实例关系图。</p><p>对于 ESM ，这个过程包含三个阶段：</p><ol><li><strong>构建</strong>：查找，下载，然后把所有文件解析成模块记录。</li><li><strong>实例化</strong>：为所有模块分配内存空间（此刻还没有填充值），然后依照导出、导入语句把模块指向对应的内存地址。这个过程称为<strong>链接</strong>（Linking）。</li><li><strong>运行</strong>：运行代码，从而把内存空间填充为真实值。</li></ol><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_3_phases-500x184.png" alt="The three phases. Construction goes from a single JS file to multiple module records. Instantiation links those records. Evaluation executes the code."></p><p>大家都说 ESM 是异步的。<br>因为它把整个过程分为了三个不同的阶段：加载、实例化和运行，并且这三个阶段是可以独立进行的。</p><p>这意味着，ESM 规范确实引入了一种异步方式，且这种异步方式在 CJS 中是没有的。<br>后面我们会详细说到为什么，然而在 CJS 中，一个模块及其依赖的加载、实例化和运行是一起顺序执行的，中间没有任何间断。</p><p>不过，这三个阶段本身是没必要异步化。它们可以同步执行，这取决于它是由谁来加载的。因为 ESM 标准并没有明确规范所有相关内容。实际上，这些工作分为两部分，并且分别是由不同的标准所规范的。</p><p>其中，<a href="https://tc39.github.io/ecma262/#sec-modules" target="_blank" rel="noopener">ESM 标准</a> 规范了如何把文件解析为模块记录，如何实例化和如何运行模块。但是它没有规范如何获取文件。</p><p>文件是由<strong>加载器</strong>来提取的，而加载器由另一个不同的标准所规范。对于浏览器来说，这个标准就是 <a href="https://html.spec.whatwg.org/#fetch-a-module-script-tree" target="_blank" rel="noopener">HTML</a>。但是你还可以根据所使用的平台使用不同的加载器。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/07_loader_vs_es-500x286.png" alt="Two cartoon figures. One represents the spec that says how to load modules (i.e., the HTML spec). The other represents the ES module spec."></p><p>加载器也同时控制着如何加载模块。它会调用 ESM 的方法，包括 <code>ParseModule</code>、<code>Module.Instantiate</code> 和 <code>Module.Evaluate</code> 。它就像是控制着 JS 引擎的木偶。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/08_loader_as_puppeteer-500x330.png" alt="The loader figure acting as a puppeteer to the ES module spec figure."></p><p>下面我们将更加详细地说明每一步。</p><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><p>对于每个模块，在构建阶段会做三个处理：</p><ol><li>确定要从哪里下载包含该模块的文件，也称为模块定位（Module Resolution）</li><li>提取文件，通过从 URL 下载或者从文件系统加载</li><li>解析文件为模块记录</li></ol><h6 id="1-下载模块"><a href="#1-下载模块" class="headerlink" title="1.下载模块"></a>1.下载模块</h6><p>加载器负责定位文件并且提取。首先，它需要找到入口文件。在 HTML 中，你可以通过 <code>&lt;script&gt;</code> 标签来告诉加载器。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/08_script_entry-500x188.png" alt="A script tag with the type=module attribute and a src URL. The src URL has a file coming from it which is the entry"></p><p>但是，加载器要如何定位 <code>main.js</code> 直接依赖的模块呢？<br>这个时候导入语句就派上用场了。导入语句中有一部分称为<strong>模块定位符</strong>（Module Specifier），它会告诉加载器去哪定位模块。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/09_module_specifier-500x105.png" alt="An import statement with the URL at the end labeled as the module specifier"></p><p>对于模块定位符，有一点要注意的是：它们在浏览器和 Node 中会有不同的处理。每个平台都有自己的一套方式来解析模块定位符。这些方式称为<strong>模块定位算法</strong>，不同的平台会使用不同的模块定位算法。<br>当前，一些在 Node 中能工作模块定位符并不能在浏览器中工作，但是已经有一项工作<a href="https://github.com/domenic/package-name-maps" target="_blank" rel="noopener">正在解决这个问题</a>。</p><p>在这个问题被解决之前，浏览器只接受 URL 作为模块定位符。<br>它们会从 URL 加载模块文件。但是，这并不是在整个关系图上同时发生的。因为在解析完这个模块之前，你根本不知道它依赖哪些模块。而且在它下载完成之前，你也无法解析它。</p><p>这就意味着，我们必须一层层遍历依赖树，先解析文件，然后找出依赖，最后又定位并加载这些依赖，如此往复。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/10_construction-500x302.png" alt="A diagram that shows one file being fetched and then parsed, and then two more files being fetched and then parsed"></p><p>如果主线程正在等待这些模块文件下载完成，许多其他任务将会堆积在任务队列中，造成阻塞。这是因为在浏览器中，下载会耗费大量的时间。</p><p><img src="https://segmentfault.com/img/bV78AB?w=500&h=270" alt="11_latency-500x270.png"></p><p>而阻塞主线程会使得应用变得卡顿，影响用户体验。这是 ESM 标准把算法分成多个阶段的原因之一。将构建划分为一个独立阶段后，浏览器可以在进入同步的实例化过程之前下载文件然后理解模块关系图。</p><p>ESM 和 CJS 之间最主要的区别之一就是，ESM 把算法化为为多个阶段。</p><p>CJS 使用不同的算法是因为它从文件系统加载文件，这耗费的时间远远小于从网络上下载。因此 Node 在加载文件的时候可以阻塞主线程，而不造成太大影响。而且既然文件已经加载完成了，那么它就可以直接进行实例化和运行。所以在 CJS 中实例化和运行并不是两个相互独立的阶段。<br>这也意味着，你可以在返回模块实例之前，顺着整颗依赖树去逐一加载、实例化和运行每一个依赖。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/12_cjs_require-500x298.png" alt="A diagram showing a Node module evaluating up to a require statement, and then Node going to synchronously load and evaluate the module and any of its dependencies"></p><p>CJS 的方式对 ESM 也有一些启发，这个后面会解释。<br>其中一个就是，在 Node 的 CJS 中，你可以在模块定位符中使用变量。因为已经执行了 <code>require</code> 之前的代码，所以模块定位符中的变量此刻是有值的，这样就可以进行模块定位的处理了。</p><p>但是对于 ESM，在运行任何代码之前，你首先需要建立整个模块依赖的关系图。也就是说，<strong>建立关系图时变量是还没有值的</strong>，因为代码都还没运行。</p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/13_static_import-500x146.png" alt="A require statement which uses a variable is fine. An import statement that uses a variable is not."  /><p>不过呢，有时候我们确实需要在模块定位符中使用变量。比如，你可能需要根据当前的状况加载不同的依赖。</p><p>为了在 ESM 中实现这种方式，人们已经提出了一个<strong>动态导入</strong>提案。该提案允许你可以使用类似 <code>import(\</code>${path}/foo.js<code>)</code>的导入语句。</p><p>这种方式实际上是把使用 <code>import()</code> 加载的文件当成了一个入口文件。动态导入的模块会开启一个全新的独立依赖关系树。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/14dynamic_import_graph-500x389.png" alt="Two module graphs with a dependency between them, labeled with a dynamic import statement"></p><p>不过有一点要注意的是，这两棵依赖关系树共有的模块会共享同一个模块实例。这是因为加载器会缓存模块实例。在特定的全局作用域中，每个模块只会有一个与之对应的模块实例。</p><p>这种方式有助于提高 JS 引擎的性能。例如，一个模块文件只会被下载一次，即使有多个模块依赖它。这也是缓存模块的原因之一，后面说到运行的时候会介绍另一个原因。</p><p>加载器使用<strong>模块映射</strong>（Module Map）来管理缓存。每个全局作用域都在一个单独的模块映射中跟踪其模块。</p><p>当加载器要从一个 URL 加载文件时，它会把 URL 记录到模块映射中，并把它标记为正在下载的文件。然后它会发出这个文件请求并继续开始获取下一个文件。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/15_module_map-500x170.png" alt="The loader figure filling in a Module Map chart, with the URL of the main module on the left and the word fetching being filled in on the right"></p><p>当其他模块也依赖这个文件的时候会发生什么呢？加载器会查找模块映射中的每一个 URL 。如果发现 URL 的状态为正在下载，则会跳过该 URL ，然后开始下一个依赖的处理。</p><p>不过，模块映射的作用并不仅仅是记录哪些文件已经下载。下面我们将会看到，模块映射也可以作为模块的缓存。</p><h6 id="2-解析模块"><a href="#2-解析模块" class="headerlink" title="2.解析模块"></a>2.解析模块</h6><p>至此，我们已经拿到了模块文件，我们需要把它解析为模块记录。<br>这有助于浏览器理解模块的不同部分。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/25_file_to_module_record-500x199.png" alt="Diagram showing main.js file being parsed into a module record"></p><p>一旦模块记录创建完成，它就会被记录在模块映射中。所以，后续任何时候再次请求这个模块时，加载器就可以直接从模块映射中获取该模块。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/25_module_map-500x239.png" alt="The “fetching” placeholders in the module map chart being filled in with module records"></p><p>解析过程中有一个看似微不足道的细节，但是实际造成的影响却很大。那就是所有的模块都按照<strong>严格模式</strong>来解析的。<br>也还有其他的小细节，比如，关键字 <code>await</code> 在模块的最顶层是保留字， <code>this</code> 的值为 <code>undefinded</code>。</p><p>这种不同的解析方式称为<strong>解析目标</strong>（Parse Goal）。如果按照不同的解析目标来解析相同的文件，会得到不同的结果。因此，在解析文件之前，必须清楚地知道所解析的文件类型是什么，不管它是不是一个模块文件。</p><p>在浏览器中，知道文件类型是很简单的。只需要在 <code>&lt;script&gt;</code> 脚本中添加 <code>type=&quot;module&quot;</code> 属性即可。这告诉浏览器这个文件需要被解析为一个模块。而且，因为只有模块才能被导入，所以浏览器以此推测所有的导入也都是模块文件。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/26_parse_goal-500x311.png" alt="The loader determining that main.js is a module because the type attribute on the script tag says so, and counter.js must be a module because it’s imported"></p><p>不过在 Node 中，我们并不使用 HTML 标签，所以也没办法通过 <code>type</code> 属性来辨别。社区提出一种解决办法是使用 <code>.mjs</code> 拓展名。使用该拓展名会告诉 Node 说“这是个模块文件”。你会看到大家正在讨论把这个作为解析目标。不过讨论仍在继续，所以目前仍不明确 Node 社区最终会采用哪种方式。</p><p>无论最终使用哪种方式，加载器都会决定是否把一个文件作为模块来解析。如果是模块，而且包含导入语句，那它会重新开始处理直至所有的文件都已提取和解析。</p><p>到这里，构建阶段差不多就完成了。在加载过程处理完成后，你已经从最开始只有一个入口文件，到现在得到了一堆模块记录。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/27_construction-500x406.png" alt="A JS file on the left, with 3 parsed module records on the right as a result of the construction phase"></p><p>下一步会实例化这些模块并且把所有的实例链接起来。</p><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5><p>正如前文所述，一个模块实例结合了代码和状态。状态存储在内存中，所以实例化的过程就是把所有值写入内存的过程。</p><p>首先，JS 引擎会创建一个<strong>模块环境记录</strong>（Module Environment Record）。它管理着模块记录的所有变量。然后，引擎会找出多有导出在内存中的地址。模块环境记录会跟踪每个导出对应于哪个内存地址。</p><p>这些内存地址此时还没有值，只有等到运行后它们才会被填充上实际值。有一点要注意，所有导出的函数声明都在这个阶段初始化，这会使得后面的运行阶段变得更加简单。</p><p>为了实例化模块关系图，引擎会采用<strong>深度优先的后序遍历方式</strong>。<br>即，它会顺着关系图到达最底端没有任何依赖的模块，然后设置它们的导出。</p><p><img src="https://hacks.mozilla.org/files/2018/03/30_live_bindings_04-500x206.png" alt="30_live_bindings_01.png"></p><p>最终，引擎会把模块下的所有依赖导出链接到当前模块。然后回到上一层把模块的导入链接起来。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/30_live_bindings_02-500x206.png" alt="Same diagram as above, but with the module environment record for main.js now having its imports linked up to the exports from the other two modules."></p><p>这个过程跟 CJS 是不同的。在 CJS 中，整个导出对象在导出时都是<strong>值拷贝</strong>。<br>即，所有的导出值都是拷贝值，而不是引用。<br>所以，如果导出模块内导出的值改变了，导入模块中导入的值也不会改变。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/31_cjs_variable-500x113.png" alt="Memory in the middle with an exporting common JS module pointing to one memory location, then the value being copied to another and the importing JS module pointing to the new location"></p><p>相反，ESM 则使用称为<strong>实时绑定</strong>（Live Binding）的方式。导出和导入的模块都指向相同的内存地址（即<strong>值引用</strong>）。所以，当导出模块内导出的值改变后，导入模块中的值也实时改变了。</p><p>模块导出的值在任何时候都可以能发生改变，但是导入模块却不能改变它所导入的值，因为它是<strong>只读</strong>的。<br>举例来说，如果一个模块导入了一个对象，那么它只能改变该对象的属性，而不能改变对象本身。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/30_live_bindings_04-500x206.png" alt="The exporting module changing the value in memory. The importing module also tries but fails."></p><p>ESM 采用这种实时绑定的原因是，引擎可以在不运行任何模块代码的情况下完成链接。后面会解释到，这对解决运行阶段的循环依赖问题也是有帮助的。</p><p>实例化阶段完成后，我们得到了所有模块实例，以及已完成链接的导入、导出值。</p><p>现在我们可以开始运行代码并且往内存空间内填充值了。</p><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><p>最后一步是往已申请好的内存空间中填入真实值。JS 引擎通过运行顶层代码（函数外的代码）来完成填充。</p><p>除了填充值以外，运行代码也会引发一些副作用（Side Effect）。例如，一个模块可能会向服务器发起请求。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/40_top_level_code-500x146.png" alt="A module will code outside of functions, labeled top level code"></p><p>因为这些潜在副作用的存在，所以<strong>模块代码只能运行一次</strong>。<br>前面我们看到，实例化阶段中发生的链接可以多次进行，并且每次的结果都一样。但是，如果运行阶段进行多次的话，则可能会每次都得到不一样的结果。</p><p>这正是为什么会使用模块映射的原因之一。模块映射会以 URL 为索引来缓存模块，以确保每个模块<strong>只有一个</strong>模块记录。这保证了每个模块只会运行一次。跟实例化一样，运行阶段也采用深度优先的后序遍历方式。</p><p>那对于前面谈到的循环依赖会怎么处理呢？</p><p>循环依赖会使得依赖关系图中出现一个依赖环，即你依赖我，我也依赖你。通常来说，这个环会非常大。不过，为了解释好这个问题，这里我们举例一个简单的循环依赖。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/41_cjs_cycle-500x224.png" alt="A complex module graph with a 4 module cycle on the left. A simple 2 module cycle on the right."></p><p><code>counter</code> 模块会试图去访问导出对象的 <code>message</code> 。不过，由于 <code>main</code> 模块中还没运行到 <code>message</code> 处，所以此时得到的 <code>message</code> 为 <code>undefined</code>。JS 引擎会为本地变量分配空间并把值设为 <code>undefined</code> 。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/42_cjs_variable_2-500x113.png" alt="Memory in the middle with no connection between main.js and memory, but an importing link from counter.js to a memory location which has undefined"></p><p>运行阶段继续往下执行，直到 <code>counter</code> 模块顶层代码的末尾处。我们想知道，当 <code>counter</code> 模块运行结束后，<code>message</code> 是否会得到真实值，所以我们设置了一个超时定时器。之后运行阶段便返回到 <code>main.js</code> 中。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/43_cjs_cycle-500x224.png" alt="counter.js returning control to main.js, which finishes evaluating"></p><p>这时，<code>message</code> 将会被初始化并添加到内存中。但是这个 <code>message</code> 与 <code>counter</code> 模块中的 <code>message</code> 之间并没有任何关联关系，所以 <code>counter</code> 模块中的 <code>message</code> 仍然为 <code>undefined</code>。</p><p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2018/03/44_cjs_variable_2-500x216.png" alt="main.js getting its export connection to memory and filling in the correct value, but counter.js still pointing to the other memory location with undefined in it"></p><p>如果导出值采用的是实时绑定方式，那么 <code>counter</code> 模块最终会得到真实的 <code>message</code> 值。当超时定时器开始计时时，<code>main.js</code> 的运行就已经完成并设置了 <code>message</code> 值。</p><p>支持循环依赖是 ESM 设计之初就考虑到的一大原因。也正是这种分段设计使其成为可能。</p><h4 id="ESM-的当前状态"><a href="#ESM-的当前状态" class="headerlink" title="ESM 的当前状态"></a>ESM 的当前状态</h4><p>等到 2018 年 5 月 Firefox 60 发布后，所有的主流浏览器就都默认支持 ESM 了。Node 也正在添加 ESM 支持，为此还成立了<a href="https://github.com/nodejs/modules" target="_blank" rel="noopener">工作小组</a>来专门研究 CJS 和 ESM 之间的兼容性问题。</p><p>所以，在未来你可以直接在 <code>&lt;script&gt;</code> 标签中使用 <code>type=&quot;module&quot;</code>，并且在代码中使用 <code>import</code> 和 <code>export</code> 。<br>同时，更多的模块功能也正在研究中。<br>比如<a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">动态导入提案</a>已经处于 Stage 3 状态；<a href="https://github.com/tc39/proposal-import-meta" target="_blank" rel="noopener"><code>import.meta</code></a>也被提出以便 Node.js 对 ESM 的支持；<a href="https://github.com/domenic/package-name-maps" target="_blank" rel="noopener">模块定位提案</a> 也致力于解决浏览器和 Node.js 之间的差异。</p><p>相信在不久的未来，跟模块一起玩耍将会变成一件更加愉快的事！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ESmodule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Event loop</title>
      <link href="/2019/05/19/Event%20loop/"/>
      <url>/2019/05/19/Event%20loop/</url>
      
        <content type="html"><![CDATA[<p>Event loop的粗浅认识</p><a id="more"></a><h5 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h5><p>js是单线程的。其事件轮询由：同步任务，异步任务，macrotask（宏任务），microtask （微任务）组成。其执行过程如下：</p><ul><li>同步任务： 主线程上的任务，前一个完成后后一个执行。</li><li>异步任务：不进入主线程，进入任务队列（task queue)中执行，等于macrotask。</li><li>macrotask：任务队列的主体，同一个队列内的“先进先出”执行。不同的队列之间“先进后出”执行。</li><li>microtask ：总在任务队列末尾执行，有新的microtask 继续加在末尾执行。</li></ul><p>执行过程：1.同步任务执行 2.  任务按队列依次执行 3.微任务按队列依次执行 4.重复1-3</p><h5 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h5><p>对于<code>宏任务</code>和<code>微任务</code>的概念的理解，一开始确实是不太清楚的。</p><p>先来说说<code>宏任务</code>，我们不妨这样来看，既然它是<strong>任务队列的主体</strong>，那么它一定由一个或者多个任务构成。抛开<code>JS</code>,[宏]这个字本身就不是单一的，在<code>CS</code>中的[宏]就是<strong>批量处理</strong>的意思。</p><p>对于稍微了解过一点点<code>c</code>的人来说，应该都不陌生，辟如：编译预处理命令，宏定义等等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译预处理命令</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>我将[编译预处理命令]（在编译之前进行的处理）就看做是[宏任务]，就是你写了一系列的前置操作，在后面的代码执行之前，这些宏任务全部需要执行完毕~</p><p>稍微生活化一点点，比如那个中国互联网起步的时候，我的同学之间，喜欢用QQ等级作为谈资。所以我让我的<strong>电脑开机后自动登录QQ</strong>；或者现今5G来临之前，男生多半玩过的MOBA类游戏，就拿LOL中的瞎子<strong>摸眼R闪</strong>这种操作，你完全可以选一个拥有宏命令的鼠标，设置测试后一键完成这种“用双手成就你的梦想”等秀的飞起的操作；还有诸如乔碧萝之类的人士，开启直播推流之前，对自己<strong>直播效果的优化</strong>。这些都是所谓<strong>宏任务</strong>。</p><p>至于<code>微任务</code>，相信聪明可爱的你一定能够举一反一，找到自己对其充分的理解~:smile:</p><p>常见的宏任务和微任务：</p><p><strong>宏任务</strong>：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>requestAnimationFrame</li><li>I/O</li><li>UI rendering</li></ul><p><strong>微任务</strong>：</p><ul><li>process.nextTick</li><li>Promises</li><li>Object.observe</li><li>MutationObserver</li></ul><p><strong>执行图例</strong></p><p>希望执行帧动画能让你对整个过程的理解清晰许多</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/18/16860ae5ad02f993?imageslim" alt=""></p><h5 id="小练习1"><a href="#小练习1" class="headerlink" title="小练习1"></a><strong>小练习1</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器输出顺序：</span></span><br><span class="line"><span class="comment">//script start</span></span><br><span class="line"><span class="comment">//script end</span></span><br><span class="line"><span class="comment">//promise1</span></span><br><span class="line"><span class="comment">//promise2</span></span><br><span class="line"><span class="comment">//setTimeout</span></span><br></pre></td></tr></table></figure><h5 id="小练习2"><a href="#小练习2" class="headerlink" title="小练习2"></a><strong>小练习2</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>) </span><br><span class="line">&#125;,<span class="number">0</span>)  </span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// 浏览器输出顺序：</span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">//async1 start</span></span><br><span class="line"><span class="comment">//async2</span></span><br><span class="line"><span class="comment">//promise1</span></span><br><span class="line"><span class="comment">//script end</span></span><br><span class="line"><span class="comment">//async1 end</span></span><br><span class="line"><span class="comment">//promise2</span></span><br><span class="line"><span class="comment">//setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>await会将之后的代码抛入下一个执行队列，代码上的表现就是执行完await的会跳出函数体执行其他的同步任务。</li><li>setTimeout的回调函数会进入下一个同步任务队列中。</li><li>如果输出顺序不一致，是因为各大浏览器对异步的处理是不一样的，没什么奇怪的。</li><li>另外，node环境输出顺序也有很大差异。</li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> javascript event loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css tips</title>
      <link href="/2019/04/11/CSS-tips/"/>
      <url>/2019/04/11/CSS-tips/</url>
      
        <content type="html"><![CDATA[<p>如何进行命名是一件看上去微不足道但其实对代码整洁度破坏很大的事情，《代码整洁之道》建议的第一篇就是如何进行好的命名</p><a id="more"></a><h2 id="css杂项-命名，书写顺序，调试"><a href="#css杂项-命名，书写顺序，调试" class="headerlink" title="css杂项(命名，书写顺序，调试)"></a>css杂项(命名，书写顺序，调试)</h2><ul><li><h3 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h3><p><code>BEM</code>是模块（Block）、元素（Element）、修饰符（Modifier）的简写。</p><p><code>BEM</code> 是一种组件架构的命名方法，它的基本思想是将<code>Html</code>元素划分成独立的组件，然后用简单的规则链接起来，开发时不用担心不会取名字了，同时后期维护和多人协作上好处大大的。</p><p>其命名规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Block - 模块，名字的单词之间用 &#96;-&#96; 符号连接</span><br><span class="line">Element - 元素，模块中的子元素，用 &#96;__&#96; 符号连接</span><br><span class="line">Modifier - 修饰符，表示父元素或子元素的其他形态，用 &#96;--&#96; 符号连接</span><br></pre></td></tr></table></figure><ul><li><p>优势</p><p>在没用 BEM 之前，我们可能会这样组织 CSS 类名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Common命名的 Search Bar 模块 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"search-bar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"input"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- / input 输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- / button 搜索按钮 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- E Search Bar 模块 --&gt;</span></span><br></pre></td></tr></table></figure><p>  用 BEM 命名重写之后：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- BEM命名的 Search Bar 模块 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"search-bar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"search-form__input"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- / input 输入框子元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"search-form__button"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- / button 搜索按钮子元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- E Search Bar 模块 --&gt;</span></span><br></pre></td></tr></table></figure><p>有对比高下立判~ 通常面试问的语义化(作用与实践)，这样就达到了，最终目的是减少代码阅读成本。</p><ul><li><p>缺陷</p><p>优点也是缺点，当<code>HTML</code>元素层级繁多时，会使得命名越来越长，那样的话，文件会变得臃肿不堪，反而违背了我们的初心。乱七八糟的<code>HTML</code>谁会愿意看？</p></li></ul></li></ul></li></ul><ul><li><h3 id="姓氏命名法"><a href="#姓氏命名法" class="headerlink" title="姓氏命名法"></a>姓氏命名法</h3><p>为了进一步简化 CSS 的命名，采用<strong>凹凸实验室团队</strong>推广的姓氏命名法。 感谢凹凸大大们~</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161f8ff1517a16c9?w=1442&h=682&f=jpeg&s=61130" alt="img"></p></li></ul><p>  我们并不需要把每个元素的全部名称带上来表明主次关系。就像这份族谱一样，他的孩子只需要保留「贾」姓就可以了，名字是可以随便取的。</p><p>  关联上 BEM 命名方法，姓氏命名法中的 Block 就是「姓」，Element 就是「名字」，而 Modifier 就表示这个人的某种状态，例如：「范 - - 冰冰 - - 很美」。这样就达到了取其精华，去其糟粕的作用。</p><pre><code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- am = app_market --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am_answer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am_secheader"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am_answer_list"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am_answer_item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am_answer_itop"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"am_answer_imid"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"am_answer_ibtn"</span>&gt;</span>去围观<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></code></pre><p>   将 <strong>app_market</strong> 可以看成是「复姓」，将两个单词的首字母结合在一起形成一个新的「单姓」，如 <strong>am</strong> ；将item中的子项类名直接简写为「ixx」，如：<strong>itop</strong>。追求便利的副作用之一是牺牲了一点代码的可读性。但多半项目上的文档可以注明命名方法和其他书写规范，如果团队有约束，那一定是极佳的实践。</p><p>  <strong>小结</strong></p><ul><li><p>ClassName 的命名应该尽量精短、明确，以英文单词命名，且全部字母为小写，避免意义不明的缩写</p></li><li><p>单词之间统一使用下划线 <code>_</code> 或 <code>-</code> 连接</p></li><li><p>定义样式模块，提高代码的可复用性</p></li></ul><h2 id="CSS推荐书写"><a href="#CSS推荐书写" class="headerlink" title="CSS推荐书写"></a>CSS推荐书写</h2><ul><li><p>推荐书写顺序</p><ol><li>位置属性(position, top, right, z-index, display, float等)</li><li>大小(width, height, padding, margin)</li><li>文字系列(font, line-height, letter-spacing, color- text-align等)</li><li>背景(background, border等)</li><li>其他(animation, transition等) </li></ol></li><li><p>why this ?</p><p>主要从浏览器的渲染机制方面来考虑，减少重绘与重排,提高性能。</p><p>良好的习惯会使得你编写<code>css</code>代码时也更加清晰</p></li></ul><hr><p>拿到文件后浏览器的渲染流程为：</p><p><img src="https://img2018.cnblogs.com/blog/612653/201905/612653-20190528155836708-1330513625.png" alt=""></p><p>（1）浏览器解析html构建dom树，解析css构建cssom树即css rule tree：将html和css都解析成树形的数据结构； dom树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p><p>（2）构建render树：DOM树和cssom树合并之后形成render树。为了构建渲染树，浏览器大体完成了下列工作：从DOM树的根节点开始遍历每个可见节点。对于每个可见节点，为其找到适配的CSSOM规则并应用它们。发射可见节点，连同其内容和计算的样式。渲染树中包含了屏幕上所有可见内容及其样式信息。</p><p>（3）布局render树：有了render树，浏览器已经知道网页中有哪些节点，各个节点的css定义以及它们的从属关系，接着就开始布局，计算出每个节点在屏幕中的位置和大小。(html采用了一种流式布局的布局模型，从上到下，从左到右顺序布局，布局的起点是从render树的根节点开始的，对应dom树的document节点，其初始位置为(0,0)，详细的布局过程为：每个renderer的宽度由父节点的renderer确定。父节点遍历子节点，确定子节点的位置(x,y)，调用子节点的layout方法确定其高度，父节点根据子节点的height, margin, padding确定自身的高度)。</p><p>（4）渲染render树：浏览器已经知道啦哪些节点要显示，每个节点的css属性是什么，每个节点在屏幕中的位置是哪里。就进入啦最后一步，按照计算出来的规则，通过显卡把内容画在屏幕上。</p><p>  DOM 的变化影响了元素的几何属性（宽和高）- 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）” </p><hr><p> 好了好了，照本宣科的东西终于没了，当然渲染过程没这么简单，这里也是借鉴一下啦。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>; </span><br><span class="line"><span class="selector-tag">height</span>: 100<span class="selector-tag">px</span>; </span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">red</span>; </span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br></pre></td></tr></table></figure><p>当浏览器解析到position的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，解除该元素在文档中所占位置，然而由于该元素的占位发生变化，其他元素也可能会受到回流的影响而重新排位，最终导致（3）步骤花费时间太久而影响 。</p><h2 id="CSS便捷调试法"><a href="#CSS便捷调试法" class="headerlink" title="CSS便捷调试法"></a>CSS便捷调试法</h2><ol><li><p>控制台输入神秘代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">javascript: <span class="keyword">var</span> _q = !_q;<span class="built_in">document</span>.querySelectorAll(<span class="string">'*'</span>).forEach(<span class="function"><span class="params">q</span> =&gt;</span> q.style.outline = _q ? <span class="string">'1px solid red'</span> : <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">$$(<span class="string">'*'</span>).forEach(<span class="function"><span class="params">a</span>=&gt;</span>&#123;a.style.outline=<span class="string">'1px solid red'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">xxxxxxxxx</span><br></pre></td></tr></table></figure></li><li><p>插件： Keylines ( 一键+彩色线条 )</p></li><li><p>优雅的<code>xss</code></p><ol><li>打开书签管理页</li><li>右上角三个点「添加新书签」</li><li>名称随意，粘贴以下代码到网址中</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">javascript: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.body.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line"><span class="keyword">var</span> items = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (elements[i].innerHTML.indexOf(<span class="string">'html * &#123; outline: 1px solid red &#125;'</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">items.push(elements[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (items.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">items[i].innerHTML = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML +=</span><br><span class="line"><span class="string">'&lt;style&gt;html * &#123; outline: 1px solid red &#125;&lt;/style&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p> 然后我们就可以在任意网站上点击刚才创建的书签，内部会判断是否存在调试的 <code>style</code>。存在的话就删除，不存在的话就添加，通过这种方式我们就能很方便的通过这个技巧查看任意网页的布局了。 </p></li></ol><p>效果如下：</p><p><img src="http://m.qpic.cn/psb?/V14Ny1NJ1hfPZT/kIdOUSJYDH6NCqVQAq*dhPn2fnHwFebgM1p9XdBNvsE!/b/dDYBAAAAAAAA&bo=QQd6AgAAAAADBxw!&rf=viewer_4" alt=""></p><h6 id="reference："><a href="#reference：" class="headerlink" title="reference："></a>reference：</h6><blockquote><p>浏览器渲染过程与性能优化： <a href="https://juejin.im/post/59d489156fb9a00a571d6509" target="_blank" rel="noopener">https://juejin.im/post/59d489156fb9a00a571d6509</a> ，</p><p>CSS书写顺序 ：<a href="https://www.cnblogs.com/xuepei/p/8961809.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuepei/p/8961809.html</a> ，</p><p>auto实验室 <a href="https://aotu.io/" target="_blank" rel="noopener">https://aotu.io/</a> </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包详解</title>
      <link href="/2019/02/12/closure/"/>
      <url>/2019/02/12/closure/</url>
      
        <content type="html"><![CDATA[<p>结合《你不知道的JavaScript(上)》一书，详解闭包，理清关于闭包的三个问题，彻底认识闭包。</p><a id="more"></a><h4 id="闭包详解"><a href="#闭包详解" class="headerlink" title="闭包详解"></a>闭包详解</h4><h5 id="1-什么是闭包？"><a href="#1-什么是闭包？" class="headerlink" title="1. 什么是闭包？"></a>1. 什么是闭包？</h5><blockquote><p>闭包的定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz();</span><br><span class="line">-----&gt; <span class="string">'3'</span></span><br></pre></td></tr></table></figure><p>这是一段非常经典的<code>闭包</code>代码，根据网上的说法，闭包的产生有三个条件：1. A函数内返回B函数。2.B函数调用了A函数的变量。3.B()。</p><p>很神奇有没有？ 我们在外部环境访问了内部环境的变量。并且正常执行了<code>foo</code>的作用域会被销毁掉，垃圾回收机制也会使的释放掉内存空间。显然闭包阻止了这件事情的发生。</p><h5 id="2-闭包产生的条件？"><a href="#2-闭包产生的条件？" class="headerlink" title="2.闭包产生的条件？"></a>2.闭包产生的条件？</h5><p>由于<code>bar</code>声明的位置，使其拥有涵盖了<code>foo</code>的内部作用域，当<code>bar</code>被调用后，会保持对<code>foo</code>作用域的引用，访问<code>a</code>变量。保持对外部作用域的引用，就会产生闭包，而不是非要返回函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waiting</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">waiting(<span class="string">'js'</span>)</span><br></pre></td></tr></table></figure><p>无论是什么其他的骚操作，只要你将内部函数传递到所在的<code>词法作用域</code>之外，他都会保持对内部作用域的引用，无论在哪里执行内部函数，都会创建闭包。这个例子中<code>setTimeout</code>保持对<code>waiting</code>的引用，在执行时也会创建闭包。</p><h5 id="3-闭包的用途？"><a href="#3-闭包的用途？" class="headerlink" title="3. 闭包的用途？"></a>3. 闭包的用途？</h5><p>有时候，我们希望能够重用一个变量，并且其被保护起来不被污染篡改，就可以使用闭包。这种变量一般被称为<strong>私有变量</strong>或者<strong>局部变量</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个很经典的题</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i* <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，我相信大多数搜集资料学习的人，都会清楚答案。 至于为什么，值得再复习一下。</p><p>每次循环，我们都会挑出一份<code>i</code>用来输出，但因为<code>setTimeout</code>会在循环完成后执行，每次的<code>i</code>都在同一全局作用域下，于是后来居上，覆盖了前面的<code>i</code>，再由<code>setTimeout</code>执行时，就全是6了。</p><p>怎么使得每次循环输出正确呢？ 我们只需要将每次的<code>i</code>变成一个私有变量，有独立的作用域，让其不在篡改就OK了。</p><ul><li>使用<code>IIFE</code></li></ul><p>这里引入来自<code>MDN</code>的释义。</p><hr><p><strong>IIFE</strong>（ 立即调用函数表达式）是一个在定义时就会立即执行的  <a href="https://developer.mozilla.org/en-US/docs/Glossary/JavaScript" target="_blank" rel="noopener">JavaScript</a> <a href="https://developer.mozilla.org/en-US/docs/Glossary/function" target="_blank" rel="noopener">函数</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这是一个被称为 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Self-Executing_Anonymous_Function" target="_blank" rel="noopener">自执行匿名函数</a> 的设计模式，主要包含两部分。第一部分是包围在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Grouping" target="_blank" rel="noopener"><code>圆括号运算符</code></a> <code>()</code> 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><p>第二部分再一次使用 <code>()</code> 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE方法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j* <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里利用<code>IIFE</code>拥有独立的此法作用域的特性，将变量私有化，这样在<code>setTimeout</code>执行时就会得到正确输出。没错，好像就是利用闭包将每次的变量缓存起来，放在独立的内存中。</p><ul><li>使用ES6的<code>let</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let方法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, i* <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code>会劫持块作用域，“劫持”就是把当前块作用域抢过来变为一个独立的，如果还不明白，请看下面代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> j = i;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j* <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code> 遇见<code>{}</code>发生了奇妙的邂逅，于是他们“私奔”了~  在每次循环中都被声明了一次，所以每次循环中的<code>{}</code>内的变量都不干扰。<code>setTimeout</code>很高兴的执行了。</p><p>摇晃一下你的小脑瓜，试想一下，如果我们将这些通过闭包产生的<strong>私有变量</strong>赋值给一个函数，你会联想到什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = （<span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> myPublic = <span class="string">'web工程师的自我修养'</span>；</span><br><span class="line">    <span class="keyword">var</span> mywx = [<span class="string">'tangtang1996918'</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">joinMyPublic</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'join web工程师的自我修养'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pushMywx</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(mywx.push(<span class="string">'your'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">joinMyPublic: joinMyPublic,</span><br><span class="line">    pushMywx: pushMywx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;）（）；</span><br><span class="line"></span><br><span class="line">foo.joinMyPublic();</span><br><span class="line">foo.pushMywx();</span><br></pre></td></tr></table></figure><p>是不是在项目中很常见？ 我靠，这就是模块机制啊，兄弟！！！把一些绝妙的方法都劫持过来放在自己的小空间里面，想拿来用就拿来用，岂不美哉？？？当然，现代的模块机制肯定没这么简单，嘻嘻。</p><h5 id="4-强大的闭包"><a href="#4-强大的闭包" class="headerlink" title="4. 强大的闭包"></a>4. 强大的闭包</h5><p>认识了闭包，好好想想过去一天中你所写的代码，里面有闭包吗？这是一种日常且强大的模式。</p><p>包管理器或者管理模块机制都会将<strong>模块定义</strong>和<strong>模块引入</strong>进行封装。封装到现在，已经变成了<code>import</code>和<code>export</code>或者其他的语法糖。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript-native </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
